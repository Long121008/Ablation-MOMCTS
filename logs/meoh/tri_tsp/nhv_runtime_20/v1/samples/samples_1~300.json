[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.6158149239578572,
            3.0981446623802187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.6158149239578572,
            3.0981446623802187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.6158149239578572,
            3.0981446623802187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6842166962733786,
            2.797532057762146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6842166962733786,
            2.797532057762146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6842166962733786,
            2.797532057762146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel multi-objective local search algorithm that selects a solution based on objective diversity, then applies a combination of segment reversal and node reinsertion with adaptive perturbation to explore the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply adaptive perturbation based on objective diversity\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5996510901291552,
            2.6659298658370973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply adaptive perturbation based on objective diversity\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel multi-objective local search algorithm that selects a solution based on objective diversity, then applies a combination of segment reversal and node reinsertion with adaptive perturbation to explore the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply adaptive perturbation based on objective diversity\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5996510901291552,
            2.6659298658370973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply adaptive perturbation based on objective diversity\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform segment reversal with objective-aware selection\n    segment_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate segment in all three objectives\n    segment_costs = [\n        sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))),\n        sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment))),\n        sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)))\n    ]\n\n    # Reverse segment if it improves any objective\n    if any(cost > 0 for cost in segment_costs):\n        new_solution[start:start+segment_size] = segment[::-1]\n\n    # Perform objective-aware node swaps\n    for _ in range(3):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate potential improvement in all objectives\n        improvements = [\n            distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_1[new_solution[i-1], node_i] - distance_matrix_1[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_1[new_solution[j-1], node_j] - distance_matrix_1[node_j, new_solution[(j+1)%n]],\n\n            distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_2[new_solution[i-1], node_i] - distance_matrix_2[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_2[new_solution[j-1], node_j] - distance_matrix_2[node_j, new_solution[(j+1)%n]],\n\n            distance_matrix_3[new_solution[i-1], node_j] + distance_matrix_3[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j-1], node_i] + distance_matrix_3[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_3[new_solution[i-1], node_i] - distance_matrix_3[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_3[new_solution[j-1], node_j] - distance_matrix_3[node_j, new_solution[(j+1)%n]]\n        ]\n\n        # Swap if at least one objective improves\n        if any(improvement > 0 for improvement in improvements):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6254622189786001,
            3.298504078388214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform segment reversal with objective-aware selection\n    segment_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate segment in all three objectives\n    segment_costs = [\n        sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))),\n        sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment))),\n        sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)))\n    ]\n\n    # Reverse segment if it improves any objective\n    if any(cost > 0 for cost in segment_costs):\n        new_solution[start:start+segment_size] = segment[::-1]\n\n    # Perform objective-aware node swaps\n    for _ in range(3):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate potential improvement in all objectives\n        improvements = [\n            distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_1[new_solution[i-1], node_i] - distance_matrix_1[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_1[new_solution[j-1], node_j] - distance_matrix_1[node_j, new_solution[(j+1)%n]],\n\n            distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_2[new_solution[i-1], node_i] - distance_matrix_2[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_2[new_solution[j-1], node_j] - distance_matrix_2[node_j, new_solution[(j+1)%n]],\n\n            distance_matrix_3[new_solution[i-1], node_j] + distance_matrix_3[node_j, new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j-1], node_i] + distance_matrix_3[node_i, new_solution[(j+1)%n]] -\n            distance_matrix_3[new_solution[i-1], node_i] - distance_matrix_3[node_i, new_solution[(i+1)%n]] -\n            distance_matrix_3[new_solution[j-1], node_j] - distance_matrix_3[node_j, new_solution[(j+1)%n]]\n        ]\n\n        # Swap if at least one objective improves\n        if any(improvement > 0 for improvement in improvements):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a multi-objective-aware local search that combines 3-opt with objective-specific edge swaps, ensuring feasibility by verifying node uniqueness and repairing invalid solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest combined normalized value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Multi-objective 3-opt with objective-aware edge selection\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate objective-specific edge weights\n    obj_weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    edge_weights = np.zeros(3)\n    for i in range(3):\n        edge_weights[i] = (obj_weights[i][new_solution[a], new_solution[b]] +\n                          obj_weights[i][new_solution[b], new_solution[c]])\n\n    # Select the objective with highest edge weight for this operation\n    selected_obj = np.argmax(edge_weights)\n\n    # Perform 3-opt based on the selected objective\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n\n    # Reconstruct solution in different order\n    if selected_obj == 0:\n        new_order = np.concatenate([segment1, segment3, segment2])\n    elif selected_obj == 1:\n        new_order = np.concatenate([segment2, segment1, segment3])\n    else:\n        new_order = np.concatenate([segment3, segment2, segment1])\n\n    new_solution[a:] = new_order\n\n    # Verify feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5992219105743475,
            2.9392340898513796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest combined normalized value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Multi-objective 3-opt with objective-aware edge selection\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate objective-specific edge weights\n    obj_weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    edge_weights = np.zeros(3)\n    for i in range(3):\n        edge_weights[i] = (obj_weights[i][new_solution[a], new_solution[b]] +\n                          obj_weights[i][new_solution[b], new_solution[c]])\n\n    # Select the objective with highest edge weight for this operation\n    selected_obj = np.argmax(edge_weights)\n\n    # Perform 3-opt based on the selected objective\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n\n    # Reconstruct solution in different order\n    if selected_obj == 0:\n        new_order = np.concatenate([segment1, segment3, segment2])\n    elif selected_obj == 1:\n        new_order = np.concatenate([segment2, segment1, segment3])\n    else:\n        new_order = np.concatenate([segment3, segment2, segment1])\n\n    new_solution[a:] = new_order\n\n    # Verify feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a novel local search operator: \"Objective-Driven Segment Reversal\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Evaluate the new solution's objectives\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    # If the new solution is non-dominated or better in at least one objective, accept it\n    original_obj = archive[selected_idx][1]\n    if any(new_obj[i] < original_obj[i] for i in range(3)):\n        return new_solution\n\n    # If not, try a different segment reversal\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    return new_solution\n\n",
        "score": [
            -0.5471811056183162,
            3.296879005432129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a novel local search operator: \"Objective-Driven Segment Reversal\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Evaluate the new solution's objectives\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    # If the new solution is non-dominated or better in at least one objective, accept it\n    original_obj = archive[selected_idx][1]\n    if any(new_obj[i] < original_obj[i] for i in range(3)):\n        return new_solution\n\n    # If not, try a different segment reversal\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives as a starting point\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Perform node reinsertion\n    l = np.random.randint(0, n)\n    if l not in [i, j, k]:\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:l], new_solution[l+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5911044276665044,
            4.107048606872558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives as a starting point\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Perform node reinsertion\n    l = np.random.randint(0, n)\n    if l not in [i, j, k]:\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:l], new_solution[l+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm selects a solution from the archive based on the most diverse objectives, then applies a hybrid local search combining 2-opt swaps and edge insertions to generate a neighbor solution while ensuring feasibility through diversity-based selection and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most diverse objectives\n    diversity_scores = [abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0]) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i + 1 != j and j + 1 != k:\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i+1:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Perform node reinsertion\n    m = np.random.randint(0, n)\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.44550814677321504,
            2.9843647837638856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the most diverse objectives\n    diversity_scores = [abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0]) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i + 1 != j and j + 1 != k:\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i+1:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Perform node reinsertion\n    m = np.random.randint(0, n)\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6826143314800543,
            2.5631468176841734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6826143314800543,
            2.5631468176841734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7165742229680494,
            1.876284396648407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6523830934774043,
            2.0378265261650084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest diversity in objectives, then applies a novel hybrid local search combining 3-opt swaps with objective-aware edge swapping to improve solutions across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap to improve tour structure\n    if i + 1 != j and j + 1 != k:\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i+1:k+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Objective-aware edge swapping\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate improvement potential across all objectives\n        delta1 = (distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_1[node_b, new_solution[b-1]] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_1[node_b, new_solution[b-1]] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_2[node_b, new_solution[b-1]] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_2[node_b, new_solution[b-1]] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[node_a, new_solution[a-1]] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_3[node_b, new_solution[b-1]] + distance_matrix_3[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_3[node_a, new_solution[a-1]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_3[node_b, new_solution[b-1]] + distance_matrix_3[node_b, new_solution[(b+1)%n]])\n\n        if delta1 + delta2 + delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6242437727825421,
            2.8109444975852966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap to improve tour structure\n    if i + 1 != j and j + 1 != k:\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i+1:k+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Objective-aware edge swapping\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate improvement potential across all objectives\n        delta1 = (distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_1[node_b, new_solution[b-1]] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_1[node_b, new_solution[b-1]] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_2[node_b, new_solution[b-1]] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_2[node_b, new_solution[b-1]] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[node_a, new_solution[a-1]] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n                 distance_matrix_3[node_b, new_solution[b-1]] + distance_matrix_3[node_a, new_solution[(b+1)%n]]) - \\\n                (distance_matrix_3[node_a, new_solution[a-1]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n                 distance_matrix_3[node_b, new_solution[b-1]] + distance_matrix_3[node_b, new_solution[(b+1)%n]])\n\n        if delta1 + delta2 + delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects solutions based on objective diversity and applies a hybrid of 2-opt, edge insertion, and objective-aware swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum variance in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    total_variance = np.sum(obj_variance)\n    selected_idx = np.argmax(total_variance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform 2-opt with objective-aware selection\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i + 1 != j:\n        segment = new_solution[i+1:j+1]\n        # Evaluate segment in all objectives\n        obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        # Reverse if any objective improves\n        if obj1 > sum(distance_matrix_1[segment[-1], segment[-2]] for _ in range(len(segment)-1)):\n            new_solution[i+1:j+1] = segment[::-1]\n\n    # Perform edge insertion based on objective diversity\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    # Evaluate insertion in all objectives\n    prev, next_ = new_solution[k-1], new_solution[(k+1)%n]\n    obj1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_] - distance_matrix_1[prev, next_]\n    obj2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_] - distance_matrix_2[prev, next_]\n    obj3 = distance_matrix_3[prev, node] + distance_matrix_3[node, next_] - distance_matrix_3[prev, next_]\n    # Insert if any objective improves\n    if obj1 < 0 or obj2 < 0 or obj3 < 0:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6350024235303439,
            3.334311068058014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum variance in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    total_variance = np.sum(obj_variance)\n    selected_idx = np.argmax(total_variance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform 2-opt with objective-aware selection\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i + 1 != j:\n        segment = new_solution[i+1:j+1]\n        # Evaluate segment in all objectives\n        obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        # Reverse if any objective improves\n        if obj1 > sum(distance_matrix_1[segment[-1], segment[-2]] for _ in range(len(segment)-1)):\n            new_solution[i+1:j+1] = segment[::-1]\n\n    # Perform edge insertion based on objective diversity\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    # Evaluate insertion in all objectives\n    prev, next_ = new_solution[k-1], new_solution[(k+1)%n]\n    obj1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_] - distance_matrix_1[prev, next_]\n    obj2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_] - distance_matrix_2[prev, next_]\n    obj3 = distance_matrix_3[prev, node] + distance_matrix_3[node, next_] - distance_matrix_3[prev, next_]\n    # Insert if any objective improves\n    if obj1 < 0 or obj2 < 0 or obj3 < 0:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate the total distance improvement across all three objectives\n    def calculate_improvement(solution):\n        total_improvement = 0\n        for i in range(n):\n            u, v = solution[i], solution[(i+1)%n]\n            total_improvement += (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n        return total_improvement\n\n    current_improvement = calculate_improvement(new_solution)\n\n    # Try all possible 3-opt moves and select the one with the best improvement\n    best_improvement = current_improvement\n    best_solution = new_solution.copy()\n\n    for i in [a, b, c]:\n        for j in [a, b, c]:\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_improvement = calculate_improvement(temp_solution)\n                if temp_improvement < best_improvement:\n                    best_improvement = temp_improvement\n                    best_solution = temp_solution.copy()\n\n    new_solution = best_solution.copy()\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6848907002482537,
            3.811893939971924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate the total distance improvement across all three objectives\n    def calculate_improvement(solution):\n        total_improvement = 0\n        for i in range(n):\n            u, v = solution[i], solution[(i+1)%n]\n            total_improvement += (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n        return total_improvement\n\n    current_improvement = calculate_improvement(new_solution)\n\n    # Try all possible 3-opt moves and select the one with the best improvement\n    best_improvement = current_improvement\n    best_solution = new_solution.copy()\n\n    for i in [a, b, c]:\n        for j in [a, b, c]:\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_improvement = calculate_improvement(temp_solution)\n                if temp_improvement < best_improvement:\n                    best_improvement = temp_improvement\n                    best_solution = temp_solution.copy()\n\n    new_solution = best_solution.copy()\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{The new algorithm combines a multi-objective selection criterion with a novel hybrid local search that performs a dynamic segment reversal followed by a targeted node relocation, ensuring feasibility while exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic segment reversal and targeted node relocation\n    n = len(new_solution)\n    segment_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Perform dynamic segment reversal\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Perform targeted node relocation\n    relocate_node = new_solution[np.random.randint(0, n)]\n    insert_pos = np.random.randint(0, n)\n    if insert_pos < n - 1:\n        new_solution = np.concatenate([new_solution[:insert_pos], [relocate_node], new_solution[insert_pos:-1]])\n    else:\n        new_solution = np.concatenate([new_solution[:-1], [relocate_node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6580029022904543,
            3.0089889407157897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic segment reversal and targeted node relocation\n    n = len(new_solution)\n    segment_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Perform dynamic segment reversal\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Perform targeted node relocation\n    relocate_node = new_solution[np.random.randint(0, n)]\n    insert_pos = np.random.randint(0, n)\n    if insert_pos < n - 1:\n        new_solution = np.concatenate([new_solution[:insert_pos], [relocate_node], new_solution[insert_pos:-1]])\n    else:\n        new_solution = np.concatenate([new_solution[:-1], [relocate_node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.776750955178542,
            3.3453062772750854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.776750955178542,
            3.3453062772750854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel algorithm that selects solutions based on their hypervolume contribution and applies a three-objective-aware edge exchange operator with adaptive search depth to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution (simplified)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum((objectives - np.min(objectives, axis=0)) * (np.max(objectives, axis=0) - np.min(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    depth = min(5, n // 2)  # Adaptive search depth\n\n    for _ in range(depth):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            # Three-objective aware edge exchange\n            a, b, c = new_solution[i], new_solution[i+1], new_solution[j]\n            cost_change = (distance_matrix_1[a,b] + distance_matrix_1[b,c] + distance_matrix_1[c,a] -\n                          distance_matrix_1[a,b] - distance_matrix_1[b,c] - distance_matrix_1[c,a]) + \\\n                         (distance_matrix_2[a,b] + distance_matrix_2[b,c] + distance_matrix_2[c,a] -\n                          distance_matrix_2[a,b] - distance_matrix_2[b,c] - distance_matrix_2[c,a]) + \\\n                         (distance_matrix_3[a,b] + distance_matrix_3[b,c] + distance_matrix_3[c,a] -\n                          distance_matrix_3[a,b] - distance_matrix_3[b,c] - distance_matrix_3[c,a])\n\n            if cost_change < 0:  # Only accept if beneficial for at least one objective\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6395696960374693,
            4.045617496967315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution (simplified)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum((objectives - np.min(objectives, axis=0)) * (np.max(objectives, axis=0) - np.min(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    depth = min(5, n // 2)  # Adaptive search depth\n\n    for _ in range(depth):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            # Three-objective aware edge exchange\n            a, b, c = new_solution[i], new_solution[i+1], new_solution[j]\n            cost_change = (distance_matrix_1[a,b] + distance_matrix_1[b,c] + distance_matrix_1[c,a] -\n                          distance_matrix_1[a,b] - distance_matrix_1[b,c] - distance_matrix_1[c,a]) + \\\n                         (distance_matrix_2[a,b] + distance_matrix_2[b,c] + distance_matrix_2[c,a] -\n                          distance_matrix_2[a,b] - distance_matrix_2[b,c] - distance_matrix_2[c,a]) + \\\n                         (distance_matrix_3[a,b] + distance_matrix_3[b,c] + distance_matrix_3[c,a] -\n                          distance_matrix_3[a,b] - distance_matrix_3[b,c] - distance_matrix_3[c,a])\n\n            if cost_change < 0:  # Only accept if beneficial for at least one objective\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.731078947156645,
            2.709162104129791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with probability proportional to its objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = np.sum(objectives * diversity, axis=1)\n    weights = np.maximum(weights, 0)  # Ensure non-negative\n    if np.sum(weights) == 0:\n        weights = np.ones(len(archive))\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt operator\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = (i + 1) % n\n\n    # Find best possible swap considering all three objectives\n    best_gain = -np.inf\n    best_k = -1\n    best_l = -1\n\n    for k in range(n):\n        if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n            continue\n        l = (k + 1) % n\n\n        # Calculate gains for all three objectives\n        gain1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l]]) - \\\n                (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[k], new_solution[l]])\n\n        gain2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l]]) - \\\n                (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[k], new_solution[l]])\n\n        gain3 = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                 distance_matrix_3[new_solution[j], new_solution[l]]) - \\\n                (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[k], new_solution[l]])\n\n        # Combined gain using weighted sum (weights based on diversity)\n        total_gain = gain1 * diversity[0] + gain2 * diversity[1] + gain3 * diversity[2]\n\n        if total_gain > best_gain:\n            best_gain = total_gain\n            best_k = k\n            best_l = l\n\n    if best_k != -1:\n        # Perform the swap\n        if i < best_k:\n            new_solution[i+1:best_k+1] = new_solution[i+1:best_k+1][::-1]\n        else:\n            new_solution[best_k+1:i+1] = new_solution[best_k+1:i+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6532501024675721,
            4.292539310455322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with probability proportional to its objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = np.sum(objectives * diversity, axis=1)\n    weights = np.maximum(weights, 0)  # Ensure non-negative\n    if np.sum(weights) == 0:\n        weights = np.ones(len(archive))\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt operator\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = (i + 1) % n\n\n    # Find best possible swap considering all three objectives\n    best_gain = -np.inf\n    best_k = -1\n    best_l = -1\n\n    for k in range(n):\n        if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n            continue\n        l = (k + 1) % n\n\n        # Calculate gains for all three objectives\n        gain1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l]]) - \\\n                (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[k], new_solution[l]])\n\n        gain2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l]]) - \\\n                (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[k], new_solution[l]])\n\n        gain3 = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                 distance_matrix_3[new_solution[j], new_solution[l]]) - \\\n                (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[k], new_solution[l]])\n\n        # Combined gain using weighted sum (weights based on diversity)\n        total_gain = gain1 * diversity[0] + gain2 * diversity[1] + gain3 * diversity[2]\n\n        if total_gain > best_gain:\n            best_gain = total_gain\n            best_k = k\n            best_l = l\n\n    if best_k != -1:\n        # Perform the swap\n        if i < best_k:\n            new_solution[i+1:best_k+1] = new_solution[i+1:best_k+1][::-1]\n        else:\n            new_solution[best_k+1:i+1] = new_solution[best_k+1:i+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7874278529961871,
            3.993821918964386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7874278529961871,
            3.993821918964386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The new algorithm combines multi-objective solution selection with a novel hybrid local search that integrates 2-opt, edge insertion, and objective-aware segment reversal to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.mean(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt, edge insertion, and objective-aware segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Objective-aware segment reversal\n    if np.random.rand() < 0.4:\n        # Calculate segment costs in all three objectives\n        segment = new_solution[i:j]\n        segment_costs = [\n            sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        ]\n        # Reverse if any objective shows improvement potential\n        if any(cost > 0 for cost in segment_costs):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6235417368695086,
            3.632917356491089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.mean(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt, edge insertion, and objective-aware segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Objective-aware segment reversal\n    if np.random.rand() < 0.4:\n        # Calculate segment costs in all three objectives\n        segment = new_solution[i:j]\n        segment_costs = [\n            sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        ]\n        # Reverse if any objective shows improvement potential\n        if any(cost > 0 for cost in segment_costs):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment of the tour and apply a multi-objective-aware 2-opt move\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate the total distance reduction across all three objectives\n    def calculate_delta(a, b):\n        delta = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            delta += dm[new_solution[a-1], new_solution[a]] + dm[new_solution[b-1], new_solution[b]]\n            delta -= dm[new_solution[a-1], new_solution[b-1]] + dm[new_solution[a], new_solution[b]]\n        return delta\n\n    # Apply the move if it improves at least one objective\n    if calculate_delta(a, b) < 0:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Additional diversification: randomly swap two nodes if the tour is too similar to the base solution\n    if np.array_equal(new_solution, base_solution):\n        c, d = np.random.choice(range(n), 2, replace=False)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6900290656527557,
            3.3864779353141783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment of the tour and apply a multi-objective-aware 2-opt move\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate the total distance reduction across all three objectives\n    def calculate_delta(a, b):\n        delta = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            delta += dm[new_solution[a-1], new_solution[a]] + dm[new_solution[b-1], new_solution[b]]\n            delta -= dm[new_solution[a-1], new_solution[b-1]] + dm[new_solution[a], new_solution[b]]\n        return delta\n\n    # Apply the move if it improves at least one objective\n    if calculate_delta(a, b) < 0:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Additional diversification: randomly swap two nodes if the tour is too similar to the base solution\n    if np.array_equal(new_solution, base_solution):\n        c, d = np.random.choice(range(n), 2, replace=False)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a multi-objective-aware local search that combines 3-opt with objective-specific edge swaps, ensuring feasibility by verifying node uniqueness and repairing invalid solutions.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest combined normalized value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Multi-objective 3-opt with objective-aware edge selection\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate objective-specific edge weights\n    obj_weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    edge_weights = np.zeros(3)\n    for i in range(3):\n        edge_weights[i] = (obj_weights[i][new_solution[a], new_solution[b]] +\n                          obj_weights[i][new_solution[b], new_solution[c]])\n\n    # Select the objective with highest edge weight for this operation\n    selected_obj = np.argmax(edge_weights)\n\n    # Perform 3-opt based on the selected objective\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n\n    # Reconstruct solution in different order\n    if selected_obj == 0:\n        new_order = np.concatenate([segment1, segment3, segment2])\n    elif selected_obj == 1:\n        new_order = np.concatenate([segment2, segment1, segment3])\n    else:\n        new_order = np.concatenate([segment3, segment2, segment1])\n\n    new_solution[a:] = new_order\n\n    # Verify feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objective values, then applies a multi-objective-aware local search that combines 4-opt with adaptive objective-specific edge swaps, ensuring feasibility by verifying node uniqueness and repairing invalid solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest combined normalized value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Multi-objective 4-opt with objective-aware edge selection\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Calculate objective-specific edge weights\n    obj_weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    edge_weights = np.zeros(3)\n    for i in range(3):\n        edge_weights[i] = (obj_weights[i][new_solution[a], new_solution[b]] +\n                          obj_weights[i][new_solution[c], new_solution[d]])\n\n    # Select the objective with highest edge weight for this operation\n    selected_obj = np.argmax(edge_weights)\n\n    # Perform 4-opt based on the selected objective\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n    segment4 = new_solution[d+1:] if d+1 < n else np.array([])\n\n    # Reconstruct solution in different order\n    if selected_obj == 0:\n        new_order = np.concatenate([segment1, segment4, segment3, segment2])\n    elif selected_obj == 1:\n        new_order = np.concatenate([segment2, segment3, segment1, segment4])\n    else:\n        new_order = np.concatenate([segment3, segment4, segment2, segment1])\n\n    new_solution[a:] = new_order\n\n    # Verify feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler 2-opt if 4-opt fails\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.595327046432182,
            3.1793557167053224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest combined normalized value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Multi-objective 4-opt with objective-aware edge selection\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Calculate objective-specific edge weights\n    obj_weights = np.array([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    edge_weights = np.zeros(3)\n    for i in range(3):\n        edge_weights[i] = (obj_weights[i][new_solution[a], new_solution[b]] +\n                          obj_weights[i][new_solution[c], new_solution[d]])\n\n    # Select the objective with highest edge weight for this operation\n    selected_obj = np.argmax(edge_weights)\n\n    # Perform 4-opt based on the selected objective\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n    segment4 = new_solution[d+1:] if d+1 < n else np.array([])\n\n    # Reconstruct solution in different order\n    if selected_obj == 0:\n        new_order = np.concatenate([segment1, segment4, segment3, segment2])\n    elif selected_obj == 1:\n        new_order = np.concatenate([segment2, segment3, segment1, segment4])\n    else:\n        new_order = np.concatenate([segment3, segment4, segment2, segment1])\n\n    new_solution[a:] = new_order\n\n    # Verify feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler 2-opt if 4-opt fails\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment reversal and node insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Perform segment reversal\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.choice(range(n-1))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4394769716584038,
            4.061123073101044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Perform segment reversal\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.choice(range(n-1))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6964809385523342,
            3.631229114532471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge exchange\n    if k != l and k + 1 != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6940844558520585,
            2.9028249263763426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge exchange\n    if k != l and k + 1 != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel \"objective-aware segment rotation\" local search to generate a neighbor solution while ensuring feasibility by intelligently rotating segments between nodes while considering the trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment rotation\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate segment distances in all three objectives\n    def segment_distance(s, a, b, dm1, dm2, dm3):\n        total = 0\n        for m in range(a, b):\n            total += dm1[s[m]][s[m+1]] + dm2[s[m]][s[m+1]] + dm3[s[m]][s[m+1]]\n        return total\n\n    current_dist = segment_distance(new_solution, i, j, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Try rotating segments in different ways\n    rotated_solution = new_solution.copy()\n    rotated_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    rotated_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    rotated_dist = segment_distance(rotated_solution, i, j, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    if rotated_dist < current_dist:\n        new_solution = rotated_solution\n    else:\n        # Try shifting segments\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[k:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6450564215110327,
            3.2856929063797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment rotation\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate segment distances in all three objectives\n    def segment_distance(s, a, b, dm1, dm2, dm3):\n        total = 0\n        for m in range(a, b):\n            total += dm1[s[m]][s[m+1]] + dm2[s[m]][s[m+1]] + dm3[s[m]][s[m+1]]\n        return total\n\n    current_dist = segment_distance(new_solution, i, j, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Try rotating segments in different ways\n    rotated_solution = new_solution.copy()\n    rotated_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    rotated_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    rotated_dist = segment_distance(rotated_solution, i, j, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    if rotated_dist < current_dist:\n        new_solution = rotated_solution\n    else:\n        # Try shifting segments\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[k:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel multi-objective neighbor selection algorithm that prioritizes solutions with high diversity in objective improvements and applies a hybrid 3-opt and edge-swap local search to generate neighbors, ensuring feasibility and balancing exploration across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest variance in objectives\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate edge costs across all objectives\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Evaluate potential moves\n    current_cost = edge_cost(new_solution[i-1], new_solution[i]) + edge_cost(new_solution[j-1], new_solution[j]) + edge_cost(new_solution[k-1], new_solution[k])\n    new_cost = edge_cost(new_solution[i-1], new_solution[k]) + edge_cost(new_solution[j-1], new_solution[i]) + edge_cost(new_solution[k-1], new_solution[j])\n\n    if new_cost < current_cost:\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n    else:\n        # Fall back to edge swap if 3-opt is not beneficial\n        a, b = np.random.choice(range(n), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.44286125051160974,
            3.9895289063453676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest variance in objectives\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Calculate edge costs across all objectives\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Evaluate potential moves\n    current_cost = edge_cost(new_solution[i-1], new_solution[i]) + edge_cost(new_solution[j-1], new_solution[j]) + edge_cost(new_solution[k-1], new_solution[k])\n    new_cost = edge_cost(new_solution[i-1], new_solution[k]) + edge_cost(new_solution[j-1], new_solution[i]) + edge_cost(new_solution[k-1], new_solution[j])\n\n    if new_cost < current_cost:\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n    else:\n        # Fall back to edge swap if 3-opt is not beneficial\n        a, b = np.random.choice(range(n), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.600178144946075,
            1.06874680519104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest sum\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Perform node insertion\n    if m != i and m != j and m != k:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.600178144946075,
            1.06874680519104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The new algorithm combines multi-objective selection with a novel \"objective-aware segment inversion\" operator that selectively inverts segments based on the worst-performing objective, while ensuring feasibility through a relaxed 2-opt local search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective sum\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify worst objective\n    worst_obj = np.argmax(objectives[selected_idx])\n\n    # Objective-aware segment inversion\n    n = len(new_solution)\n    if worst_obj == 0:\n        # Invert first quarter of tour\n        segment = new_solution[:n//4]\n        new_solution[:n//4] = segment[::-1]\n    elif worst_obj == 1:\n        # Invert middle quarter of tour\n        segment = new_solution[n//4:3*n//4]\n        new_solution[n//4:3*n//4] = segment[::-1]\n    else:\n        # Invert last quarter of tour\n        segment = new_solution[3*n//4:]\n        new_solution[3*n//4:] = segment[::-1]\n\n    # Relaxed 2-opt to ensure feasibility\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7167805784631365,
            3.3867942214012148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective sum\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify worst objective\n    worst_obj = np.argmax(objectives[selected_idx])\n\n    # Objective-aware segment inversion\n    n = len(new_solution)\n    if worst_obj == 0:\n        # Invert first quarter of tour\n        segment = new_solution[:n//4]\n        new_solution[:n//4] = segment[::-1]\n    elif worst_obj == 1:\n        # Invert middle quarter of tour\n        segment = new_solution[n//4:3*n//4]\n        new_solution[n//4:3*n//4] = segment[::-1]\n    else:\n        # Invert last quarter of tour\n        segment = new_solution[3*n//4:]\n        new_solution[3*n//4:] = segment[::-1]\n\n    # Relaxed 2-opt to ensure feasibility\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8025620663011376,
            3.213436150550842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8025620663011376,
            3.213436150550842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7754966857918857,
            2.541741704940796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This algorithm selects a solution from the archive based on the best trade-off between the three objectives, then applies a novel local search combining segment reversal, node insertion, and objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-aware edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Perform objective-aware edge swap\n    if l != i and l != j:\n        node1, node2 = new_solution[l], new_solution[(l+1)%n]\n        obj1 = distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]\n        obj2 = distance_matrix_1[node1, new_solution[(l+2)%n]] + distance_matrix_2[node1, new_solution[(l+2)%n]] + distance_matrix_3[node1, new_solution[(l+2)%n]]\n        if obj2 < obj1:\n            new_solution[l], new_solution[(l+1)%n] = new_solution[(l+1)%n], new_solution[l]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.623549598756853,
            2.5436323642730714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-aware edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Perform objective-aware edge swap\n    if l != i and l != j:\n        node1, node2 = new_solution[l], new_solution[(l+1)%n]\n        obj1 = distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]\n        obj2 = distance_matrix_1[node1, new_solution[(l+2)%n]] + distance_matrix_2[node1, new_solution[(l+2)%n]] + distance_matrix_3[node1, new_solution[(l+2)%n]]\n        if obj2 < obj1:\n            new_solution[l], new_solution[(l+1)%n] = new_solution[(l+1)%n], new_solution[l]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects a solution from the archive based on its objective diversity and applies a hybrid 2-opt and edge exchange operator tailored for three-dimensional objective spaces to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objective_ranges))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange based on objective diversity\n    k = np.random.randint(0, n)\n    l = (k + np.random.randint(1, n)) % n\n\n    # Swap edges in a way that maximizes objective diversity\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7068840529013978,
            3.387748968601227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objective_ranges))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange based on objective diversity\n    k = np.random.randint(0, n)\n    l = (k + np.random.randint(1, n)) % n\n\n    # Swap edges in a way that maximizes objective diversity\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A novel multi-objective TSP heuristic that intelligently selects a solution from the archive based on its dominance and applies a hybrid local search combining edge insertion, segment rotation, and adaptive node swapping to explore diverse Pareto-optimal regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, segment rotation, and adaptive node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i + 2 < j:\n        new_solution[i+1:j] = np.roll(new_solution[i+1:j], shift=1)\n\n    # Segment rotation\n    if i + 1 < j:\n        segment = new_solution[i:j+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[i:j+1] = np.roll(segment, shift=rotation)\n\n    # Adaptive node swap based on objective trade-offs\n    if k != i and k != j:\n        # Calculate objective differences\n        obj1_diff = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(k+1)%n]] -\n                    distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                    distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n        obj2_diff = (distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(k+1)%n]] -\n                    distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        obj3_diff = (distance_matrix_3[new_solution[k-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i], new_solution[(k+1)%n]] -\n                    distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7491512400547595,
            2.582768142223358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, segment rotation, and adaptive node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i + 2 < j:\n        new_solution[i+1:j] = np.roll(new_solution[i+1:j], shift=1)\n\n    # Segment rotation\n    if i + 1 < j:\n        segment = new_solution[i:j+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[i:j+1] = np.roll(segment, shift=rotation)\n\n    # Adaptive node swap based on objective trade-offs\n    if k != i and k != j:\n        # Calculate objective differences\n        obj1_diff = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(k+1)%n]] -\n                    distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                    distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n        obj2_diff = (distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(k+1)%n]] -\n                    distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        obj3_diff = (distance_matrix_3[new_solution[k-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i], new_solution[(k+1)%n]] -\n                    distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic combination of objectives using time-varying weights, then applies a hybrid local search combining 2-opt and edge exchange moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    t = len(archive) / (len(archive) + 1)  # Time-varying factor\n    weights = np.array([t, 1-t, 0.5])  # Dynamic weight combination\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and edge exchange\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 2-opt move\n    if a < b < c < d:\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Edge exchange\n    if np.random.rand() < 0.3:\n        temp = new_solution[a]\n        new_solution[a] = new_solution[c]\n        new_solution[c] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7172654238220526,
            2.4741228222846985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    t = len(archive) / (len(archive) + 1)  # Time-varying factor\n    weights = np.array([t, 1-t, 0.5])  # Dynamic weight combination\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and edge exchange\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 2-opt move\n    if a < b < c < d:\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Edge exchange\n    if np.random.rand() < 0.3:\n        temp = new_solution[a]\n        new_solution[a] = new_solution[c]\n        new_solution[c] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with balanced improvements across all three objectives, then applies a hybrid local search combining 4-opt and random segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6922881887044491,
            2.3746248960494993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic combination of objectives, where weights are adjusted based on the current diversity of the archive, then applies a hybrid local search combining 2-opt, segment reversal, and a novel multi-objective swap operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / diversity.sum() if diversity.sum() > 0 else np.ones(3)/3\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, segment reversal, and multi-objective swap\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # 2-opt move\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Segment reversal\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective swap\n    swap_nodes = np.random.choice(new_solution, size=2, replace=False)\n    idx1, idx2 = np.where(new_solution == swap_nodes[0])[0][0], np.where(new_solution == swap_nodes[1])[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7650913367224138,
            2.456178939342499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / diversity.sum() if diversity.sum() > 0 else np.ones(3)/3\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, segment reversal, and multi-objective swap\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # 2-opt move\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Segment reversal\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective swap\n    swap_nodes = np.random.choice(new_solution, size=2, replace=False)\n    idx1, idx2 = np.where(new_solution == swap_nodes[0])[0][0], np.where(new_solution == swap_nodes[1])[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining 2-opt and node swap moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1] + objectives[:, 2]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel \"multi-objective segment reversal\" operator that reverses segments of the tour while considering trade-offs across all three objectives to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for multi-objective selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    # Select solution with lowest crowding distance (most under-explored)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment reversal operator\n    n = len(new_solution)\n    segment_length = np.random.randint(3, min(8, n//2))\n    start = np.random.randint(0, n - segment_length)\n\n    # Reverse the segment while considering objective trade-offs\n    segment = new_solution[start:start+segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the effect on each objective\n    original_costs = [\n        sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]],\n        sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]],\n        sum(distance_matrix_3[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_3[base_solution[-1], base_solution[0]]\n    ]\n\n    temp_solution = new_solution.copy()\n    temp_solution[start:start+segment_length] = reversed_segment\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n    ]\n\n    # Accept the move if at least one objective improves\n    if any(new_costs[m] < original_costs[m] for m in range(3)):\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different segment\n        new_solution = base_solution.copy()\n        new_solution[start:start+segment_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6031671993186986,
            3.602205491065979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for multi-objective selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    # Select solution with lowest crowding distance (most under-explored)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment reversal operator\n    n = len(new_solution)\n    segment_length = np.random.randint(3, min(8, n//2))\n    start = np.random.randint(0, n - segment_length)\n\n    # Reverse the segment while considering objective trade-offs\n    segment = new_solution[start:start+segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the effect on each objective\n    original_costs = [\n        sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]],\n        sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]],\n        sum(distance_matrix_3[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_3[base_solution[-1], base_solution[0]]\n    ]\n\n    temp_solution = new_solution.copy()\n    temp_solution[start:start+segment_length] = reversed_segment\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n    ]\n\n    # Accept the move if at least one objective improves\n    if any(new_costs[m] < original_costs[m] for m in range(3)):\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different segment\n        new_solution = base_solution.copy()\n        new_solution[start:start+segment_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation and node reinsertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    m = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform node reinsertion\n    if m != i and m != j:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.804404701158453,
            2.403682363033295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7837616220655585,
            2.861217975616455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three distinct positions for 3-opt move\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Generate all possible 3-opt moves and evaluate their cost across all objectives\n    moves = [\n        (a, b, c), (a, c, b),  # Reverse segments\n        (b, a, c), (b, c, a),  # Swap segments\n        (c, a, b), (c, b, a)    # Swap segments\n    ]\n\n    best_move = None\n    best_cost = float('inf')\n\n    for move in moves:\n        # Calculate the cost of the new tour segment\n        i, j, k = move\n        cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[j-1], new_solution[k]] +\n                distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[j-1], new_solution[k]] +\n                distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[j-1], new_solution[k]] +\n                distance_matrix_3[new_solution[k-1], new_solution[i]])\n\n        if cost < best_cost:\n            best_cost = cost\n            best_move = move\n\n    if best_move:\n        i, j, k = best_move\n        # Apply the best 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6250661767576504,
            2.988612914085388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three distinct positions for 3-opt move\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Generate all possible 3-opt moves and evaluate their cost across all objectives\n    moves = [\n        (a, b, c), (a, c, b),  # Reverse segments\n        (b, a, c), (b, c, a),  # Swap segments\n        (c, a, b), (c, b, a)    # Swap segments\n    ]\n\n    best_move = None\n    best_cost = float('inf')\n\n    for move in moves:\n        # Calculate the cost of the new tour segment\n        i, j, k = move\n        cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[j-1], new_solution[k]] +\n                distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[j-1], new_solution[k]] +\n                distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[j-1], new_solution[k]] +\n                distance_matrix_3[new_solution[k-1], new_solution[i]])\n\n        if cost < best_cost:\n            best_cost = cost\n            best_move = move\n\n    if best_move:\n        i, j, k = best_move\n        # Apply the best 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search strategy that combines multi-objective-aware edge swapping with a novel segment inversion technique to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective-aware edge swapping with segment inversion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform edge swap with multi-objective consideration\n    if np.random.random() < 0.5:\n        # Swap edges based on combined distance improvement\n        total_improvement = 0\n        for d in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current = d[new_solution[i-1], new_solution[i]] + d[new_solution[j-1], new_solution[j]]\n            swapped = d[new_solution[i-1], new_solution[j]] + d[new_solution[j-1], new_solution[i]]\n            total_improvement += (current - swapped)\n\n        if total_improvement > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7326174520888151,
            2.7826206207275392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective-aware edge swapping with segment inversion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform edge swap with multi-objective consideration\n    if np.random.random() < 0.5:\n        # Swap edges based on combined distance improvement\n        total_improvement = 0\n        for d in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current = d[new_solution[i-1], new_solution[i]] + d[new_solution[j-1], new_solution[j]]\n            swapped = d[new_solution[i-1], new_solution[j]] + d[new_solution[j-1], new_solution[i]]\n            total_improvement += (current - swapped)\n\n        if total_improvement > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off (minimize sum of objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, where weights are dynamically adjusted to prioritize objectives with higher variance, then applies a hybrid local search combining segment reversal, node insertion, and 2-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on objective variances\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.ones(3) / 3\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and 2-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform 2-opt\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    if a + 1 < b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6856001977097883,
            2.6769527554512025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on objective variances\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.ones(3) / 3\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and 2-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    if i + 1 < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform 2-opt\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    if a + 1 < b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with balanced improvements across all three objectives, then applies a hybrid local search combining 4-opt and random segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes solutions with better performance in the most critical objective, then applies a hybrid local search combining 2-opt and random segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7533385166825984,
            2.421829867362976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest diversity in its objective values, then applies a novel local search strategy that combines 2-opt swaps with multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: 2-opt with multi-objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    if j - i > 1:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l and k != (l + 1) % n and l != (k + 1) % n:\n        # Calculate edge cost changes for all three objectives\n        cost_change = (\n            distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]] -\n            distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] - distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]] -\n            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] - distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]] -\n            distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] - distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n        )\n\n        # Accept if any objective improves\n        if any(cost_change[obj] < 0 for obj in range(3)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7789246570586232,
            3.027314043045044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: 2-opt with multi-objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    if j - i > 1:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l and k != (l + 1) % n and l != (k + 1) % n:\n        # Calculate edge cost changes for all three objectives\n        cost_change = (\n            distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]] -\n            distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] - distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]] -\n            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] - distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]] -\n            distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] - distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n        )\n\n        # Accept if any objective improves\n        if any(cost_change[obj] < 0 for obj in range(3)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of objective values (diversity-based selection)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6587740226913822,
            3.8311955094337464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of objective values (diversity-based selection)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n\n    # Select edges to swap based on objective-aware criteria\n    def objective_aware_edge_selection():\n        # Calculate edge costs across all objectives\n        edge_costs = np.zeros(n)\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_costs[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n        # Select edges with highest combined cost (potential for improvement)\n        sorted_edges = np.argsort(edge_costs)[::-1]\n        return sorted_edges[0], sorted_edges[1]\n\n    i, j = objective_aware_edge_selection()\n\n    # Apply 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7135381018969198,
            3.814563572406769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n\n    # Select edges to swap based on objective-aware criteria\n    def objective_aware_edge_selection():\n        # Calculate edge costs across all objectives\n        edge_costs = np.zeros(n)\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_costs[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n        # Select edges with highest combined cost (potential for improvement)\n        sorted_edges = np.argsort(edge_costs)[::-1]\n        return sorted_edges[0], sorted_edges[1]\n\n    i, j = objective_aware_edge_selection()\n\n    # Apply 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with balanced improvements across all three objectives, then applies a hybrid local search combining 4-opt and random segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This new algorithm selects a solution from the archive based on the worst-performing objective to promote diversity, then applies a novel \"objective-aware\" local search that combines random segment reversal with targeted edge swaps based on the most improved objective, ensuring feasibility through careful segment manipulation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective to promote diversity\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Objective-aware local search\n    # Step 1: Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Targeted edge swaps based on most improved objective\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    for obj_idx in range(3):\n        if objectives[worst_obj_idx][obj_idx] > objectives.mean(axis=0)[obj_idx]:\n            # Find worst edge in this objective\n            worst_edge = None\n            worst_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrices[obj_idx][u, v]\n                if dist > worst_dist:\n                    worst_dist = dist\n                    worst_edge = (i, (i+1)%n)\n\n            if worst_edge:\n                # Swap nodes in the worst edge\n                i, j = worst_edge\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.47321617777831093,
            2.8696155667304994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with worst objective to promote diversity\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Objective-aware local search\n    # Step 1: Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Targeted edge swaps based on most improved objective\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    for obj_idx in range(3):\n        if objectives[worst_obj_idx][obj_idx] > objectives.mean(axis=0)[obj_idx]:\n            # Find worst edge in this objective\n            worst_edge = None\n            worst_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrices[obj_idx][u, v]\n                if dist > worst_dist:\n                    worst_dist = dist\n                    worst_edge = (i, (i+1)%n)\n\n            if worst_edge:\n                # Swap nodes in the worst edge\n                i, j = worst_edge\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This algorithm selects a solution from the archive based on objective diversity and performs a novel multi-objective aware local search by combining adaptive segment rotation with targeted node insertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Targeted node insertion based on objective improvement\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        b = np.random.choice([i for i in range(n) if i != a])\n        node = new_solution[a]\n\n        # Calculate cost before removal\n        before_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]\n        ]\n\n        # Calculate cost after insertion\n        after_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n        ]\n\n        if sum(after_costs) < sum(before_costs) or np.random.random() < 0.15:\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6883091368297913,
            4.105040144920349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Targeted node insertion based on objective improvement\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        b = np.random.choice([i for i in range(n) if i != a])\n        node = new_solution[a]\n\n        # Calculate cost before removal\n        before_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]\n        ]\n\n        # Calculate cost after insertion\n        after_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n        ]\n\n        if sum(after_costs) < sum(before_costs) or np.random.random() < 0.15:\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic combination of objectives, where weights are adjusted based on the current diversity of the archive, then applies a hybrid local search combining 2-opt, segment reversal, and a novel multi-objective swap operator to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / diversity.sum() if diversity.sum() > 0 else np.ones(3)/3\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, segment reversal, and multi-objective swap\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # 2-opt move\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Segment reversal\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective swap\n    swap_nodes = np.random.choice(new_solution, size=2, replace=False)\n    idx1, idx2 = np.where(new_solution == swap_nodes[0])[0][0], np.where(new_solution == swap_nodes[1])[0][0]\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective preference that adapts to the current archive diversity, then applies a novel combination of multi-objective-aware segment crossover and adaptive node displacement to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic objective preference\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / diversity.sum() if diversity.sum() > 0 else np.ones(3)/3\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective-aware segment crossover\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n\n    # Adaptive node displacement\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6791641826672536,
            2.4639068961143495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic objective preference\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / diversity.sum() if diversity.sum() > 0 else np.ones(3)/3\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective-aware segment crossover\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n\n    # Adaptive node displacement\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the highest sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt swap\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Perform edge reversal\n    if np.random.rand() < 0.5:\n        m = np.random.randint(1, n)\n        new_solution[m:] = new_solution[m:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with balanced improvements across all three objectives, then applies a hybrid local search combining 4-opt and random segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection criterion that prioritizes solutions with high potential for improvement in all three objectives, then applies a hybrid local search combining segment reversal, node swapping, and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    diversity_scores = normalized_scores.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node swapping, and adaptive edge insertion\n    n = len(new_solution)\n\n    # Segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node swapping\n    i, j = np.random.choice(range(n), 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge insertion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(1, n-1)\n        if k != l:\n            edge1 = (new_solution[k-1], new_solution[k])\n            edge2 = (new_solution[l], new_solution[l+1])\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6249349739090115,
            2.578118312358856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    diversity_scores = normalized_scores.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node swapping, and adaptive edge insertion\n    n = len(new_solution)\n\n    # Segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node swapping\n    i, j = np.random.choice(range(n), 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge insertion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(1, n-1)\n        if k != l:\n            edge1 = (new_solution[k-1], new_solution[k])\n            edge2 = (new_solution[l], new_solution[l+1])\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 2-opt and insertion moves with probabilistic acceptance criteria to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(normalized_scores.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with probabilistic insertion\n    n = len(new_solution)\n\n    # 2-opt move\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Insertion move with probability\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(range(n), 2, replace=False)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6085678818821021,
            2.6884426712989806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(normalized_scores.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with probabilistic insertion\n    n = len(new_solution)\n\n    # 2-opt move\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Insertion move with probability\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(range(n), 2, replace=False)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with balanced improvements across all three objectives, then applies a hybrid local search combining 4-opt and random segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection that prioritizes solutions with high variance in objective values, then applies a hybrid local search combining edge swaps and random segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance\n    objectives = np.array([obj for _, obj in archive])\n    variances = objectives.var(axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Edge swap\n    if a < b < c < d:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Random segment reversal\n    e, f = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[e:f+1] = new_solution[e:f+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.521537928395224,
            2.6372109413146974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance\n    objectives = np.array([obj for _, obj in archive])\n    variances = objectives.var(axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Edge swap\n    if a < b < c < d:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Random segment reversal\n    e, f = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[e:f+1] = new_solution[e:f+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-segment inversion and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    m = np.random.randint(n)\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6032958642294457,
            3.359850549697876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-segment inversion and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    m = np.random.randint(n)\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers the Pareto front's spread and diversity, then applies a hybrid local search combining multi-segment reversal with objective-aware node insertion, ensuring feasibility while balancing exploration of trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    crowding_distances = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-segment reversal with objective awareness\n    segments = np.random.choice([2, 3, 4], p=[0.5, 0.3, 0.2])\n    points = sorted(np.random.choice(range(n), segments + 1, replace=False))\n    for i in range(len(points) - 1):\n        start, end = points[i], points[i+1]\n        new_solution[start:end+1] = new_solution[end:start-1 if start > 0 else None:-1]\n\n    # Objective-aware node insertion\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6722249050879007,
            3.5036261320114135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    crowding_distances = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-segment reversal with objective awareness\n    segments = np.random.choice([2, 3, 4], p=[0.5, 0.3, 0.2])\n    points = sorted(np.random.choice(range(n), segments + 1, replace=False))\n    for i in range(len(points) - 1):\n        start, end = points[i], points[i+1]\n        new_solution[start:end+1] = new_solution[end:start-1 if start > 0 else None:-1]\n\n    # Objective-aware node insertion\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with balanced improvements across all three objectives, then applies a hybrid local search combining 4-opt and random segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective rank that prioritizes solutions with good performance in at least two objectives, then applies a hybrid local search combining edge exchange and node relocation with a probability-based selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with good performance in at least two objectives\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    selected_idx = np.argmin(np.sum(ranks < 0.5 * len(archive), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange and node relocation\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Edge exchange\n    if np.random.rand() < 0.7:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Node relocation\n    if np.random.rand() < 0.5:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6496794527533838,
            2.2931840896606444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with good performance in at least two objectives\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    selected_idx = np.argmin(np.sum(ranks < 0.5 * len(archive), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange and node relocation\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Edge exchange\n    if np.random.rand() < 0.7:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Node relocation\n    if np.random.rand() < 0.5:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes solutions with better performance in the most critical objective, then applies a hybrid local search combining 2-opt and random segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7271321614092314,
            1.380692183971405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy that combines segment reversal, multi-objective-aware node swapping, and distance-aware insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    combined_scores = np.mean(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node swapping, and distance-aware insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swapping\n    if k != i and k != j:\n        node1 = new_solution[k]\n        node2 = new_solution[(k+1)%n]\n        total_distance = (distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]) / 3\n        if total_distance > (distance_matrix_1[node1, new_solution[(k-1)%n]] + distance_matrix_2[node1, new_solution[(k-1)%n]] + distance_matrix_3[node1, new_solution[(k-1)%n]]) / 3:\n            new_solution[k], new_solution[(k-1)%n] = new_solution[(k-1)%n], new_solution[k]\n\n    # Perform distance-aware insertion\n    if i != k and j != k:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        best_pos = 0\n        min_distance = float('inf')\n        for pos in range(n-1):\n            total_distance = (distance_matrix_1[node, new_solution[pos]] + distance_matrix_2[node, new_solution[pos]] + distance_matrix_3[node, new_solution[pos]]) / 3\n            total_distance += (distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]] + distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]] + distance_matrix_3[new_solution[pos], new_solution[(pos+1)%(n-1)]]) / 3\n            if total_distance < min_distance:\n                min_distance = total_distance\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5707869593114986,
            3.3466681241989136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    combined_scores = np.mean(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node swapping, and distance-aware insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swapping\n    if k != i and k != j:\n        node1 = new_solution[k]\n        node2 = new_solution[(k+1)%n]\n        total_distance = (distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]) / 3\n        if total_distance > (distance_matrix_1[node1, new_solution[(k-1)%n]] + distance_matrix_2[node1, new_solution[(k-1)%n]] + distance_matrix_3[node1, new_solution[(k-1)%n]]) / 3:\n            new_solution[k], new_solution[(k-1)%n] = new_solution[(k-1)%n], new_solution[k]\n\n    # Perform distance-aware insertion\n    if i != k and j != k:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        best_pos = 0\n        min_distance = float('inf')\n        for pos in range(n-1):\n            total_distance = (distance_matrix_1[node, new_solution[pos]] + distance_matrix_2[node, new_solution[pos]] + distance_matrix_3[node, new_solution[pos]]) / 3\n            total_distance += (distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]] + distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]] + distance_matrix_3[new_solution[pos], new_solution[(pos+1)%(n-1)]]) / 3\n            if total_distance < min_distance:\n                min_distance = total_distance\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2.5-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 2.5-opt move: reverse segments between i, j, and k while preserving order\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.539936122346533,
            4.398335587978363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2.5-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 2.5-opt move: reverse segments between i, j, and k while preserving order\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive with the most balanced trade-off across objectives, then applies a hybrid local search combining segment inversion and node swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7568459331280453,
            3.4815101623535156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle with adaptive segment size\n    n = len(new_solution)\n    segment_size = max(2, min(10, n // 3))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives with weighted cost\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate weighted cost for swapping nodes i and j across all objectives\n                original_cost = (0.4 * distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                0.3 * distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                0.3 * distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (0.4 * distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              0.3 * distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              0.3 * distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6937454371146594,
            1.7077110886573792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle with adaptive segment size\n    n = len(new_solution)\n    segment_size = max(2, min(10, n // 3))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives with weighted cost\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate weighted cost for swapping nodes i and j across all objectives\n                original_cost = (0.4 * distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                0.3 * distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                0.3 * distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (0.4 * distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              0.3 * distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              0.3 * distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects a solution from the archive based on its objective diversity and applies a hybrid 2-opt and edge exchange operator tailored for three-dimensional objective spaces to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objective_ranges))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange based on objective diversity\n    k = np.random.randint(0, n)\n    l = (k + np.random.randint(1, n)) % n\n\n    # Swap edges in a way that maximizes objective diversity\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid 3-opt and edge reversal operator to generate neighbors, ensuring feasibility by maintaining valid TSP tours while optimizing across three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objective_ranges))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:i]\n\n    # Randomly reverse segments\n    if np.random.rand() < 0.5:\n        segment1 = segment1[::-1]\n    if np.random.rand() < 0.5:\n        segment2 = segment2[::-1]\n    if np.random.rand() < 0.5:\n        segment3 = segment3[::-1]\n\n    # Reconstruct solution\n    new_solution = np.concatenate([segment1, segment2, segment3])\n\n    # Edge reversal based on objective diversity\n    l = np.random.randint(0, n)\n    m = (l + np.random.randint(1, n)) % n\n\n    # Reverse a segment to maximize objective diversity\n    if np.random.rand() < 0.5:\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.697989882533451,
            4.403340697288513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objective_ranges))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with edge reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:i]\n\n    # Randomly reverse segments\n    if np.random.rand() < 0.5:\n        segment1 = segment1[::-1]\n    if np.random.rand() < 0.5:\n        segment2 = segment2[::-1]\n    if np.random.rand() < 0.5:\n        segment3 = segment3[::-1]\n\n    # Reconstruct solution\n    new_solution = np.concatenate([segment1, segment2, segment3])\n\n    # Edge reversal based on objective diversity\n    l = np.random.randint(0, n)\n    m = (l + np.random.randint(1, n)) % n\n\n    # Reverse a segment to maximize objective diversity\n    if np.random.rand() < 0.5:\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced objective values (using the geometric mean to avoid bias towards any single objective) and applies a novel multi-objective inversion operator that flips segments of the tour while considering the combined effect on all three objectives, with a probabilistic acceptance criterion to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (geometric mean)\n    objectives = np.array([obj for _, obj in archive])\n    geometric_mean = np.exp(np.mean(np.log(objectives + 1e-10), axis=1))\n    selected_idx = np.argmax(geometric_mean)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective inversion operator\n    n = len(new_solution)\n    segment_size = max(2, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Calculate segment inversion cost across all objectives\n    def calculate_segment_cost(solution, start, end):\n        cost = 0\n        for i in range(start, end):\n            prev = solution[i-1] if i > 0 else solution[-1]\n            curr = solution[i]\n            next_node = solution[i+1] if i < len(solution)-1 else solution[0]\n            cost += (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] + distance_matrix_3[prev, curr] +\n                     distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node] + distance_matrix_3[curr, next_node])\n        return cost\n\n    original_cost = calculate_segment_cost(new_solution, start, end)\n    inverted_segment = new_solution[start:end][::-1]\n    new_solution[start:end] = inverted_segment\n    inverted_cost = calculate_segment_cost(new_solution, start, end)\n\n    # Accept with probability based on cost improvement\n    cost_diff = inverted_cost - original_cost\n    if cost_diff > 0 and np.random.random() < np.exp(-cost_diff / np.mean(objectives[selected_idx])):\n        new_solution[start:end] = inverted_segment[::-1]  # Revert if not accepted\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7470027018226444,
            4.473057436943054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (geometric mean)\n    objectives = np.array([obj for _, obj in archive])\n    geometric_mean = np.exp(np.mean(np.log(objectives + 1e-10), axis=1))\n    selected_idx = np.argmax(geometric_mean)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective inversion operator\n    n = len(new_solution)\n    segment_size = max(2, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Calculate segment inversion cost across all objectives\n    def calculate_segment_cost(solution, start, end):\n        cost = 0\n        for i in range(start, end):\n            prev = solution[i-1] if i > 0 else solution[-1]\n            curr = solution[i]\n            next_node = solution[i+1] if i < len(solution)-1 else solution[0]\n            cost += (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] + distance_matrix_3[prev, curr] +\n                     distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node] + distance_matrix_3[curr, next_node])\n        return cost\n\n    original_cost = calculate_segment_cost(new_solution, start, end)\n    inverted_segment = new_solution[start:end][::-1]\n    new_solution[start:end] = inverted_segment\n    inverted_cost = calculate_segment_cost(new_solution, start, end)\n\n    # Accept with probability based on cost improvement\n    cost_diff = inverted_cost - original_cost\n    if cost_diff > 0 and np.random.random() < np.exp(-cost_diff / np.mean(objectives[selected_idx])):\n        new_solution[start:end] = inverted_segment[::-1]  # Revert if not accepted\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel multi-objective local search algorithm that combines diverse solution selection with a hybrid 2-opt and insertion operator, prioritizing solutions with balanced objective improvements and applying a weighted cost evaluation to generate high-quality neighbors across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvement_scores = np.mean((objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8), axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform weighted insertion\n    removed_node = new_solution[k]\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        weight1 = 0.4  # Weight for first objective\n        weight2 = 0.3  # Weight for second objective\n        weight3 = 0.3  # Weight for third objective\n\n        cost = (weight1 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weight2 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weight3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6986525391200685,
            3.4562804460525514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvement_scores = np.mean((objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8), axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform weighted insertion\n    removed_node = new_solution[k]\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        weight1 = 0.4  # Weight for first objective\n        weight2 = 0.3  # Weight for second objective\n        weight3 = 0.3  # Weight for third objective\n\n        cost = (weight1 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weight2 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weight3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{A novel heuristic selects solutions with high combined objective values from the archive and applies a hybrid 3-opt and 2-opt local search strategy, combining segment reversals and edge swaps to explore diverse neighborhoods while ensuring feasibility through intelligent repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with probabilistic 2-opt\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move with probability 0.7, otherwise 2-opt\n    if np.random.random() < 0.7:\n        # 3-opt: reverse segments between i, j, and k\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n    else:\n        # 2-opt: reverse segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n        # Apply random 2-opt as fallback\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6511107622734454,
            1.9644233345985413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with probabilistic 2-opt\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move with probability 0.7, otherwise 2-opt\n    if np.random.random() < 0.7:\n        # 3-opt: reverse segments between i, j, and k\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n    else:\n        # 2-opt: reverse segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n        # Apply random 2-opt as fallback\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that balances all three objectives equally, then applies a hybrid local search strategy that combines segment reversal with adaptive node insertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = np.mean(objectives / np.max(objectives, axis=0), axis=1)\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive node insertion\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Adaptive node insertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[b-1]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7380784414149641,
            2.982565152645111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = np.mean(objectives / np.max(objectives, axis=0), axis=1)\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive node insertion\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Adaptive node insertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[b-1]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most Pareto-frontier diversity\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.linalg.norm(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective path relinking with node insertion\n    n = len(new_solution)\n    k = np.random.randint(1, n//2)\n\n    # Randomly select k nodes to relocate\n    nodes_to_relocate = np.random.choice(new_solution, size=k, replace=False)\n    new_solution = np.setdiff1d(new_solution, nodes_to_relocate)\n\n    # Find best insertion points considering all three objectives\n    best_insert_positions = []\n    for node in nodes_to_relocate:\n        insertion_costs = np.zeros(len(new_solution) + 1)\n        for i in range(len(insertion_costs)):\n            if i == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            elif i == len(new_solution):\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n            # Calculate cost across all three objectives\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                    distance_matrix_1[prev_node, next_node])\n            cost += (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                    distance_matrix_2[prev_node, next_node])\n            cost += (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n            insertion_costs[i] = cost\n\n        best_pos = np.argmin(insertion_costs)\n        best_insert_positions.append((node, best_pos))\n\n    # Insert nodes at best positions\n    for node, pos in sorted(best_insert_positions, key=lambda x: x[1], reverse=True):\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.683955178227088,
            3.6401757836341857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most Pareto-frontier diversity\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.linalg.norm(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective path relinking with node insertion\n    n = len(new_solution)\n    k = np.random.randint(1, n//2)\n\n    # Randomly select k nodes to relocate\n    nodes_to_relocate = np.random.choice(new_solution, size=k, replace=False)\n    new_solution = np.setdiff1d(new_solution, nodes_to_relocate)\n\n    # Find best insertion points considering all three objectives\n    best_insert_positions = []\n    for node in nodes_to_relocate:\n        insertion_costs = np.zeros(len(new_solution) + 1)\n        for i in range(len(insertion_costs)):\n            if i == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            elif i == len(new_solution):\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n            # Calculate cost across all three objectives\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                    distance_matrix_1[prev_node, next_node])\n            cost += (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                    distance_matrix_2[prev_node, next_node])\n            cost += (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n            insertion_costs[i] = cost\n\n        best_pos = np.argmin(insertion_costs)\n        best_insert_positions.append((node, best_pos))\n\n    # Insert nodes at best positions\n    for node, pos in sorted(best_insert_positions, key=lambda x: x[1], reverse=True):\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6653237518155988,
            1.0276680707931518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6653237518155988,
            1.0276680707931518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off (minimize sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Shuffle segment considering all three objectives\n    segment = new_solution[start:end]\n    segment_costs = np.zeros((len(segment), len(segment)))\n\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                # Calculate cost for swapping nodes i and j across all objectives\n                original_cost = (distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] +\n                                distance_matrix_3[segment[i], segment[(i+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]])\n                segment_costs[i,j] = swapped_cost - original_cost\n\n    # Find best swap to minimize total cost across objectives\n    best_swap = np.unravel_index(np.argmin(segment_costs), segment_costs.shape)\n    if best_swap[0] != best_swap[1]:\n        segment[best_swap[0]], segment[best_swap[1]] = segment[best_swap[1]], segment[best_swap[0]]\n\n    # Reinsert segment with node reordering based on all objectives\n    reinsert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:reinsert_pos],\n        segment,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced trade-off across objectives, then applies a hybrid local search combining multi-objective-aware edge swaps, segment rotations, and node reinsertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balanced trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: multi-objective edge swaps\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or j == (i+1)%n:\n            continue\n\n        # Calculate cost difference for all objectives\n        cost_diff = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_2[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_3[new_solution[i], new_solution[j]] +\n                    distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost_diff < 0:\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotation with multi-objective consideration\n    segment_size = max(2, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Evaluate segment rotations\n    rotation_costs = []\n    for r in range(1, len(segment)):\n        rotated = np.roll(segment, r)\n        cost = 0\n        for i in range(len(rotated)):\n            prev = rotated[i-1] if i > 0 else new_solution[start-1] if start > 0 else new_solution[-1]\n            curr = rotated[i]\n            next_node = rotated[(i+1)%len(rotated)] if i < len(rotated)-1 else new_solution[end] if end < n else new_solution[0]\n            cost += (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                    distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                    distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node])\n        rotation_costs.append(cost)\n\n    if rotation_costs:\n        best_rotation = np.argmin(rotation_costs) + 1\n        new_solution[start:end] = np.roll(segment, best_rotation)\n\n    # Node reinsertion with multi-objective consideration\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position across objectives\n    insertion_costs = []\n    for pos in range(n-1):\n        prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n        cost = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] -\n               distance_matrix_1[prev, next_node] +\n               distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] -\n               distance_matrix_2[prev, next_node] +\n               distance_matrix_3[prev, node] + distance_matrix_3[node, next_node] -\n               distance_matrix_3[prev, next_node])\n        insertion_costs.append(cost)\n\n    if insertion_costs:\n        best_pos = np.argmin(insertion_costs)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6848221304110249,
            4.3546840190887455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balanced trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(norm_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: multi-objective edge swaps\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or j == (i+1)%n:\n            continue\n\n        # Calculate cost difference for all objectives\n        cost_diff = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_2[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_3[new_solution[i], new_solution[j]] +\n                    distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost_diff < 0:\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotation with multi-objective consideration\n    segment_size = max(2, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Evaluate segment rotations\n    rotation_costs = []\n    for r in range(1, len(segment)):\n        rotated = np.roll(segment, r)\n        cost = 0\n        for i in range(len(rotated)):\n            prev = rotated[i-1] if i > 0 else new_solution[start-1] if start > 0 else new_solution[-1]\n            curr = rotated[i]\n            next_node = rotated[(i+1)%len(rotated)] if i < len(rotated)-1 else new_solution[end] if end < n else new_solution[0]\n            cost += (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                    distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                    distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node])\n        rotation_costs.append(cost)\n\n    if rotation_costs:\n        best_rotation = np.argmin(rotation_costs) + 1\n        new_solution[start:end] = np.roll(segment, best_rotation)\n\n    # Node reinsertion with multi-objective consideration\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position across objectives\n    insertion_costs = []\n    for pos in range(n-1):\n        prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n        cost = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] -\n               distance_matrix_1[prev, next_node] +\n               distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] -\n               distance_matrix_2[prev, next_node] +\n               distance_matrix_3[prev, node] + distance_matrix_3[node, next_node] -\n               distance_matrix_3[prev, next_node])\n        insertion_costs.append(cost)\n\n    if insertion_costs:\n        best_pos = np.argmin(insertion_costs)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-based local search\n    n = len(new_solution)\n    edge_scores = np.zeros(n)\n\n    # Calculate edge scores based on improvement potential across all objectives\n    for i in range(n):\n        current_node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement for each objective\n        obj1_improvement = (distance_matrix_1[prev_node, next_node] -\n                           (distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]))\n        obj2_improvement = (distance_matrix_2[prev_node, next_node] -\n                           (distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]))\n        obj3_improvement = (distance_matrix_3[prev_node, next_node] -\n                           (distance_matrix_3[prev_node, current_node] + distance_matrix_3[current_node, next_node]))\n\n        edge_scores[i] = (obj1_improvement + obj2_improvement + obj3_improvement) / 3\n\n    # Select edges with highest improvement potential\n    top_edges = np.argsort(edge_scores)[-min(3, n):]\n\n    # Perform edge-based swaps\n    for edge in top_edges:\n        if edge == 0:\n            new_solution[edge], new_solution[edge+1] = new_solution[edge+1], new_solution[edge]\n        elif edge == n-1:\n            new_solution[edge], new_solution[0] = new_solution[0], new_solution[edge]\n        else:\n            new_solution[edge], new_solution[edge+1] = new_solution[edge+1], new_solution[edge]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6425617958195988,
            3.4432846784591673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-based local search\n    n = len(new_solution)\n    edge_scores = np.zeros(n)\n\n    # Calculate edge scores based on improvement potential across all objectives\n    for i in range(n):\n        current_node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement for each objective\n        obj1_improvement = (distance_matrix_1[prev_node, next_node] -\n                           (distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]))\n        obj2_improvement = (distance_matrix_2[prev_node, next_node] -\n                           (distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]))\n        obj3_improvement = (distance_matrix_3[prev_node, next_node] -\n                           (distance_matrix_3[prev_node, current_node] + distance_matrix_3[current_node, next_node]))\n\n        edge_scores[i] = (obj1_improvement + obj2_improvement + obj3_improvement) / 3\n\n    # Select edges with highest improvement potential\n    top_edges = np.argsort(edge_scores)[-min(3, n):]\n\n    # Perform edge-based swaps\n    for edge in top_edges:\n        if edge == 0:\n            new_solution[edge], new_solution[edge+1] = new_solution[edge+1], new_solution[edge]\n        elif edge == n-1:\n            new_solution[edge], new_solution[0] = new_solution[0], new_solution[edge]\n        else:\n            new_solution[edge], new_solution[edge+1] = new_solution[edge+1], new_solution[edge]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7045151327959184,
            0.933543610572815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7045151327959184,
            0.933543610572815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid local search combining segment inversion, node swap, and multi-objective-aware edge insertion to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid local search: segment inversion, node swap, and multi-objective edge insertion\n    if np.random.rand() < 0.7:  # 70% chance for segment inversion\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for node swap and edge insertion\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Multi-objective edge insertion\n        if n > 3:\n            m = np.random.randint(1, n-1)\n            # Calculate combined distance improvement\n            def combined_distance(sol, a, b, c):\n                d1 = distance_matrix_1[sol[a], sol[b]] + distance_matrix_1[sol[b], sol[c]] - distance_matrix_1[sol[a], sol[c]]\n                d2 = distance_matrix_2[sol[a], sol[b]] + distance_matrix_2[sol[b], sol[c]] - distance_matrix_2[sol[a], sol[c]]\n                d3 = distance_matrix_3[sol[a], sol[b]] + distance_matrix_3[sol[b], sol[c]] - distance_matrix_3[sol[a], sol[c]]\n                return d1 + d2 + d3\n\n            best_improvement = 0\n            best_pos = m\n            for pos in range(m-1, m+2):\n                if pos >= 0 and pos < n-1:\n                    improvement = combined_distance(new_solution, pos, m, pos+1)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = pos\n\n            if best_improvement > 0:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [new_solution[m]],\n                    new_solution[best_pos+1:m],\n                    new_solution[m+1:]\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.66651259866662,
            2.2681270360946657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid local search: segment inversion, node swap, and multi-objective edge insertion\n    if np.random.rand() < 0.7:  # 70% chance for segment inversion\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for node swap and edge insertion\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Multi-objective edge insertion\n        if n > 3:\n            m = np.random.randint(1, n-1)\n            # Calculate combined distance improvement\n            def combined_distance(sol, a, b, c):\n                d1 = distance_matrix_1[sol[a], sol[b]] + distance_matrix_1[sol[b], sol[c]] - distance_matrix_1[sol[a], sol[c]]\n                d2 = distance_matrix_2[sol[a], sol[b]] + distance_matrix_2[sol[b], sol[c]] - distance_matrix_2[sol[a], sol[c]]\n                d3 = distance_matrix_3[sol[a], sol[b]] + distance_matrix_3[sol[b], sol[c]] - distance_matrix_3[sol[a], sol[c]]\n                return d1 + d2 + d3\n\n            best_improvement = 0\n            best_pos = m\n            for pos in range(m-1, m+2):\n                if pos >= 0 and pos < n-1:\n                    improvement = combined_distance(new_solution, pos, m, pos+1)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = pos\n\n            if best_improvement > 0:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [new_solution[m]],\n                    new_solution[best_pos+1:m],\n                    new_solution[m+1:]\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46140848205124313,
            0.7015927314758301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weighted combination of objectives, then applies a hybrid local search strategy that combines segment reversal and multi-objective-aware node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    diversity_scores = np.dot(normalized_objectives, diversity_weights)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and multi-objective-aware node swapping\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swapping\n    if k != i and k != j and l != i and l != j:\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        new_solution[k], new_solution[l] = node_l, node_k\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8020627931710779,
            3.865574264526367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    diversity_scores = np.dot(normalized_objectives, diversity_weights)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and multi-objective-aware node swapping\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swapping\n    if k != i and k != j and l != i and l != j:\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        new_solution[k], new_solution[l] = node_l, node_k\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with better balanced trade-offs across objectives, then applies a hybrid local search that combines randomized edge swaps with objective-aware path relinking to explore diverse solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    balanced_scores = np.mean(normalized_scores, axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if np.random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            a_obj = objectives[selected_idx]\n            b_obj = (distance_matrix_1[new_solution[a-1], new_solution[b]],\n                    distance_matrix_2[new_solution[a-1], new_solution[b]],\n                    distance_matrix_3[new_solution[a-1], new_solution[b]])\n            if sum(b_obj) < sum(a_obj):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7068892066369628,
            3.473329770565033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    balanced_scores = np.mean(normalized_scores, axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if np.random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            a_obj = objectives[selected_idx]\n            b_obj = (distance_matrix_1[new_solution[a-1], new_solution[b]],\n                    distance_matrix_2[new_solution[a-1], new_solution[b]],\n                    distance_matrix_3[new_solution[a-1], new_solution[b]])\n            if sum(b_obj) < sum(a_obj):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes solutions with better performance in the most critical objective, then applies a hybrid local search combining 2-opt and random segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective-aware selection that considers both individual objective performance and their relative importance, then applies a novel hybrid local search combining multi-objective-aware segment replacement and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic objective-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = objectives.max(axis=0) - objectives.min(axis=0)\n    normalized_objectives = (objectives - objectives.min(axis=0)) / objective_ranges\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(normalized_objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment replacement and adaptive node swapping\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Segment replacement\n    replacement_segment = np.random.permutation(new_solution[start:end])\n    new_solution[start:end] = replacement_segment\n\n    # Adaptive node swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        if np.random.rand() < 0.7:  # Higher probability for beneficial swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7347919084025766,
            3.6883121728897095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic objective-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = objectives.max(axis=0) - objectives.min(axis=0)\n    normalized_objectives = (objectives - objectives.min(axis=0)) / objective_ranges\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(normalized_objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment replacement and adaptive node swapping\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Segment replacement\n    replacement_segment = np.random.permutation(new_solution[start:end])\n    new_solution[start:end] = replacement_segment\n\n    # Adaptive node swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        if np.random.rand() < 0.7:  # Higher probability for beneficial swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes solutions with better performance in the most critical objective, then applies a hybrid local search combining 2-opt and random segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized hypervolume contribution score, then applies a multi-objective edge exchange heuristic that considers all three objectives simultaneously, ensuring feasibility through careful edge swapping and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    hypervolume = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge exchange heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate edge costs before exchange\n    prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    next_i = new_solution[(i+1)%n]\n    prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    next_j = new_solution[(j+1)%n]\n\n    cost_before = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                   distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                   distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                   distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                   distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n                   distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Calculate edge costs after exchange\n    cost_after = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                  distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                  distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                  distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                  distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n                  distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n    # Revert if no improvement in any objective\n    if cost_after >= cost_before:\n        new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7163317452572071,
            2.6160496354103087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    hypervolume = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge exchange heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate edge costs before exchange\n    prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    next_i = new_solution[(i+1)%n]\n    prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    next_j = new_solution[(j+1)%n]\n\n    cost_before = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                   distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                   distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                   distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                   distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n                   distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Calculate edge costs after exchange\n    cost_after = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                  distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                  distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                  distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                  distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n                  distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n    # Revert if no improvement in any objective\n    if cost_after >= cost_before:\n        new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = np.array([obj for _, obj in archive])\n    avg_scores = objectives.mean(axis=1)\n    selected_idx = np.argmax(avg_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6830493450622964,
            2.5409131407737733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest average objective value\n    objectives = np.array([obj for _, obj in archive])\n    avg_scores = objectives.mean(axis=1)\n    selected_idx = np.argmax(avg_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes solutions with better performance in the most critical objective, then applies a hybrid local search combining 2-opt and random segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic objective balance that adapts to the current distribution of solutions, then applies a hybrid local search combining 3-opt and random node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic objective balance\n    objectives = np.array([obj for _, obj in archive])\n    mean_objectives = np.mean(objectives, axis=0)\n    deviation = np.std(objectives, axis=0)\n    weights = deviation / np.sum(deviation)  # Higher weight for more deviant objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and random node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Random node insertion\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6845919912789948,
            3.0755950570106507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic objective balance\n    objectives = np.array([obj for _, obj in archive])\n    mean_objectives = np.mean(objectives, axis=0)\n    deviation = np.std(objectives, axis=0)\n    weights = deviation / np.sum(deviation)  # Higher weight for more deviant objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and random node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Random node insertion\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid of 2-opt and node swap to explore diverse neighborhoods\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move: reverse segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node swap: randomly swap two nodes to introduce diversity\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5555898821521199,
            2.5091660022735596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid of 2-opt and node swap to explore diverse neighborhoods\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move: reverse segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node swap: randomly swap two nodes to introduce diversity\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest variance in objectives (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(variance))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid 2-opt and 3-opt local search\n    n = len(new_solution)\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6469444832076215,
            3.1738221287727355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest variance in objectives (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(variance))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid 2-opt and 3-opt local search\n    n = len(new_solution)\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8272230658111269,
            4.093543696403503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8272230658111269,
            4.093543696403503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity in objectives, then applies a hybrid local search combining 2-opt swaps and segment reversals to optimize the least dominant objective while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    balanced_idx = np.argmax(std_devs)\n    base_solution = archive[balanced_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[balanced_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply hybrid local search: 2-opt swap and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Optimize the least dominant objective\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if least_dominant == 0:\n            cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b-1], new_solution[b]]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b-1], new_solution[b]]\n        else:\n            cost = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]] - distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b-1], new_solution[b]]\n\n        if cost < 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4840608261766045,
            3.7383183360099794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    balanced_idx = np.argmax(std_devs)\n    base_solution = archive[balanced_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[balanced_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply hybrid local search: 2-opt swap and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment reversal\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Optimize the least dominant objective\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if least_dominant == 0:\n            cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b-1], new_solution[b]]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b-1], new_solution[b]]\n        else:\n            cost = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]] - distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b-1], new_solution[b]]\n\n        if cost < 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search that combines a multi-objective edge exchange with a dynamic insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    diversity_scores = np.dot(objectives, diversity_weights)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-objective edge exchange with dynamic insertion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Edge exchange\n    exchanged_solution = new_solution.copy()\n    exchanged_solution[i], exchanged_solution[j] = exchanged_solution[j], exchanged_solution[i]\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = exchanged_solution[k-1]\n        curr = exchanged_solution[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try dynamic insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = exchanged_solution\n    else:\n        # Dynamic insertion based on objective weights\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            # Weighted cost calculation\n            cost = (diversity_weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    diversity_weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    diversity_weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6638449451085445,
            1.0661031603813171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    diversity_scores = np.dot(objectives, diversity_weights)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-objective edge exchange with dynamic insertion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Edge exchange\n    exchanged_solution = new_solution.copy()\n    exchanged_solution[i], exchanged_solution[j] = exchanged_solution[j], exchanged_solution[i]\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = exchanged_solution[k-1]\n        curr = exchanged_solution[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try dynamic insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = exchanged_solution\n    else:\n        # Dynamic insertion based on objective weights\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            # Weighted cost calculation\n            cost = (diversity_weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    diversity_weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    diversity_weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 4-opt and segment insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-10)\n    selected_idx = np.argmin(normalized_scores.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6305298023575573,
            2.9740802884101867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-10)\n    selected_idx = np.argmin(normalized_scores.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and segment insertion\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(range(n), 4, replace=False))\n\n    # Perform 4-opt move\n    if i < j < k < l:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Random segment insertion\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7457153660610267,
            1.0815984010696411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on the most promising trade-off between objectives, then applies a novel multi-objective-aware local search strategy that combines adaptive segment rotation with objective-biased node insertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.max(objectives, axis=1) - np.min(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Objective-biased node insertion\n    k = np.random.choice(range(n))\n    l = np.random.choice(range(n))\n    while l == k:\n        l = np.random.choice(range(n))\n\n    current_costs = [\n        distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]],\n        distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]],\n        distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]],\n        distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]],\n        distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n    ]\n\n    if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7022234094689124,
            3.25175085067749
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.max(objectives, axis=1) - np.min(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Objective-biased node insertion\n    k = np.random.choice(range(n))\n    l = np.random.choice(range(n))\n    while l == k:\n        l = np.random.choice(range(n))\n\n    current_costs = [\n        distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]],\n        distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]],\n        distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]],\n        distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]],\n        distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n    ]\n\n    if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes solutions with better performance in the most critical objective, then applies a hybrid local search combining 2-opt and random segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-weighted objective score that balances exploration of different trade-offs, then applies a novel local search combining segment rotation and objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with diversity-weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    k = np.random.randint(1, n-2)\n    new_solution = np.roll(new_solution, k)\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate potential improvement in all objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[i], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[j], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[i], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n\n        current_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in current_edges)\n        new_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in new_edges)\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6758459699595625,
            4.054358959197998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with diversity-weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    k = np.random.randint(1, n-2)\n    new_solution = np.roll(new_solution, k)\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate potential improvement in all objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[i], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[j], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[i], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n\n        current_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in current_edges)\n        new_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in new_edges)\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective selection, then applies a novel multi-objective local search combining alternating path reversal and intelligent node insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: alternating path reversal and node insertion\n    n = len(new_solution)\n\n    # Alternating path reversal\n    for i in range(0, n, 2):\n        j = min(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Intelligent node insertion\n    if n > 2:\n        # Select a node to remove and reinsert\n        remove_pos = np.random.randint(1, n-1)\n        node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Calculate insertion points based on all three distance matrices\n        insertion_costs = np.zeros(n-1)\n        for pos in range(n-1):\n            a = new_solution[pos]\n            b = new_solution[(pos+1)%(n-1)]\n            insertion_costs[pos] = (distance_matrix_1[a, node] + distance_matrix_1[node, b] - distance_matrix_1[a, b] +\n                                   distance_matrix_2[a, node] + distance_matrix_2[node, b] - distance_matrix_2[a, b] +\n                                   distance_matrix_3[a, node] + distance_matrix_3[node, b] - distance_matrix_3[a, b])\n\n        best_pos = np.argmin(insertion_costs)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6932431967166186,
            3.756994926929474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: alternating path reversal and node insertion\n    n = len(new_solution)\n\n    # Alternating path reversal\n    for i in range(0, n, 2):\n        j = min(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Intelligent node insertion\n    if n > 2:\n        # Select a node to remove and reinsert\n        remove_pos = np.random.randint(1, n-1)\n        node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Calculate insertion points based on all three distance matrices\n        insertion_costs = np.zeros(n-1)\n        for pos in range(n-1):\n            a = new_solution[pos]\n            b = new_solution[(pos+1)%(n-1)]\n            insertion_costs[pos] = (distance_matrix_1[a, node] + distance_matrix_1[node, b] - distance_matrix_1[a, b] +\n                                   distance_matrix_2[a, node] + distance_matrix_2[node, b] - distance_matrix_2[a, b] +\n                                   distance_matrix_3[a, node] + distance_matrix_3[node, b] - distance_matrix_3[a, b])\n\n        best_pos = np.argmin(insertion_costs)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes solutions with better performance in the most critical objective, then applies a hybrid local search combining 2-opt and random segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.3, 0.1])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective diversity score that combines objective values and solution structure, then applies a hybrid local search combining 3-opt and random node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best multi-objective diversity score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and random node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Random node insertion\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0][0]), pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.705130704945937,
            4.118334841728211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best multi-objective diversity score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and random node insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Random node insertion\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(n)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0][0]), pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7590325985312143,
            1.6597802758216857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7100923616511146,
            1.181328284740448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective insertion heuristic\n    n = len(new_solution)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    # Find best insertion point considering all three objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_remove:\n            continue\n\n        # Calculate cost for inserting at position i\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel multi-objective local search algorithm that selects solutions based on a weighted combination of objective diversity and solution quality, then applies a hybrid 2-opt and insertion heuristic to generate high-quality neighbors across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weighted score combining diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    quality_scores = 1 / (1 + np.sum(objectives, axis=1))\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * diversity_scores + (1 - weights) * quality_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return base_solution\n\n    # Randomly choose between 2-opt or insertion\n    if np.random.random() < 0.5:\n        # 2-opt operation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        # Find best insertion point considering all three objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i == node_to_remove:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.41248098010622386,
            4.254672396183014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weighted score combining diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    quality_scores = 1 / (1 + np.sum(objectives, axis=1))\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * diversity_scores + (1 - weights) * quality_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return base_solution\n\n    # Randomly choose between 2-opt or insertion\n    if np.random.random() < 0.5:\n        # 2-opt operation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        # Find best insertion point considering all three objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i == node_to_remove:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm employs a multi-objective aware segment inversion with adaptive reinsertion, where it first selects a solution based on its objective diversity and then applies a segment inversion followed by a targeted reinsertion of the inverted segment's nodes to optimize the least improved objective while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the objective with the largest improvement potential\n    current_obj = objectives[selected_idx]\n    sorted_obj = np.argsort(current_obj)\n    target_obj = sorted_obj[0]\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment to optimize the target objective\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if target_obj == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif target_obj == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.610662689274533,
            1.0898192882537843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the objective with the largest improvement potential\n    current_obj = objectives[selected_idx]\n    sorted_obj = np.argsort(current_obj)\n    target_obj = sorted_obj[0]\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment to optimize the target objective\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if target_obj == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif target_obj == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest diversity in objective trade-offs and applies a hybrid local search combining segment reversal with multi-objective-aware node insertion to explore promising regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with multi-objective-aware insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Reverse segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        # Multi-objective cost calculation\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.3\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6364848658218513,
            1.483479380607605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with multi-objective-aware insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Reverse segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        # Multi-objective cost calculation\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.3\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This algorithm prioritizes solutions with the largest spread in objectives, applies a hybrid local search combining segment reversal and node swapping to improve the most underperforming objective, and ensures feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the largest spread in objectives\n    objectives = np.array([obj for _, obj in archive])\n    spread = objectives.max(axis=1) - objectives.min(axis=1)\n    spread_idx = np.argmax(spread)\n    base_solution = archive[spread_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most underperforming objective\n    worst_obj = objectives[spread_idx]\n    underperforming_obj = np.argmin(worst_obj)\n\n    # Apply segment reversal for local search\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Apply node swapping to further improve the underperforming objective\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if underperforming_obj == 0:\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        elif underperforming_obj == 1:\n            cost_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        else:\n            cost_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost_diff < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4194088921523188,
            4.1843531131744385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the largest spread in objectives\n    objectives = np.array([obj for _, obj in archive])\n    spread = objectives.max(axis=1) - objectives.min(axis=1)\n    spread_idx = np.argmax(spread)\n    base_solution = archive[spread_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most underperforming objective\n    worst_obj = objectives[spread_idx]\n    underperforming_obj = np.argmin(worst_obj)\n\n    # Apply segment reversal for local search\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Apply node swapping to further improve the underperforming objective\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if underperforming_obj == 0:\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        elif underperforming_obj == 1:\n            cost_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        else:\n            cost_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost_diff < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of the three objectives, then applies a novel hybrid local search that combines 2-opt swaps with segment-based reinsertion to improve the least dominant objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of objectives\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective\n    least_dominant = np.argmax(objectives[selected_idx])\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment-based reinsertion\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Remove segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n    # Find best insertion point for the segment\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        if i == 0:\n            prev_node = new_solution[-1]\n            next_node = new_solution[0]\n        else:\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n\n        if least_dominant == 0:\n            cost = (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] -\n                    distance_matrix_1[prev_node, next_node])\n        elif least_dominant == 1:\n            cost = (distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] -\n                    distance_matrix_2[prev_node, next_node])\n        else:\n            cost = (distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7195819762082282,
            4.073582029342651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of objectives\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective\n    least_dominant = np.argmax(objectives[selected_idx])\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment-based reinsertion\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Remove segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n    # Find best insertion point for the segment\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        if i == 0:\n            prev_node = new_solution[-1]\n            next_node = new_solution[0]\n        else:\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n\n        if least_dominant == 0:\n            cost = (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] -\n                    distance_matrix_1[prev_node, next_node])\n        elif least_dominant == 1:\n            cost = (distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] -\n                    distance_matrix_2[prev_node, next_node])\n        else:\n            cost = (distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm employs a multi-objective weighted random selection strategy that combines a novel segment-based inversion with a hybrid local search that prioritizes simultaneous improvement across all three objectives using a weighted cost function, ensuring feasibility through careful node reinsertion and segment rotation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1.0 / (1 + objectives.max(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(4, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment using weighted cost function\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Weighted cost across all three objectives\n        cost = (\n            0.4 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            0.3 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            0.3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7208922341497198,
            1.3558992266654968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1.0 / (1 + objectives.max(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(4, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment using weighted cost function\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Weighted cost across all three objectives\n        cost = (\n            0.4 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            0.3 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            0.3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that balances all three objectives, then applies a hybrid local search strategy combining multi-segment reversal with adaptive node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segments = np.random.randint(2, 4)\n    for _ in range(segments):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > 0 and b < n-1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:b], new_solution[b+1:a+1], [node], new_solution[a+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6540689118579299,
            2.2422650337219237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segments = np.random.randint(2, 4)\n    for _ in range(segments):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > 0 and b < n-1:\n            node = new_solution[b]\n            new_solution = np.concatenate([new_solution[:b], new_solution[b+1:a+1], [node], new_solution[a+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel multi-objective local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.1, 0.5, size=3)\n    weights /= weights.sum()\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 3-opt and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    if i < j < k:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity metric that combines objective values and spatial distribution, then applies a novel hybrid local search combining node swapping and partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    diversity = objectives.std(axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping and partial path reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Node swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial path reversal between two random points\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6595585387703887,
            3.8150630593299866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    diversity = objectives.std(axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping and partial path reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Node swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial path reversal between two random points\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score and applies a hybrid local search that combines 2-opt swaps with multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt swap with multi-objective edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective edge swap\n    if k != l:\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        total_gain = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[node_l, new_solution[(k+1)%n]] +\n                     distance_matrix_1[node_l, new_solution[(l-1)%n]] + distance_matrix_1[node_k, new_solution[(l+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[(k-1)%n], node_k] + distance_matrix_1[node_k, new_solution[(k+1)%n]] +\n                     distance_matrix_1[new_solution[(l-1)%n], node_l] + distance_matrix_1[node_l, new_solution[(l+1)%n]])\n\n        if total_gain < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.63859586867302,
            3.8964142918586733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt swap with multi-objective edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective edge swap\n    if k != l:\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        total_gain = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[node_l, new_solution[(k+1)%n]] +\n                     distance_matrix_1[node_l, new_solution[(l-1)%n]] + distance_matrix_1[node_k, new_solution[(l+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[(k-1)%n], node_k] + distance_matrix_1[node_k, new_solution[(k+1)%n]] +\n                     distance_matrix_1[new_solution[(l-1)%n], node_l] + distance_matrix_1[node_l, new_solution[(l+1)%n]])\n\n        if total_gain < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5889008962833742,
            1.7802202820777893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This algorithm employs a multi-objective-aware evolutionary strategy that combines adaptive segment crossover with dynamic node reordering, using a hybrid of Pareto-front guided selection and objective-space partitioning to explore diverse trade-offs while ensuring feasibility through constrained optimization techniques.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off across all objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Partition the tour into three segments\n    partition_points = sorted(np.random.choice(range(1, n), 2, replace=False))\n    segments = [\n        new_solution[:partition_points[0]],\n        new_solution[partition_points[0]:partition_points[1]],\n        new_solution[partition_points[1]:]\n    ]\n\n    # Recombine segments with dynamic reordering\n    order = np.random.permutation(3)\n    new_solution = np.concatenate([segments[i] for i in order])\n\n    # Apply dynamic node swapping based on objective improvement\n    for _ in range(5):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[(j+1)%n]\n\n        current_cost = (\n            distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n            distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n            distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6946284140499077,
            4.375819396972656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off across all objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Partition the tour into three segments\n    partition_points = sorted(np.random.choice(range(1, n), 2, replace=False))\n    segments = [\n        new_solution[:partition_points[0]],\n        new_solution[partition_points[0]:partition_points[1]],\n        new_solution[partition_points[1]:]\n    ]\n\n    # Recombine segments with dynamic reordering\n    order = np.random.permutation(3)\n    new_solution = np.concatenate([segments[i] for i in order])\n\n    # Apply dynamic node swapping based on objective improvement\n    for _ in range(5):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[(j+1)%n]\n\n        current_cost = (\n            distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n            distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n            distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment exchange strategy that dynamically balances improvements across all three objectives by prioritizing segments with the highest potential for balanced multi-objective improvement, using a hybrid of segment swapping and node reinsertion with objective-aware distance evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    best_balance_idx = np.argmin(balance_scores)\n    base_solution = archive[best_balance_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate segment improvement potential\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(6, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Evaluate segment improvement across all objectives\n    total_improvement = 0\n    for i in range(seg_length-1):\n        node1 = segment[i]\n        node2 = segment[i+1]\n        total_improvement += (distance_matrix_1[node1, node2] +\n                            distance_matrix_2[node1, node2] +\n                            distance_matrix_3[node1, node2])\n\n    # Find best position to insert the segment\n    best_pos = -1\n    max_improvement = -float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[prev_node, segment[0]] +\n                   distance_matrix_2[prev_node, segment[0]] +\n                   distance_matrix_3[prev_node, segment[0]] +\n                   distance_matrix_1[segment[-1], next_node] +\n                   distance_matrix_2[segment[-1], next_node] +\n                   distance_matrix_3[segment[-1], next_node])\n\n        new_cost = (distance_matrix_1[prev_node, segment[0]] +\n                   distance_matrix_2[prev_node, segment[0]] +\n                   distance_matrix_3[prev_node, segment[0]] +\n                   distance_matrix_1[segment[-1], next_node] +\n                   distance_matrix_2[segment[-1], next_node] +\n                   distance_matrix_3[segment[-1], next_node])\n\n        improvement = old_cost - new_cost\n\n        if improvement > max_improvement:\n            max_improvement = improvement\n            best_pos = i\n\n    if best_pos != -1:\n        # Remove segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:]\n        ])\n\n        # Insert segment at best position\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7772291338801507,
            4.124417948722839
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    best_balance_idx = np.argmin(balance_scores)\n    base_solution = archive[best_balance_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate segment improvement potential\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(6, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Evaluate segment improvement across all objectives\n    total_improvement = 0\n    for i in range(seg_length-1):\n        node1 = segment[i]\n        node2 = segment[i+1]\n        total_improvement += (distance_matrix_1[node1, node2] +\n                            distance_matrix_2[node1, node2] +\n                            distance_matrix_3[node1, node2])\n\n    # Find best position to insert the segment\n    best_pos = -1\n    max_improvement = -float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[prev_node, segment[0]] +\n                   distance_matrix_2[prev_node, segment[0]] +\n                   distance_matrix_3[prev_node, segment[0]] +\n                   distance_matrix_1[segment[-1], next_node] +\n                   distance_matrix_2[segment[-1], next_node] +\n                   distance_matrix_3[segment[-1], next_node])\n\n        new_cost = (distance_matrix_1[prev_node, segment[0]] +\n                   distance_matrix_2[prev_node, segment[0]] +\n                   distance_matrix_3[prev_node, segment[0]] +\n                   distance_matrix_1[segment[-1], next_node] +\n                   distance_matrix_2[segment[-1], next_node] +\n                   distance_matrix_3[segment[-1], next_node])\n\n        improvement = old_cost - new_cost\n\n        if improvement > max_improvement:\n            max_improvement = improvement\n            best_pos = i\n\n    if best_pos != -1:\n        # Remove segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:]\n        ])\n\n        # Insert segment at best position\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and spatial proximity, then applies a novel multi-objective-aware local search strategy that combines adaptive node clustering with dynamic segment insertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    crowding_dist = np.sum(np.abs(normalized_obj[:, np.newaxis] - normalized_obj), axis=2)\n    crowding_dist = np.sum(crowding_dist, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    cluster_size = np.random.randint(3, min(7, n//2))\n    clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n        i, j = np.random.choice(range(len(cluster)), 2, replace=False)\n        cluster[i], cluster[j] = cluster[j], cluster[i]\n\n    new_solution = np.concatenate(clusters)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5840849896608525,
            4.380909860134125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    crowding_dist = np.sum(np.abs(normalized_obj[:, np.newaxis] - normalized_obj), axis=2)\n    crowding_dist = np.sum(crowding_dist, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    cluster_size = np.random.randint(3, min(7, n//2))\n    clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n        i, j = np.random.choice(range(len(cluster)), 2, replace=False)\n        cluster[i], cluster[j] = cluster[j], cluster[i]\n\n    new_solution = np.concatenate(clusters)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This new algorithm employs a multi-objective dominance-based selection with a hybrid local search that prioritizes improving the worst-performing objective while using a combination of node swaps and segment reversals to maintain solution feasibility and diversity across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n\n    # Reverse the selected segment\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Perform a node swap to optimize the least dominant objective\n    i, j = np.random.choice(n, 2, replace=False)\n    if least_dominant == 0:\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif least_dominant == 1:\n        cost_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        cost_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.531898336514923,
            3.491374135017395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply hybrid local search: segment reversal and node swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n\n    # Reverse the selected segment\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Perform a node swap to optimize the least dominant objective\n    i, j = np.random.choice(n, 2, replace=False)\n    if least_dominant == 0:\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif least_dominant == 1:\n        cost_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        cost_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This algorithm employs a multi-objective-aware segment inversion strategy that selectively flips node segments to improve the worst-performing objective while using a hybrid of segment inversion and node swapping to maintain solution feasibility across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Swap two nodes to optimize the least dominant objective\n    node1, node2 = np.random.choice(n, 2, replace=False)\n    if least_dominant == 0:\n        cost1 = distance_matrix_1[node1, new_solution[(node1+1)%n]] + distance_matrix_1[new_solution[(node1-1)%n], node1]\n        cost2 = distance_matrix_1[node2, new_solution[(node2+1)%n]] + distance_matrix_1[new_solution[(node2-1)%n], node2]\n        new_cost1 = distance_matrix_1[node2, new_solution[(node1+1)%n]] + distance_matrix_1[new_solution[(node1-1)%n], node2]\n        new_cost2 = distance_matrix_1[node1, new_solution[(node2+1)%n]] + distance_matrix_1[new_solution[(node2-1)%n], node1]\n    elif least_dominant == 1:\n        cost1 = distance_matrix_2[node1, new_solution[(node1+1)%n]] + distance_matrix_2[new_solution[(node1-1)%n], node1]\n        cost2 = distance_matrix_2[node2, new_solution[(node2+1)%n]] + distance_matrix_2[new_solution[(node2-1)%n], node2]\n        new_cost1 = distance_matrix_2[node2, new_solution[(node1+1)%n]] + distance_matrix_2[new_solution[(node1-1)%n], node2]\n        new_cost2 = distance_matrix_2[node1, new_solution[(node2+1)%n]] + distance_matrix_2[new_solution[(node2-1)%n], node1]\n    else:\n        cost1 = distance_matrix_3[node1, new_solution[(node1+1)%n]] + distance_matrix_3[new_solution[(node1-1)%n], node1]\n        cost2 = distance_matrix_3[node2, new_solution[(node2+1)%n]] + distance_matrix_3[new_solution[(node2-1)%n], node2]\n        new_cost1 = distance_matrix_3[node2, new_solution[(node1+1)%n]] + distance_matrix_3[new_solution[(node1-1)%n], node2]\n        new_cost2 = distance_matrix_3[node1, new_solution[(node2+1)%n]] + distance_matrix_3[new_solution[(node2-1)%n], node1]\n\n    if (new_cost1 + new_cost2) < (cost1 + cost2):\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5058750840662429,
            3.5801104068756104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Swap two nodes to optimize the least dominant objective\n    node1, node2 = np.random.choice(n, 2, replace=False)\n    if least_dominant == 0:\n        cost1 = distance_matrix_1[node1, new_solution[(node1+1)%n]] + distance_matrix_1[new_solution[(node1-1)%n], node1]\n        cost2 = distance_matrix_1[node2, new_solution[(node2+1)%n]] + distance_matrix_1[new_solution[(node2-1)%n], node2]\n        new_cost1 = distance_matrix_1[node2, new_solution[(node1+1)%n]] + distance_matrix_1[new_solution[(node1-1)%n], node2]\n        new_cost2 = distance_matrix_1[node1, new_solution[(node2+1)%n]] + distance_matrix_1[new_solution[(node2-1)%n], node1]\n    elif least_dominant == 1:\n        cost1 = distance_matrix_2[node1, new_solution[(node1+1)%n]] + distance_matrix_2[new_solution[(node1-1)%n], node1]\n        cost2 = distance_matrix_2[node2, new_solution[(node2+1)%n]] + distance_matrix_2[new_solution[(node2-1)%n], node2]\n        new_cost1 = distance_matrix_2[node2, new_solution[(node1+1)%n]] + distance_matrix_2[new_solution[(node1-1)%n], node2]\n        new_cost2 = distance_matrix_2[node1, new_solution[(node2+1)%n]] + distance_matrix_2[new_solution[(node2-1)%n], node1]\n    else:\n        cost1 = distance_matrix_3[node1, new_solution[(node1+1)%n]] + distance_matrix_3[new_solution[(node1-1)%n], node1]\n        cost2 = distance_matrix_3[node2, new_solution[(node2+1)%n]] + distance_matrix_3[new_solution[(node2-1)%n], node2]\n        new_cost1 = distance_matrix_3[node2, new_solution[(node1+1)%n]] + distance_matrix_3[new_solution[(node1-1)%n], node2]\n        new_cost2 = distance_matrix_3[node1, new_solution[(node2+1)%n]] + distance_matrix_3[new_solution[(node2-1)%n], node1]\n\n    if (new_cost1 + new_cost2) < (cost1 + cost2):\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment inversion and node reinsertion to improve the least dominant objective while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply segment inversion\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment to optimize the least dominant objective\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6647025499462597,
            1.046725070476532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply segment inversion\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment to optimize the least dominant objective\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest potential for hypervolume improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = objectives.min(axis=0)\n    nadir_point = objectives.max(axis=0)\n    norm_obj = (objectives - ideal_point) / (nadir_point - ideal_point + 1e-10)\n\n    # Calculate hypervolume contribution\n    hv_contribution = np.prod(norm_obj, axis=1) * np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(hv_contribution)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 3D-aware local search: segment rotation and multi-objective 2-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment rotation\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Multi-objective 2-opt\n    if k != l:\n        # Evaluate potential improvement in all three objectives\n        a, b = new_solution[k-1], new_solution[k]\n        c, d = new_solution[l-1], new_solution[l]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d] -\n                  distance_matrix_1[a, b] - distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d] -\n                  distance_matrix_2[a, b] - distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d] -\n                  distance_matrix_3[a, b] - distance_matrix_3[c, d])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6905504366557,
            4.364774227142334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest potential for hypervolume improvement\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = objectives.min(axis=0)\n    nadir_point = objectives.max(axis=0)\n    norm_obj = (objectives - ideal_point) / (nadir_point - ideal_point + 1e-10)\n\n    # Calculate hypervolume contribution\n    hv_contribution = np.prod(norm_obj, axis=1) * np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(hv_contribution)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 3D-aware local search: segment rotation and multi-objective 2-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment rotation\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Multi-objective 2-opt\n    if k != l:\n        # Evaluate potential improvement in all three objectives\n        a, b = new_solution[k-1], new_solution[k]\n        c, d = new_solution[l-1], new_solution[l]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d] -\n                  distance_matrix_1[a, b] - distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d] -\n                  distance_matrix_2[a, b] - distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d] -\n                  distance_matrix_3[a, b] - distance_matrix_3[c, d])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective range and neighborhood improvement potential, then applies a hybrid segment reversal and multi-objective node swap strategy to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    range_scores = objectives.max(axis=1) - objectives.min(axis=1)\n    improvement_potential = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, improvement_potential) * range_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.759147331354028,
            3.4393190264701845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    range_scores = objectives.max(axis=1) - objectives.min(axis=1)\n    improvement_potential = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, improvement_potential) * range_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a hybrid local search strategy that combines multi-segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    k = np.random.randint(1, 4)\n    for _ in range(k):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7861112932522799,
            3.8314542889595034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    k = np.random.randint(1, 4)\n    for _ in range(k):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment exchange strategy that dynamically selects segments based on their contribution to each objective, then performs a balanced segment swap between two segments to improve multiple objectives simultaneously while maintaining feasibility through careful segment boundary preservation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance across all objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = np.std(normalized_obj, axis=1)\n    best_balance_idx = np.argmin(balance_scores)\n    base_solution = archive[best_balance_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Select two segments based on their contribution to different objectives\n    def segment_contribution(sol, start, end, dm1, dm2, dm3):\n        total = 0\n        for i in range(start, end):\n            prev = sol[i-1] if i > 0 else sol[-1]\n            next_node = sol[i] if i < n-1 else sol[0]\n            total += dm1[prev, sol[i]] + dm2[prev, sol[i]] + dm3[prev, sol[i]]\n        return total\n\n    # Find first segment (high contribution to one objective)\n    seg1_start = np.random.randint(0, n//2)\n    seg1_length = np.random.randint(2, min(5, n//3))\n    seg1_end = min(seg1_start + seg1_length, n)\n\n    # Find second segment (high contribution to different objective)\n    seg2_start = np.random.randint(n//2, n)\n    seg2_length = np.random.randint(2, min(5, n//3))\n    seg2_end = min(seg2_start + seg2_length, n)\n\n    # Perform segment swap\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg2_start:seg2_end]\n\n    if len(seg1) > 0 and len(seg2) > 0:\n        # Create new segments with swapped content\n        new_seg1 = np.concatenate([seg2, seg1])\n        new_seg2 = np.concatenate([seg1, seg2])\n\n        # Insert back into solution\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            new_seg1,\n            new_solution[seg1_end:seg2_start],\n            new_seg2,\n            new_solution[seg2_end:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7234417196775365,
            1.658408236503601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance across all objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = np.std(normalized_obj, axis=1)\n    best_balance_idx = np.argmin(balance_scores)\n    base_solution = archive[best_balance_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Select two segments based on their contribution to different objectives\n    def segment_contribution(sol, start, end, dm1, dm2, dm3):\n        total = 0\n        for i in range(start, end):\n            prev = sol[i-1] if i > 0 else sol[-1]\n            next_node = sol[i] if i < n-1 else sol[0]\n            total += dm1[prev, sol[i]] + dm2[prev, sol[i]] + dm3[prev, sol[i]]\n        return total\n\n    # Find first segment (high contribution to one objective)\n    seg1_start = np.random.randint(0, n//2)\n    seg1_length = np.random.randint(2, min(5, n//3))\n    seg1_end = min(seg1_start + seg1_length, n)\n\n    # Find second segment (high contribution to different objective)\n    seg2_start = np.random.randint(n//2, n)\n    seg2_length = np.random.randint(2, min(5, n//3))\n    seg2_end = min(seg2_start + seg2_length, n)\n\n    # Perform segment swap\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg2_start:seg2_end]\n\n    if len(seg1) > 0 and len(seg2) > 0:\n        # Create new segments with swapped content\n        new_seg1 = np.concatenate([seg2, seg1])\n        new_seg2 = np.concatenate([seg1, seg2])\n\n        # Insert back into solution\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            new_seg1,\n            new_solution[seg1_end:seg2_start],\n            new_seg2,\n            new_solution[seg2_end:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective weighted random selection strategy that combines a novel segment-based inversion with a hybrid local search that prioritizes simultaneous improvement across all three objectives using a weighted cost function, ensuring feasibility through careful node reinsertion and segment rotation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1.0 / (1 + objectives.max(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(4, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment using weighted cost function\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Weighted cost across all three objectives\n        cost = (\n            0.4 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            0.3 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            0.3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This algorithm employs a novel three-phase local search strategy that combines adaptive segment rotation with multi-objective aware node insertion, leveraging a dynamic weight adjustment mechanism to prioritize improvement across all objectives while maintaining solution feasibility through careful segment reordering and insertion validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 2: Adaptive segment rotation\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Calculate rotation cost across all objectives\n    rotation_costs = []\n    for rot in range(1, seg_length):\n        rotated = np.roll(segment, rot)\n        cost = (\n            0.33 * (sum(distance_matrix_1[rotated[i], rotated[i+1]] for i in range(seg_length-1)) +\n                   distance_matrix_1[rotated[-1], rotated[0]]) +\n            0.33 * (sum(distance_matrix_2[rotated[i], rotated[i+1]] for i in range(seg_length-1)) +\n                   distance_matrix_2[rotated[-1], rotated[0]]) +\n            0.34 * (sum(distance_matrix_3[rotated[i], rotated[i+1]] for i in range(seg_length-1)) +\n                   distance_matrix_3[rotated[-1], rotated[0]])\n        )\n        rotation_costs.append((cost, rot))\n\n    best_rot = min(rotation_costs, key=lambda x: x[0])[1]\n    rotated_segment = np.roll(segment, best_rot)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Phase 3: Multi-objective aware node insertion\n    removed_node = rotated_segment[-1]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Dynamic weight adjustment based on objective diversity\n        weight1 = 1.0 / (1 + distance_matrix_1[prev_node, removed_node])\n        weight2 = 1.0 / (1 + distance_matrix_2[prev_node, removed_node])\n        weight3 = 1.0 / (1 + distance_matrix_3[prev_node, removed_node])\n        total_weight = weight1 + weight2 + weight3\n        w1, w2, w3 = weight1/total_weight, weight2/total_weight, weight3/total_weight\n\n        cost = (\n            w1 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            w2 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            w3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6703149357727158,
            1.8281336069107055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 2: Adaptive segment rotation\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Calculate rotation cost across all objectives\n    rotation_costs = []\n    for rot in range(1, seg_length):\n        rotated = np.roll(segment, rot)\n        cost = (\n            0.33 * (sum(distance_matrix_1[rotated[i], rotated[i+1]] for i in range(seg_length-1)) +\n                   distance_matrix_1[rotated[-1], rotated[0]]) +\n            0.33 * (sum(distance_matrix_2[rotated[i], rotated[i+1]] for i in range(seg_length-1)) +\n                   distance_matrix_2[rotated[-1], rotated[0]]) +\n            0.34 * (sum(distance_matrix_3[rotated[i], rotated[i+1]] for i in range(seg_length-1)) +\n                   distance_matrix_3[rotated[-1], rotated[0]])\n        )\n        rotation_costs.append((cost, rot))\n\n    best_rot = min(rotation_costs, key=lambda x: x[0])[1]\n    rotated_segment = np.roll(segment, best_rot)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Phase 3: Multi-objective aware node insertion\n    removed_node = rotated_segment[-1]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Dynamic weight adjustment based on objective diversity\n        weight1 = 1.0 / (1 + distance_matrix_1[prev_node, removed_node])\n        weight2 = 1.0 / (1 + distance_matrix_2[prev_node, removed_node])\n        weight3 = 1.0 / (1 + distance_matrix_3[prev_node, removed_node])\n        total_weight = weight1 + weight2 + weight3\n        w1, w2, w3 = weight1/total_weight, weight2/total_weight, weight3/total_weight\n\n        cost = (\n            w1 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            w2 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            w3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm selects a diverse solution from the archive based on objective trade-offs and applies a novel multi-objective segment inversion strategy combined with adaptive node swapping to explore high-quality solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.prod(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive node swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6942684596517428,
            4.266029715538025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.prod(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive node swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm employs a multi-objective-aware adaptive segment exchange mechanism that dynamically selects and exchanges segments between solutions in the archive, prioritizing the most balanced objectives while using a hybrid of segment reversal and node swapping to maintain diversity and improve solution quality across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (lowest standard deviation)\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select another solution from archive for segment exchange\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n    else:\n        other_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n\n    # Extract segment from other solution and insert into current solution\n    segment = other_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment\n\n    # Optimize the inserted segment by reversing it if it improves the most balanced objective\n    reversed_segment = segment[::-1]\n    original_cost = 0\n    reversed_cost = 0\n\n    for i in range(seg_length):\n        prev_node = new_solution[start+i-1] if start+i > 0 else new_solution[-1]\n        next_node = new_solution[start+i+1] if start+i+1 < n else new_solution[0]\n\n        original_cost += (distance_matrix_1[prev_node, segment[i]] + distance_matrix_2[prev_node, segment[i]] + distance_matrix_3[prev_node, segment[i]])\n        reversed_cost += (distance_matrix_1[prev_node, reversed_segment[i]] + distance_matrix_2[prev_node, reversed_segment[i]] + distance_matrix_3[prev_node, reversed_segment[i]])\n\n    if reversed_cost < original_cost:\n        new_solution[start:start+seg_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7122596575583298,
            3.7601904392242433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (lowest standard deviation)\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select another solution from archive for segment exchange\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n    else:\n        other_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n\n    # Extract segment from other solution and insert into current solution\n    segment = other_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment\n\n    # Optimize the inserted segment by reversing it if it improves the most balanced objective\n    reversed_segment = segment[::-1]\n    original_cost = 0\n    reversed_cost = 0\n\n    for i in range(seg_length):\n        prev_node = new_solution[start+i-1] if start+i > 0 else new_solution[-1]\n        next_node = new_solution[start+i+1] if start+i+1 < n else new_solution[0]\n\n        original_cost += (distance_matrix_1[prev_node, segment[i]] + distance_matrix_2[prev_node, segment[i]] + distance_matrix_3[prev_node, segment[i]])\n        reversed_cost += (distance_matrix_1[prev_node, reversed_segment[i]] + distance_matrix_2[prev_node, reversed_segment[i]] + distance_matrix_3[prev_node, reversed_segment[i]])\n\n    if reversed_cost < original_cost:\n        new_solution[start:start+seg_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to prioritize less explored regions, then applies a hybrid local search combining adaptive 2-opt moves with dynamic multi-objective-aware insertion, ensuring feasibility while balancing exploration across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_idx, i]\n        min_val, max_val = objectives_sorted[0], objectives_sorted[-1]\n        crowding_distances[sorted_idx[1:-1]] += (objectives_sorted[2:] - objectives_sorted[:-2]) / (max_val - min_val + 1e-10)\n\n    selected_idx = np.random.choice(np.argsort(crowding_distances)[-max(1, len(archive)//3):])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n\n    for _ in range(3):\n        if np.random.random() < 0.5:\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n            new_solution[a:b+1] = reversed_segment\n        else:\n            c = np.random.randint(0, n)\n            while c == a or c == b:\n                c = np.random.randint(0, n)\n            if c > b:\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], new_solution[a:b+1], new_solution[c+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:c], new_solution[a:b+1], new_solution[c:a], new_solution[b+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.688102946175966,
            2.7065063238143923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_idx, i]\n        min_val, max_val = objectives_sorted[0], objectives_sorted[-1]\n        crowding_distances[sorted_idx[1:-1]] += (objectives_sorted[2:] - objectives_sorted[:-2]) / (max_val - min_val + 1e-10)\n\n    selected_idx = np.random.choice(np.argsort(crowding_distances)[-max(1, len(archive)//3):])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n\n    for _ in range(3):\n        if np.random.random() < 0.5:\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n            new_solution[a:b+1] = reversed_segment\n        else:\n            c = np.random.randint(0, n)\n            while c == a or c == b:\n                c = np.random.randint(0, n)\n            if c > b:\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], new_solution[a:b+1], new_solution[c+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:c], new_solution[a:b+1], new_solution[c:a], new_solution[b+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines segment reversal with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1 if i > 0 else None:-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment rotation with objective-biased insertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rotation based on objective improvement\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    rotation_amount = np.random.randint(1, j-i+1)\n    new_solution[i:j+1] = np.roll(new_solution[i:j+1], rotation_amount)\n\n    # Objective-biased insertion\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        removed_node = new_solution[a]\n        best_pos = a\n        min_cost = float('inf')\n\n        for k in range(n):\n            if k == a:\n                continue\n\n            prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost or (cost == min_cost and np.random.random() < 0.2):\n                min_cost = cost\n                best_pos = k\n\n        if best_pos != a:\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[a+1:best_pos+1],\n                [removed_node],\n                new_solution[best_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.763492722771841,
            4.0497079491615295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rotation based on objective improvement\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    rotation_amount = np.random.randint(1, j-i+1)\n    new_solution[i:j+1] = np.roll(new_solution[i:j+1], rotation_amount)\n\n    # Objective-biased insertion\n    for _ in range(3):\n        a = np.random.randint(0, n)\n        removed_node = new_solution[a]\n        best_pos = a\n        min_cost = float('inf')\n\n        for k in range(n):\n            if k == a:\n                continue\n\n            prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost or (cost == min_cost and np.random.random() < 0.2):\n                min_cost = cost\n                best_pos = k\n\n        if best_pos != a:\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[a+1:best_pos+1],\n                [removed_node],\n                new_solution[best_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective performance, then applies a hybrid local search that combines 3-opt with a multi-objective swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different segment reversals\n    segments = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_segment = None\n    min_cost = float('inf')\n\n    for segment in segments:\n        total_cost = 0\n        for m in range(n):\n            prev = segment[m-1]\n            curr = segment[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_segment = segment\n\n    if best_segment is not None:\n        new_solution = best_segment\n\n    # Multi-objective swap if no improvement\n    if best_segment is None or min_cost >= sum(objectives[selected_idx]):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Evaluate swap cost\n        prev_a = new_solution[a-1]\n        next_a = new_solution[(a+1)%n]\n        prev_b = new_solution[b-1]\n        next_b = new_solution[(b+1)%n]\n\n        cost = (distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[a], next_a] +\n                distance_matrix_1[prev_b, new_solution[b]] + distance_matrix_1[new_solution[b], next_b] -\n                (distance_matrix_1[prev_a, new_solution[b]] + distance_matrix_1[new_solution[b], next_a] +\n                 distance_matrix_1[prev_b, new_solution[a]] + distance_matrix_1[new_solution[a], next_b]) +\n                distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[a], next_a] +\n                distance_matrix_2[prev_b, new_solution[b]] + distance_matrix_2[new_solution[b], next_b] -\n                (distance_matrix_2[prev_a, new_solution[b]] + distance_matrix_2[new_solution[b], next_a] +\n                 distance_matrix_2[prev_b, new_solution[a]] + distance_matrix_2[new_solution[a], next_b]) +\n                distance_matrix_3[prev_a, new_solution[a]] + distance_matrix_3[new_solution[a], next_a] +\n                distance_matrix_3[prev_b, new_solution[b]] + distance_matrix_3[new_solution[b], next_b] -\n                (distance_matrix_3[prev_a, new_solution[b]] + distance_matrix_3[new_solution[b], next_a] +\n                 distance_matrix_3[prev_b, new_solution[a]] + distance_matrix_3[new_solution[a], next_b]))\n\n        if cost >= 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6109148667773602,
            3.9876097321510313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different segment reversals\n    segments = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_segment = None\n    min_cost = float('inf')\n\n    for segment in segments:\n        total_cost = 0\n        for m in range(n):\n            prev = segment[m-1]\n            curr = segment[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_segment = segment\n\n    if best_segment is not None:\n        new_solution = best_segment\n\n    # Multi-objective swap if no improvement\n    if best_segment is None or min_cost >= sum(objectives[selected_idx]):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Evaluate swap cost\n        prev_a = new_solution[a-1]\n        next_a = new_solution[(a+1)%n]\n        prev_b = new_solution[b-1]\n        next_b = new_solution[(b+1)%n]\n\n        cost = (distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[a], next_a] +\n                distance_matrix_1[prev_b, new_solution[b]] + distance_matrix_1[new_solution[b], next_b] -\n                (distance_matrix_1[prev_a, new_solution[b]] + distance_matrix_1[new_solution[b], next_a] +\n                 distance_matrix_1[prev_b, new_solution[a]] + distance_matrix_1[new_solution[a], next_b]) +\n                distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[a], next_a] +\n                distance_matrix_2[prev_b, new_solution[b]] + distance_matrix_2[new_solution[b], next_b] -\n                (distance_matrix_2[prev_a, new_solution[b]] + distance_matrix_2[new_solution[b], next_a] +\n                 distance_matrix_2[prev_b, new_solution[a]] + distance_matrix_2[new_solution[a], next_b]) +\n                distance_matrix_3[prev_a, new_solution[a]] + distance_matrix_3[new_solution[a], next_a] +\n                distance_matrix_3[prev_b, new_solution[b]] + distance_matrix_3[new_solution[b], next_b] -\n                (distance_matrix_3[prev_a, new_solution[b]] + distance_matrix_3[new_solution[b], next_a] +\n                 distance_matrix_3[prev_b, new_solution[a]] + distance_matrix_3[new_solution[a], next_b]))\n\n        if cost >= 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    rotated_segment = np.roll(new_solution[i:j+1], k - i)\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7597680328955974,
            1.575895655155182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    rotated_segment = np.roll(new_solution[i:j+1], k - i)\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A new algorithm that selects a solution from the archive based on its diversity in objective values, then applies a hybrid local search combining 2-opt with a multi-objective aware node insertion, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt\n    if i != j and j - i > 1:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective node insertion\n    k = np.random.choice(range(n))\n    l = np.random.choice(range(n))\n    if k != l:\n        # Calculate insertion cost across all three objectives\n        cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] -\n                distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] -\n                distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        cost3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] -\n                distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # If insertion improves at least one objective\n        if any(c < 0 for c in [cost1, cost2, cost3]):\n            new_solution = np.concatenate([new_solution[:k], [new_solution[l]], new_solution[k:l], new_solution[l+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4404735745366429,
            2.4998345017433166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt\n    if i != j and j - i > 1:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective node insertion\n    k = np.random.choice(range(n))\n    l = np.random.choice(range(n))\n    if k != l:\n        # Calculate insertion cost across all three objectives\n        cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] -\n                distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] -\n                distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        cost3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] -\n                distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # If insertion improves at least one objective\n        if any(c < 0 for c in [cost1, cost2, cost3]):\n            new_solution = np.concatenate([new_solution[:k], [new_solution[l]], new_solution[k:l], new_solution[l+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective weighted random selection strategy that combines a novel segment-based inversion with a hybrid local search that prioritizes simultaneous improvement across all three objectives using a weighted cost function, ensuring feasibility through careful node reinsertion and segment rotation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1.0 / (1 + objectives.max(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(4, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    # Reinsert the first node of the inverted segment using weighted cost function\n    removed_node = inverted_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Weighted cost across all three objectives\n        cost = (\n            0.4 * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            0.3 * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            0.3 * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm employs a multi-objective adaptive selection strategy that combines a novel segment-based rotation with a hybrid local search that dynamically adjusts weights based on objective improvement trends, ensuring feasibility through careful node reinsertion and segment rotation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection based on recent improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvements = np.array([np.sum(obj) for obj in objectives])\n    weights = improvements / improvements.sum() if improvements.sum() > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment and rotate it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, np.random.randint(1, seg_length))\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment using adaptive weighted cost\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    # Dynamic weights based on objective improvements\n    obj_weights = np.array([0.3, 0.3, 0.4])  # Initial weights\n    if len(archive) > 1:\n        recent_improvements = np.array([archive[-1][1], archive[-2][1]])\n        avg_improvements = np.mean(recent_improvements, axis=0)\n        obj_weights = avg_improvements / np.sum(avg_improvements) if np.sum(avg_improvements) > 0 else obj_weights\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Adaptive weighted cost\n        cost = (\n            obj_weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            obj_weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            obj_weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7041813077116709,
            3.8027296662330627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection based on recent improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvements = np.array([np.sum(obj) for obj in objectives])\n    weights = improvements / improvements.sum() if improvements.sum() > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random segment and rotate it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, np.random.randint(1, seg_length))\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment using adaptive weighted cost\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    # Dynamic weights based on objective improvements\n    obj_weights = np.array([0.3, 0.3, 0.4])  # Initial weights\n    if len(archive) > 1:\n        recent_improvements = np.array([archive[-1][1], archive[-2][1]])\n        avg_improvements = np.mean(recent_improvements, axis=0)\n        obj_weights = avg_improvements / np.sum(avg_improvements) if np.sum(avg_improvements) > 0 else obj_weights\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Adaptive weighted cost\n        cost = (\n            obj_weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n            obj_weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n            obj_weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node])\n        )\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This new algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining 3-opt with a multi-objective edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select promising solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Select a random solution from the first non-dominated front\n    selected_idx = np.random.randint(len(solutions))\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else new_solution[:i]\n\n    # Try all possible 3-opt configurations\n    configs = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    best_config = new_solution\n    min_cost = float('inf')\n\n    for config in configs:\n        total_cost = 0\n        for m in range(n):\n            prev = config[m-1]\n            curr = config[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_config = config.copy()\n\n    new_solution = best_config\n\n    # Multi-objective edge insertion\n    if np.random.rand() < 0.5:\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_edge_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            edge_cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                         distance_matrix_1[prev_node, next_node] +\n                         distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                         distance_matrix_2[prev_node, next_node] +\n                         distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                         distance_matrix_3[prev_node, next_node])\n\n            if edge_cost < min_edge_cost:\n                min_edge_cost = edge_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.710070822709455,
            3.0151803731918334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select promising solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Select a random solution from the first non-dominated front\n    selected_idx = np.random.randint(len(solutions))\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else new_solution[:i]\n\n    # Try all possible 3-opt configurations\n    configs = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    best_config = new_solution\n    min_cost = float('inf')\n\n    for config in configs:\n        total_cost = 0\n        for m in range(n):\n            prev = config[m-1]\n            curr = config[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_config = config.copy()\n\n    new_solution = best_config\n\n    # Multi-objective edge insertion\n    if np.random.rand() < 0.5:\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_edge_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            edge_cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                         distance_matrix_1[prev_node, next_node] +\n                         distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                         distance_matrix_2[prev_node, next_node] +\n                         distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                         distance_matrix_3[prev_node, next_node])\n\n            if edge_cost < min_edge_cost:\n                min_edge_cost = edge_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives (highest spread)\n    objectives = np.array([obj for _, obj in archive])\n    objective_spread = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(objective_spread)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid local search: edge insertion + 3-opt\n    if n >= 4:\n        # Random edge insertion\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Random 3-opt move\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:] if c < n else new_solution[c:]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5239155743132073,
            2.910456383228302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives (highest spread)\n    objectives = np.array([obj for _, obj in archive])\n    objective_spread = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(objective_spread)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid local search: edge insertion + 3-opt\n    if n >= 4:\n        # Random edge insertion\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Random 3-opt move\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:] if c < n else new_solution[c:]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective quality score that combines dominance rank and objective diversity, then applies a novel hybrid local search combining adaptive k-opt moves with objective-aware node swapping, ensuring feasibility while balancing exploration of different objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate multi-objective quality score\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    diversity_scores = np.std(objectives, axis=1)\n    quality_scores = dominance_scores + 0.5 * diversity_scores\n    selected_idx = np.argmin(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = np.random.randint(3, 6)  # Random k-opt move size\n\n    # Adaptive k-opt move\n    points = sorted(np.random.choice(range(n), k, replace=False))\n    segment = new_solution[points[0]:points[-1]+1]\n    np.random.shuffle(segment)\n    new_solution[points[0]:points[-1]+1] = segment\n\n    # Objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(nc < cc for nc, cc in zip(new_costs, current_costs)) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.70461428597632,
            3.5061067581176757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate multi-objective quality score\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    diversity_scores = np.std(objectives, axis=1)\n    quality_scores = dominance_scores + 0.5 * diversity_scores\n    selected_idx = np.argmin(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = np.random.randint(3, 6)  # Random k-opt move size\n\n    # Adaptive k-opt move\n    points = sorted(np.random.choice(range(n), k, replace=False))\n    segment = new_solution[points[0]:points[-1]+1]\n    np.random.shuffle(segment)\n    new_solution[points[0]:points[-1]+1] = segment\n\n    # Objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(nc < cc for nc, cc in zip(new_costs, current_costs)) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and neighborhood potential, then applies a novel multi-objective segment reversal strategy that combines dynamic path inversion with adaptive node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering balance\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = objectives.max(axis=1) - objectives.min(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * (1 / (1 + balance_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5301708778625277,
            4.123690724372864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering balance\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = objectives.max(axis=1) - objectives.min(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * (1 / (1 + balance_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    rotated_segment = np.roll(new_solution[i:j+1], k - i)\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    rotated_segment = np.roll(new_solution[i:j+1], k - i)\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209360550003168,
            3.306847846508026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that balances all three objectives equally, then applies a hybrid local search combining 2-opt swaps with objective-aware node reinsertion to efficiently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    norm_scores = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(norm_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt swap\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Objective-aware node reinsertion\n    if np.random.random() < 0.3:\n        node = np.random.choice(new_solution)\n        mask = new_solution != node\n        new_solution = new_solution[mask]\n        pos = np.random.randint(len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6283897823175242,
            4.133719408512116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    norm_scores = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(norm_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt swap\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Objective-aware node reinsertion\n    if np.random.random() < 0.3:\n        node = np.random.choice(new_solution)\n        mask = new_solution != node\n        new_solution = new_solution[mask]\n        pos = np.random.randint(len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.754763426926677,
            4.2365596175193785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a hybrid local search operator that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Dynamic node swapping based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[a+1]],\n            distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[b+1]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a+1]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a+1]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[a+1]],\n            distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[b+1]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[b+1]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[b+1]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5550392505386619,
            4.225481033325195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Dynamic node swapping based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[a+1]],\n            distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[b+1]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a+1]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a+1]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[a+1]],\n            distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[b+1]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[b+1]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[b+1]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.3:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, applies a hybrid local search combining 3-opt and edge exchange operations, and ensures feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective score (prioritizing balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.4, 0.3, 0.3])  # Weighting for three objectives\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt and edge exchange\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i-j, j-k, and k-i\n    segment1 = new_solution[i:j+1][::-1]\n    segment2 = new_solution[j+1:k+1][::-1]\n    segment3 = new_solution[k+1:i+1][::-1] if i != 0 else new_solution[k+1:][::-1]\n\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment1,\n        segment2,\n        segment3,\n        new_solution[k+1:] if i != 0 else new_solution[:i]\n    ])\n\n    # Edge exchange: swap two random edges for potential improvement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != b and c != d:\n        temp = new_solution.copy()\n        temp[a], temp[b] = temp[b], temp[a]\n        temp[c], temp[d] = temp[d], temp[c]\n\n        # Evaluate improvement across all objectives\n        old_cost = (distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]] +\n                    distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]] +\n                    distance_matrix_3[base_solution[a-1], base_solution[a]] + distance_matrix_3[base_solution[b-1], base_solution[b]])\n\n        new_cost = (distance_matrix_1[temp[a-1], temp[a]] + distance_matrix_1[temp[b-1], temp[b]] +\n                    distance_matrix_2[temp[a-1], temp[a]] + distance_matrix_2[temp[b-1], temp[b]] +\n                    distance_matrix_3[temp[a-1], temp[a]] + distance_matrix_3[temp[b-1], temp[b]])\n\n        if new_cost < old_cost:\n            new_solution = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.630626075343963,
            3.5066850543022157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective score (prioritizing balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.4, 0.3, 0.3])  # Weighting for three objectives\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt and edge exchange\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i-j, j-k, and k-i\n    segment1 = new_solution[i:j+1][::-1]\n    segment2 = new_solution[j+1:k+1][::-1]\n    segment3 = new_solution[k+1:i+1][::-1] if i != 0 else new_solution[k+1:][::-1]\n\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment1,\n        segment2,\n        segment3,\n        new_solution[k+1:] if i != 0 else new_solution[:i]\n    ])\n\n    # Edge exchange: swap two random edges for potential improvement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    if a != b and c != d:\n        temp = new_solution.copy()\n        temp[a], temp[b] = temp[b], temp[a]\n        temp[c], temp[d] = temp[d], temp[c]\n\n        # Evaluate improvement across all objectives\n        old_cost = (distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]] +\n                    distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]] +\n                    distance_matrix_3[base_solution[a-1], base_solution[a]] + distance_matrix_3[base_solution[b-1], base_solution[b]])\n\n        new_cost = (distance_matrix_1[temp[a-1], temp[a]] + distance_matrix_1[temp[b-1], temp[b]] +\n                    distance_matrix_2[temp[a-1], temp[a]] + distance_matrix_2[temp[b-1], temp[b]] +\n                    distance_matrix_3[temp[a-1], temp[a]] + distance_matrix_3[temp[b-1], temp[b]])\n\n        if new_cost < old_cost:\n            new_solution = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier aware selection criteria that combines hypervolume contribution and objective diversity, then applies a novel multi-objective-aware local search strategy that combines adaptive 3-opt moves with dynamic segment inversion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.unique(objectives, axis=0)\n    selected_idx = np.random.choice(len(pareto_front))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive 3-opt move\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n    # Dynamic segment inversion based on objective improvement\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        inverted_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[b-1]] + distance_matrix_3[new_solution[a], new_solution[b]]\n        ]\n\n        if sum(inverted_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8095920130733599,
            4.354125380516052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.unique(objectives, axis=0)\n    selected_idx = np.random.choice(len(pareto_front))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive 3-opt move\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n    # Dynamic segment inversion based on objective improvement\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        inverted_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[b-1]] + distance_matrix_3[new_solution[a], new_solution[b]]\n        ]\n\n        if sum(inverted_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized hypervolume contribution score, then applies a hybrid local search that combines 3-opt with a multi-objective swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    hv_contributions = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_candidate = None\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n    else:\n        # Multi-objective swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        swapped = new_solution.copy()\n        swapped[a], swapped[b] = swapped[b], swapped[a]\n\n        cost_a = (distance_matrix_1[swapped[a-1], swapped[a]] + distance_matrix_1[swapped[a], swapped[a+1]] -\n                 distance_matrix_1[swapped[a-1], swapped[a+1]] +\n                 distance_matrix_2[swapped[a-1], swapped[a]] + distance_matrix_2[swapped[a], swapped[a+1]] -\n                 distance_matrix_2[swapped[a-1], swapped[a+1]] +\n                 distance_matrix_3[swapped[a-1], swapped[a]] + distance_matrix_3[swapped[a], swapped[a+1]] -\n                 distance_matrix_3[swapped[a-1], swapped[a+1]])\n\n        cost_b = (distance_matrix_1[swapped[b-1], swapped[b]] + distance_matrix_1[swapped[b], swapped[b+1]] -\n                 distance_matrix_1[swapped[b-1], swapped[b+1]] +\n                 distance_matrix_2[swapped[b-1], swapped[b]] + distance_matrix_2[swapped[b], swapped[b+1]] -\n                 distance_matrix_2[swapped[b-1], swapped[b+1]] +\n                 distance_matrix_3[swapped[b-1], swapped[b]] + distance_matrix_3[swapped[b], swapped[b+1]] -\n                 distance_matrix_3[swapped[b-1], swapped[b+1]])\n\n        if cost_a + cost_b < 0:\n            new_solution = swapped\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.643411217839665,
            3.4301074743270874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    hv_contributions = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_candidate = None\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n    else:\n        # Multi-objective swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        swapped = new_solution.copy()\n        swapped[a], swapped[b] = swapped[b], swapped[a]\n\n        cost_a = (distance_matrix_1[swapped[a-1], swapped[a]] + distance_matrix_1[swapped[a], swapped[a+1]] -\n                 distance_matrix_1[swapped[a-1], swapped[a+1]] +\n                 distance_matrix_2[swapped[a-1], swapped[a]] + distance_matrix_2[swapped[a], swapped[a+1]] -\n                 distance_matrix_2[swapped[a-1], swapped[a+1]] +\n                 distance_matrix_3[swapped[a-1], swapped[a]] + distance_matrix_3[swapped[a], swapped[a+1]] -\n                 distance_matrix_3[swapped[a-1], swapped[a+1]])\n\n        cost_b = (distance_matrix_1[swapped[b-1], swapped[b]] + distance_matrix_1[swapped[b], swapped[b+1]] -\n                 distance_matrix_1[swapped[b-1], swapped[b+1]] +\n                 distance_matrix_2[swapped[b-1], swapped[b]] + distance_matrix_2[swapped[b], swapped[b+1]] -\n                 distance_matrix_2[swapped[b-1], swapped[b+1]] +\n                 distance_matrix_3[swapped[b-1], swapped[b]] + distance_matrix_3[swapped[b], swapped[b+1]] -\n                 distance_matrix_3[swapped[b-1], swapped[b+1]])\n\n        if cost_a + cost_b < 0:\n            new_solution = swapped\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                              distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                              distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                              distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6888564213319417,
            1.7148556113243103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                              distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                              distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                              distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search that combines 3-opt with a multi-objective swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_candidate = None\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n    else:\n        # Multi-objective swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6059885871312386,
            3.8611042380332945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_candidate = None\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n    else:\n        # Multi-objective swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-based selection, then applies a hybrid local search combining 3-opt with a multi-objective edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    crowding = np.zeros(len(archive))\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_indices, i]\n\n        # Boundary solutions have infinite crowding distance\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        # Calculate crowding distance for interior solutions\n        for j in range(1, len(sorted_obj)-1):\n            crowding[sorted_indices[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b], new_solution[a:c+1], new_solution[b:a], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b], new_solution[a:c+1][::-1], new_solution[b:a], new_solution[c+1:]])\n    ]\n\n    best_candidate = new_solution\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for k in range(n):\n            prev = candidate[k-1]\n            curr = candidate[k]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not new_solution:\n        new_solution = best_candidate\n    else:\n        # Multi-objective edge insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6507526533379449,
            2.8625157117843627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    crowding = np.zeros(len(archive))\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_indices, i]\n\n        # Boundary solutions have infinite crowding distance\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        # Calculate crowding distance for interior solutions\n        for j in range(1, len(sorted_obj)-1):\n            crowding[sorted_indices[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b], new_solution[a:c+1], new_solution[b:a], new_solution[c+1:]]),\n        np.concatenate([new_solution[:b], new_solution[a:c+1][::-1], new_solution[b:a], new_solution[c+1:]])\n    ]\n\n    best_candidate = new_solution\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for k in range(n):\n            prev = candidate[k-1]\n            curr = candidate[k]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not new_solution:\n        new_solution = best_candidate\n    else:\n        # Multi-objective edge insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    rotated_segment = np.roll(new_solution[i:j+1], k - i)\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This new algorithm selects a solution from the archive based on a pareto-frontier-aware selection strategy, then applies a hybrid local search that combines a novel multi-objective node clustering with a weighted path inversion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best pareto-frontier coverage\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.sum(objectives <= objectives, axis=1)\n    selected_idx = np.argmax(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node clustering with weighted path inversion\n    n = len(new_solution)\n    cluster_size = max(2, n // 5)\n    cluster_start = np.random.randint(0, n - cluster_size + 1)\n\n    # Perform node clustering and inversion\n    cluster = new_solution[cluster_start:cluster_start+cluster_size]\n    inverted_cluster = cluster[::-1]\n    new_solution[cluster_start:cluster_start+cluster_size] = inverted_cluster\n\n    # Weighted path inversion\n    weights = np.random.rand(3)\n    path_start = np.random.randint(0, n - 2)\n    path_length = np.random.randint(2, min(5, n - path_start))\n\n    # Calculate cost difference\n    cost_diff = 0\n    for i in range(path_start, path_start + path_length - 1):\n        a = new_solution[i]\n        b = new_solution[i+1]\n        c = new_solution[(i+2)%n]\n\n        cost_diff += (weights[0] * (distance_matrix_1[a, c] + distance_matrix_1[c, b] - distance_matrix_1[a, b] - distance_matrix_1[b, c]) +\n                      weights[1] * (distance_matrix_2[a, c] + distance_matrix_2[c, b] - distance_matrix_2[a, b] - distance_matrix_2[b, c]) +\n                      weights[2] * (distance_matrix_3[a, c] + distance_matrix_3[c, b] - distance_matrix_3[a, b] - distance_matrix_3[b, c]))\n\n    if cost_diff < 0:\n        new_solution[path_start:path_start+path_length] = new_solution[path_start:path_start+path_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6148696471845084,
            3.018905210494995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best pareto-frontier coverage\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.sum(objectives <= objectives, axis=1)\n    selected_idx = np.argmax(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node clustering with weighted path inversion\n    n = len(new_solution)\n    cluster_size = max(2, n // 5)\n    cluster_start = np.random.randint(0, n - cluster_size + 1)\n\n    # Perform node clustering and inversion\n    cluster = new_solution[cluster_start:cluster_start+cluster_size]\n    inverted_cluster = cluster[::-1]\n    new_solution[cluster_start:cluster_start+cluster_size] = inverted_cluster\n\n    # Weighted path inversion\n    weights = np.random.rand(3)\n    path_start = np.random.randint(0, n - 2)\n    path_length = np.random.randint(2, min(5, n - path_start))\n\n    # Calculate cost difference\n    cost_diff = 0\n    for i in range(path_start, path_start + path_length - 1):\n        a = new_solution[i]\n        b = new_solution[i+1]\n        c = new_solution[(i+2)%n]\n\n        cost_diff += (weights[0] * (distance_matrix_1[a, c] + distance_matrix_1[c, b] - distance_matrix_1[a, b] - distance_matrix_1[b, c]) +\n                      weights[1] * (distance_matrix_2[a, c] + distance_matrix_2[c, b] - distance_matrix_2[a, b] - distance_matrix_2[b, c]) +\n                      weights[2] * (distance_matrix_3[a, c] + distance_matrix_3[c, b] - distance_matrix_3[a, b] - distance_matrix_3[b, c]))\n\n    if cost_diff < 0:\n        new_solution[path_start:path_start+path_length] = new_solution[path_start:path_start+path_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel hypervolume-based diversity metric, then applies a multi-objective-aware local search strategy that combines adaptive node insertion with dynamic segment rotation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    reference_point = np.max(objectives, axis=0) * 1.1\n    volumes = np.prod(reference_point - objectives, axis=1)\n    selected_idx = np.argmax(volumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Adaptive segment selection based on objective diversity\n    seg_length = max(2, min(5, n//4))\n    start = np.random.randint(0, n - seg_length)\n\n    # Dynamic segment rotation with objective-aware node selection\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n\n    # Evaluate potential positions for insertion\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Multi-objective cost evaluation\n        cost1 = distance_matrix_1[prev_node, rotated_segment[0]] + distance_matrix_1[rotated_segment[0], next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, rotated_segment[0]] + distance_matrix_2[rotated_segment[0], next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, rotated_segment[0]] + distance_matrix_3[rotated_segment[0], next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [rotated_segment[0]],\n            new_solution[best_pos:]\n        ])\n        # Complete the segment insertion\n        for node in rotated_segment[1:]:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6131157259407631,
            1.664938223361969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    reference_point = np.max(objectives, axis=0) * 1.1\n    volumes = np.prod(reference_point - objectives, axis=1)\n    selected_idx = np.argmax(volumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Adaptive segment selection based on objective diversity\n    seg_length = max(2, min(5, n//4))\n    start = np.random.randint(0, n - seg_length)\n\n    # Dynamic segment rotation with objective-aware node selection\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n\n    # Evaluate potential positions for insertion\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        # Multi-objective cost evaluation\n        cost1 = distance_matrix_1[prev_node, rotated_segment[0]] + distance_matrix_1[rotated_segment[0], next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, rotated_segment[0]] + distance_matrix_2[rotated_segment[0], next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, rotated_segment[0]] + distance_matrix_3[rotated_segment[0], next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [rotated_segment[0]],\n            new_solution[best_pos:]\n        ])\n        # Complete the segment insertion\n        for node in rotated_segment[1:]:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a hybrid local search that combines a novel multi-objective 2-opt with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective 2-opt with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node_to_insert:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node_to_insert]] + distance_matrix_1[new_solution[node_to_insert], new_solution[(pos+1)%n]] -\n                  distance_matrix_1[new_solution[pos-1], new_solution[pos]] - distance_matrix_1[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                  distance_matrix_1[new_solution[node_to_insert], new_solution[(node_to_insert+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node_to_insert]] + distance_matrix_2[new_solution[node_to_insert], new_solution[(pos+1)%n]] -\n                  distance_matrix_2[new_solution[pos-1], new_solution[pos]] - distance_matrix_2[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                  distance_matrix_2[new_solution[node_to_insert], new_solution[(node_to_insert+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node_to_insert]] + distance_matrix_3[new_solution[node_to_insert], new_solution[(pos+1)%n]] -\n                  distance_matrix_3[new_solution[pos-1], new_solution[pos]] - distance_matrix_3[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                  distance_matrix_3[new_solution[node_to_insert], new_solution[(node_to_insert+1)%n]]))\n\n        if cost < 0:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node_to_insert]], new_solution[pos:node_to_insert], new_solution[node_to_insert+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4901548675231845,
            2.78447939157486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective 2-opt with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node_to_insert:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node_to_insert]] + distance_matrix_1[new_solution[node_to_insert], new_solution[(pos+1)%n]] -\n                  distance_matrix_1[new_solution[pos-1], new_solution[pos]] - distance_matrix_1[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                  distance_matrix_1[new_solution[node_to_insert], new_solution[(node_to_insert+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node_to_insert]] + distance_matrix_2[new_solution[node_to_insert], new_solution[(pos+1)%n]] -\n                  distance_matrix_2[new_solution[pos-1], new_solution[pos]] - distance_matrix_2[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                  distance_matrix_2[new_solution[node_to_insert], new_solution[(node_to_insert+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node_to_insert]] + distance_matrix_3[new_solution[node_to_insert], new_solution[(pos+1)%n]] -\n                  distance_matrix_3[new_solution[pos-1], new_solution[pos]] - distance_matrix_3[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                  distance_matrix_3[new_solution[node_to_insert], new_solution[(node_to_insert+1)%n]]))\n\n        if cost < 0:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node_to_insert]], new_solution[pos:node_to_insert], new_solution[node_to_insert+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and neighborhood potential, then applies a novel multi-objective segment exchange strategy that combines adaptive path reversal with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = objectives.std(axis=1)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment exchange\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node reinsertion based on objective improvement\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and neighborhood potential, then applies a hybrid local search combining adaptive segment reversal with objective-aware node swapping to explore diverse trade-offs while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective awareness\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_segment = segment[::-1]  # Reverse the segment\n\n    # Objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply segment reversal\n    new_solution = np.concatenate([new_solution[:i], new_segment, new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7682066398979656,
            3.9703389286994932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    combined_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective awareness\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_segment = segment[::-1]  # Reverse the segment\n\n    # Objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply segment reversal\n    new_solution = np.concatenate([new_solution[:i], new_segment, new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This algorithm selects a solution from the archive based on the balance of all three objectives, then applies a hybrid local search strategy combining 2-opt swaps with multi-objective-aware edge reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balanced objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt swap with multi-objective-aware edge reinsertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    if i != 0 and j != n-1:\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Multi-objective-aware edge reinsertion\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        # Select insertion position based on combined distance improvement\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                improvement = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]] -\n                             distance_matrix_1[new_solution[-1], new_solution[0]]) + \\\n                            (distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]] -\n                             distance_matrix_2[new_solution[-1], new_solution[0]]) + \\\n                            (distance_matrix_3[new_solution[-1], node] + distance_matrix_3[node, new_solution[0]] -\n                             distance_matrix_3[new_solution[-1], new_solution[0]])\n            elif pos == len(new_solution)-1:\n                improvement = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]] -\n                             distance_matrix_1[new_solution[-2], new_solution[0]]) + \\\n                            (distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]] -\n                             distance_matrix_2[new_solution[-2], new_solution[0]]) + \\\n                            (distance_matrix_3[new_solution[-1], node] + distance_matrix_3[node, new_solution[0]] -\n                             distance_matrix_3[new_solution[-2], new_solution[0]])\n            else:\n                improvement = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] -\n                             distance_matrix_1[new_solution[pos-1], new_solution[pos]]) + \\\n                            (distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] -\n                             distance_matrix_2[new_solution[pos-1], new_solution[pos]]) + \\\n                            (distance_matrix_3[new_solution[pos-1], node] + distance_matrix_3[node, new_solution[pos]] -\n                             distance_matrix_3[new_solution[pos-1], new_solution[pos]])\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6815405915732944,
            3.8854506254196166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balanced objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balanced_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt swap with multi-objective-aware edge reinsertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    if i != 0 and j != n-1:\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Multi-objective-aware edge reinsertion\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        # Select insertion position based on combined distance improvement\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                improvement = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]] -\n                             distance_matrix_1[new_solution[-1], new_solution[0]]) + \\\n                            (distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]] -\n                             distance_matrix_2[new_solution[-1], new_solution[0]]) + \\\n                            (distance_matrix_3[new_solution[-1], node] + distance_matrix_3[node, new_solution[0]] -\n                             distance_matrix_3[new_solution[-1], new_solution[0]])\n            elif pos == len(new_solution)-1:\n                improvement = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]] -\n                             distance_matrix_1[new_solution[-2], new_solution[0]]) + \\\n                            (distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]] -\n                             distance_matrix_2[new_solution[-2], new_solution[0]]) + \\\n                            (distance_matrix_3[new_solution[-1], node] + distance_matrix_3[node, new_solution[0]] -\n                             distance_matrix_3[new_solution[-2], new_solution[0]])\n            else:\n                improvement = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] -\n                             distance_matrix_1[new_solution[pos-1], new_solution[pos]]) + \\\n                            (distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] -\n                             distance_matrix_2[new_solution[pos-1], new_solution[pos]]) + \\\n                            (distance_matrix_3[new_solution[pos-1], node] + distance_matrix_3[node, new_solution[pos]] -\n                             distance_matrix_3[new_solution[pos-1], new_solution[pos]])\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7622373871768312,
            1.5556856274604798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel hybrid local search that combines node swapping with a multi-objective segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best compromise between diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    quality_scores = np.sum(normalized_obj, axis=1)\n    combined_scores = diversity_scores * 0.4 + quality_scores * 0.6\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping with segment inversion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Swap nodes\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = new_solution[k-1]\n        curr = new_solution[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try segment inversion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = new_solution\n    else:\n        # Select a random segment and invert it\n        seg_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6962051770686621,
            3.5470423221588137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best compromise between diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    quality_scores = np.sum(normalized_obj, axis=1)\n    combined_scores = diversity_scores * 0.4 + quality_scores * 0.6\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swapping with segment inversion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Swap nodes\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = new_solution[k-1]\n        curr = new_solution[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try segment inversion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = new_solution\n    else:\n        # Select a random segment and invert it\n        seg_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high variance in objectives, then applies a hybrid local search combining 2-opt swaps with objective-aware node reinsertion to improve the least dominant objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware reinsertion\n    removed_node = new_solution[j]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6937965721834175,
            1.4012785315513612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware reinsertion\n    removed_node = new_solution[j]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objectives, then applies a novel 3-way segment swap operator that exchanges segments between three randomly chosen positions to improve all three objectives simultaneously while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select three random positions for segment swap\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Extract segments\n    seg1 = new_solution[a:b]\n    seg2 = new_solution[b:c]\n    seg3 = new_solution[c:] if c != n else np.array([])\n\n    # Create new solution by rotating segments\n    new_solution = np.concatenate([\n        seg2, seg3, seg1,\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6833911599306607,
            1.2743154525756837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select three random positions for segment swap\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Extract segments\n    seg1 = new_solution[a:b]\n    seg2 = new_solution[b:c]\n    seg3 = new_solution[c:] if c != n else np.array([])\n\n    # Create new solution by rotating segments\n    new_solution = np.concatenate([\n        seg2, seg3, seg1,\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective score that combines normalized objective values with adaptive weights, then applies a hybrid local search strategy combining 2-opt exchanges with multi-objective-aware node swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    dynamic_scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(dynamic_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective-aware node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt exchange\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swap\n    if k != l and (k not in [i, j] or l not in [i, j]):\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        new_solution[k], new_solution[l] = node_l, node_k\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7817916271548275,
            4.359719407558441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    dynamic_scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(dynamic_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective-aware node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt exchange\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swap\n    if k != l and (k not in [i, j] or l not in [i, j]):\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        new_solution[k], new_solution[l] = node_l, node_k\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{A novel tri-objective TSP algorithm that prioritizes solutions with diverse objective improvements while using a hybrid local search combining segment inversion and multi-objective-aware node swaps to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - objectives.min(axis=0)\n    selected_idx = np.argmax(np.sum(improvements > 0, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and multi-objective-aware node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swap\n    if np.random.rand() < 0.7:  # Higher probability for multi-objective swap\n        k = np.random.randint(n)\n        l = np.random.randint(n)\n        if k != l:\n            # Calculate potential improvement in all three objectives\n            orig_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                         distance_matrix_1[new_solution[l-1], new_solution[l]] +\n                         distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                        distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                        distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                        distance_matrix_1[new_solution[k], new_solution[(l+1)%n]])\n\n            if new_cost < orig_cost:  # Only swap if it improves at least one objective\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7564458013302513,
            3.6156805038452147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - objectives.min(axis=0)\n    selected_idx = np.argmax(np.sum(improvements > 0, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and multi-objective-aware node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective-aware node swap\n    if np.random.rand() < 0.7:  # Higher probability for multi-objective swap\n        k = np.random.randint(n)\n        l = np.random.randint(n)\n        if k != l:\n            # Calculate potential improvement in all three objectives\n            orig_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                         distance_matrix_1[new_solution[l-1], new_solution[l]] +\n                         distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                        distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                        distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                        distance_matrix_1[new_solution[k], new_solution[(l+1)%n]])\n\n            if new_cost < orig_cost:  # Only swap if it improves at least one objective\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7490596763778978,
            1.1524938821792603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel multi-objective diversity-aware selection strategy, then applies a hybrid local search that combines a weighted segment rotation with a multi-objective node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(np.abs(normalized_obj - np.mean(normalized_obj, axis=0)), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted segment rotation with multi-objective insertion\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Rotate segment\n    rotated_segment = np.roll(new_solution[start_pos:start_pos+segment_length], np.random.randint(1, segment_length))\n    new_solution[start_pos:start_pos+segment_length] = rotated_segment\n\n    # Multi-objective insertion with weighted objectives\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6617789505932548,
            1.5669703722000121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(np.abs(normalized_obj - np.mean(normalized_obj, axis=0)), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted segment rotation with multi-objective insertion\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Rotate segment\n    rotated_segment = np.roll(new_solution[start_pos:start_pos+segment_length], np.random.randint(1, segment_length))\n    new_solution[start_pos:start_pos+segment_length] = rotated_segment\n\n    # Multi-objective insertion with weighted objectives\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined trade-off and diversity-aware selection strategy, then applies a hybrid local search that combines a novel multi-objective segment inversion with a weighted node relocation heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Combined selection strategy\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    diversity_scores = np.std(objectives, axis=1)\n    combined_scores = tradeoff_scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment inversion with weighted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node relocation\n    weights = np.random.rand(3)\n    node_to_relocate = np.random.randint(0, n)\n    removed_node = new_solution[node_to_relocate]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_relocate:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7552029921278985,
            1.9771684646606444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Combined selection strategy\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    diversity_scores = np.std(objectives, axis=1)\n    combined_scores = tradeoff_scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment inversion with weighted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node relocation\n    weights = np.random.rand(3)\n    node_to_relocate = np.random.randint(0, n)\n    removed_node = new_solution[node_to_relocate]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_relocate:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Dynamic node relocation based on objective improvement\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score considering multi-objective trade-offs, then applies a hybrid local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Dynamic node swapping based on objective improvement\n    for _ in range(5):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7810473591424094,
            4.0189032554626465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score considering dominance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Dynamic node swapping based on objective improvement\n    for _ in range(5):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment insertion with dynamic node reinsertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n-1), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[b+1]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[b+1]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            temp = new_solution[a]\n            new_solution[a] = new_solution[b]\n            new_solution[b] = temp\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7690524757558329,
            3.635551702976227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n-1), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[b+1]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[b+1]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            temp = new_solution[a]\n            new_solution[a] = new_solution[b]\n            new_solution[b] = temp\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm employs a multi-objective dominance-aware selection followed by a hybrid local search that combines 2-opt edge exchanges with objective-specific node reinsertions to balance all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Perform 2-opt exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Reinsert nodes to optimize the least dominant objective\n    for _ in range(2):\n        node_to_move = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == current_pos:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6180878900210176,
            3.124757504463196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Perform 2-opt exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Reinsert nodes to optimize the least dominant objective\n    for _ in range(2):\n        node_to_move = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == current_pos:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{A novel multi-objective local search algorithm that selects solutions with high potential for improvement by prioritizing those with diverse objective trade-offs, then applies a hybrid operator combining segment inversion and node swap with adaptive neighborhood selection to generate high-quality neighbors across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(norm_obj * (1 - norm_obj), axis=1)  # Measures diversity in trade-offs\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive neighborhood\n    n = len(new_solution)\n    segment_size = max(2, min(5, int(np.random.exponential(scale=2))))  # Adaptive segment size\n    i = np.random.randint(0, n - segment_size + 1)\n    j = i + segment_size - 1\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap with objective-aware selection\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        # Evaluate potential swap impact across all objectives\n        delta_1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                   distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] -\n                   distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                   distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]) if k != (l+1)%n else 0\n        delta_2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                   distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] -\n                   distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                   distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]) if k != (l+1)%n else 0\n        delta_3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                   distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] -\n                   distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                   distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]) if k != (l+1)%n else 0\n\n        # Only perform swap if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6914710760620139,
            3.0224217057228087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(norm_obj * (1 - norm_obj), axis=1)  # Measures diversity in trade-offs\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive neighborhood\n    n = len(new_solution)\n    segment_size = max(2, min(5, int(np.random.exponential(scale=2))))  # Adaptive segment size\n    i = np.random.randint(0, n - segment_size + 1)\n    j = i + segment_size - 1\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap with objective-aware selection\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        # Evaluate potential swap impact across all objectives\n        delta_1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                   distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] -\n                   distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                   distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]) if k != (l+1)%n else 0\n        delta_2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                   distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] -\n                   distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                   distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]) if k != (l+1)%n else 0\n        delta_3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                   distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] -\n                   distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                   distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]) if k != (l+1)%n else 0\n\n        # Only perform swap if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This novel hybrid algorithm combines multi-objective dominance scoring with a four-phase local search (2-opt, insertion, node swap, and objective-aware segment inversion) to intelligently explore the solution space while maintaining feasibility across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: 2-opt with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.35 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.25\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Phase 4: Objective-aware segment inversion\n    if np.random.rand() < 0.3:\n        seg_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Select objective to prioritize\n        obj_weights = [0.4, 0.35, 0.25]\n        selected_obj = np.random.choice([0, 1, 2], p=obj_weights)\n\n        # Calculate improvement potential for inversion\n        original_cost = sum([\n            distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 0 else sum([\n            distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 1 else sum([\n            distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)\n        ])\n\n        inverted_cost = sum([\n            distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 0 else sum([\n            distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 1 else sum([\n            distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)\n        ])\n\n        if inverted_cost < original_cost:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6985987875087626,
            1.3594103693962096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: 2-opt with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.35 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.25\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Phase 4: Objective-aware segment inversion\n    if np.random.rand() < 0.3:\n        seg_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Select objective to prioritize\n        obj_weights = [0.4, 0.35, 0.25]\n        selected_obj = np.random.choice([0, 1, 2], p=obj_weights)\n\n        # Calculate improvement potential for inversion\n        original_cost = sum([\n            distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 0 else sum([\n            distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 1 else sum([\n            distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)\n        ])\n\n        inverted_cost = sum([\n            distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 0 else sum([\n            distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)\n        ]) if selected_obj == 1 else sum([\n            distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)\n        ])\n\n        if inverted_cost < original_cost:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Reverse the segment to create a new segment\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Apply dynamic node swapping based on the least dominant objective\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Prioritize improvement in the least dominant objective\n        if new_costs[least_dominant] < current_costs[least_dominant] or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.58803802432582,
            2.9587862133979796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Reverse the segment to create a new segment\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Apply dynamic node swapping based on the least dominant objective\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Prioritize improvement in the least dominant objective\n        if new_costs[least_dominant] < current_costs[least_dominant] or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This new algorithm selects a solution from the archive based on the most under-explored objective trade-offs, then applies a novel \"multi-objective segment shuffle\" operator that randomly reorders segments of the tour while ensuring feasibility, and evaluates the neighbor solution by considering the improvement in all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most under-explored objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    coverage = np.mean(norm_obj, axis=0)\n    selected_idx = np.argmax(np.dot(norm_obj, 1 - coverage))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    k = np.random.randint(2, 5)  # Number of segments to shuffle\n    segment_lengths = np.random.randint(1, n//k, size=k)\n    segment_lengths[-1] = n - sum(segment_lengths[:-1])\n    segments = np.split(new_solution, np.cumsum(segment_lengths)[:-1])\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7270988440008741,
            3.0243303179740906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most under-explored objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    coverage = np.mean(norm_obj, axis=0)\n    selected_idx = np.argmax(np.dot(norm_obj, 1 - coverage))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment shuffle\n    n = len(new_solution)\n    k = np.random.randint(2, 5)  # Number of segments to shuffle\n    segment_lengths = np.random.randint(1, n//k, size=k)\n    segment_lengths[-1] = n - sum(segment_lengths[:-1])\n    segments = np.split(new_solution, np.cumsum(segment_lengths)[:-1])\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(crowding_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))\n\n    for _ in range(k):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_segment = segment.copy()\n\n        if np.random.random() < 0.5:\n            new_segment = new_segment[::-1]\n        else:\n            np.random.shuffle(new_segment)\n\n        new_solution[a:b+1] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.596002544396321,
            3.1224290132522583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(crowding_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))\n\n    for _ in range(k):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_segment = segment.copy()\n\n        if np.random.random() < 0.5:\n            new_segment = new_segment[::-1]\n        else:\n            np.random.shuffle(new_segment)\n\n        new_solution[a:b+1] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7705683279598554,
            0.8467202305793762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm combines multi-objective selection with a novel three-phase local search that dynamically balances exploration and exploitation by first applying a weighted 2-opt, then performing a multi-objective insertion with adaptive weights, and finally refining with a guided node swap that considers both local and global objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity-aware dominance\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    diversity_scores = np.std(ranks, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: Dynamic weighted 2-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment_length = j - i + 1\n    weight1 = 1 - (segment_length / n) * 0.5\n    weight2 = (segment_length / n) * 0.3\n    weight3 = 0.2\n\n    original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] -\n                    distance_matrix_1[new_solution[i-1], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) * weight1 + \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] -\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) * weight2 + \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] -\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] - distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) * weight3\n\n    if original_cost > 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Multi-objective insertion with adaptive weights\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        current_cost = (distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node] -\n                        distance_matrix_1[prev_node, next_node]) * weight1 + \\\n                       (distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node] -\n                        distance_matrix_2[prev_node, next_node]) * weight2 + \\\n                       (distance_matrix_3[prev_node, new_solution[i]] + distance_matrix_3[new_solution[i], next_node] -\n                        distance_matrix_3[prev_node, next_node]) * weight3\n\n        if current_cost < min_cost:\n            min_cost = current_cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Guided node swap with objective correlation\n    if np.random.rand() < 0.4:\n        # Calculate objective correlations\n        obj_corr = np.corrcoef(objectives.T)[0,1:]\n\n        # Select nodes based on objective correlations\n        swap_positions = np.random.choice(n, 2, replace=False)\n        node1 = new_solution[swap_positions[0]]\n        node2 = new_solution[swap_positions[1]]\n\n        # Calculate potential improvement\n        improvement = (distance_matrix_1[new_solution[swap_positions[0]-1], node2] + distance_matrix_1[node2, new_solution[(swap_positions[0]+1)%n]] +\n                      distance_matrix_1[new_solution[swap_positions[1]-1], node1] + distance_matrix_1[node1, new_solution[(swap_positions[1]+1)%n]] -\n                      distance_matrix_1[new_solution[swap_positions[0]-1], node1] - distance_matrix_1[node1, new_solution[(swap_positions[0]+1)%n]] -\n                      distance_matrix_1[new_solution[swap_positions[1]-1], node2] - distance_matrix_1[node2, new_solution[(swap_positions[1]+1)%n]]) * obj_corr[0]\n\n        if improvement > 0:\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6598337800566132,
            1.9361375570297241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity-aware dominance\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    diversity_scores = np.std(ranks, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: Dynamic weighted 2-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment_length = j - i + 1\n    weight1 = 1 - (segment_length / n) * 0.5\n    weight2 = (segment_length / n) * 0.3\n    weight3 = 0.2\n\n    original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] -\n                    distance_matrix_1[new_solution[i-1], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) * weight1 + \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] -\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) * weight2 + \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] -\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] - distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) * weight3\n\n    if original_cost > 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Multi-objective insertion with adaptive weights\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        current_cost = (distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node] -\n                        distance_matrix_1[prev_node, next_node]) * weight1 + \\\n                       (distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node] -\n                        distance_matrix_2[prev_node, next_node]) * weight2 + \\\n                       (distance_matrix_3[prev_node, new_solution[i]] + distance_matrix_3[new_solution[i], next_node] -\n                        distance_matrix_3[prev_node, next_node]) * weight3\n\n        if current_cost < min_cost:\n            min_cost = current_cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Guided node swap with objective correlation\n    if np.random.rand() < 0.4:\n        # Calculate objective correlations\n        obj_corr = np.corrcoef(objectives.T)[0,1:]\n\n        # Select nodes based on objective correlations\n        swap_positions = np.random.choice(n, 2, replace=False)\n        node1 = new_solution[swap_positions[0]]\n        node2 = new_solution[swap_positions[1]]\n\n        # Calculate potential improvement\n        improvement = (distance_matrix_1[new_solution[swap_positions[0]-1], node2] + distance_matrix_1[node2, new_solution[(swap_positions[0]+1)%n]] +\n                      distance_matrix_1[new_solution[swap_positions[1]-1], node1] + distance_matrix_1[node1, new_solution[(swap_positions[1]+1)%n]] -\n                      distance_matrix_1[new_solution[swap_positions[0]-1], node1] - distance_matrix_1[node1, new_solution[(swap_positions[0]+1)%n]] -\n                      distance_matrix_1[new_solution[swap_positions[1]-1], node2] - distance_matrix_1[node2, new_solution[(swap_positions[1]+1)%n]]) * obj_corr[0]\n\n        if improvement > 0:\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-weighted objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a Pareto-aware node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with diversity-weighted objective selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized, axis=1) - np.max(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with Pareto-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    k = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Pareto-aware node insertion\n    node = np.random.choice(new_solution)\n    positions = np.random.choice(range(n), 2, replace=False)\n    pos1, pos2 = sorted(positions)\n\n    if pos1 != pos2:\n        # Calculate Pareto dominance\n        current_costs = [\n            distance_matrix_1[new_solution[pos1-1], node] + distance_matrix_1[node, new_solution[(pos1+1)%n]],\n            distance_matrix_2[new_solution[pos1-1], node] + distance_matrix_2[node, new_solution[(pos1+1)%n]],\n            distance_matrix_3[new_solution[pos1-1], node] + distance_matrix_3[node, new_solution[(pos1+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[pos2-1], node] + distance_matrix_1[node, new_solution[(pos2+1)%n]],\n            distance_matrix_2[new_solution[pos2-1], node] + distance_matrix_2[node, new_solution[(pos2+1)%n]],\n            distance_matrix_3[new_solution[pos2-1], node] + distance_matrix_3[node, new_solution[(pos2+1)%n]]\n        ]\n\n        # Check if new position dominates current position\n        if (all(new_costs[i] <= current_costs[i] for i in range(3)) and\n            any(new_costs[i] < current_costs[i] for i in range(3))):\n            new_solution = np.concatenate([\n                new_solution[:pos1], new_solution[pos1+1:pos2], [node], new_solution[pos2:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7469104893977164,
            3.1778042674064637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with diversity-weighted objective selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized, axis=1) - np.max(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with Pareto-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    k = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Pareto-aware node insertion\n    node = np.random.choice(new_solution)\n    positions = np.random.choice(range(n), 2, replace=False)\n    pos1, pos2 = sorted(positions)\n\n    if pos1 != pos2:\n        # Calculate Pareto dominance\n        current_costs = [\n            distance_matrix_1[new_solution[pos1-1], node] + distance_matrix_1[node, new_solution[(pos1+1)%n]],\n            distance_matrix_2[new_solution[pos1-1], node] + distance_matrix_2[node, new_solution[(pos1+1)%n]],\n            distance_matrix_3[new_solution[pos1-1], node] + distance_matrix_3[node, new_solution[(pos1+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[pos2-1], node] + distance_matrix_1[node, new_solution[(pos2+1)%n]],\n            distance_matrix_2[new_solution[pos2-1], node] + distance_matrix_2[node, new_solution[(pos2+1)%n]],\n            distance_matrix_3[new_solution[pos2-1], node] + distance_matrix_3[node, new_solution[(pos2+1)%n]]\n        ]\n\n        # Check if new position dominates current position\n        if (all(new_costs[i] <= current_costs[i] for i in range(3)) and\n            any(new_costs[i] < current_costs[i] for i in range(3))):\n            new_solution = np.concatenate([\n                new_solution[:pos1], new_solution[pos1+1:pos2], [node], new_solution[pos2:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a multi-objective edge insertion with a weighted segment rotation heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    tradeoff_scores = np.mean(normalized_objectives, axis=1) * diversity_scores\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge insertion with weighted segment rotation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Perform edge insertion\n    if i != j:\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Weighted segment rotation\n    weights = np.random.rand(3)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k < l:\n        segment = new_solution[k:l+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[k:l+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.503265577920468,
            2.2697651386260986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    tradeoff_scores = np.mean(normalized_objectives, axis=1) * diversity_scores\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge insertion with weighted segment rotation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Perform edge insertion\n    if i != j:\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Weighted segment rotation\n    weights = np.random.rand(3)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k < l:\n        segment = new_solution[k:l+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[k:l+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{A novel algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) using weighted objective contributions and adaptive selection pressure to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    weights = np.array([0.4, 0.3, 0.3])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7166549325648036,
            1.0533800721168518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    weights = np.array([0.4, 0.3, 0.3])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment insertion with a weighted node swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment insertion\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Weighted node swap\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4535096114637113,
            1.3939315915107726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment insertion\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Weighted node swap\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity metric, then applies a hybrid local search combining multi-objective path inversion with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective path inversion with weighted node insertion\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))\n    indices = sorted(np.random.choice(range(n), k, replace=False))\n\n    # Perform path inversion\n    for i in range(len(indices)//2):\n        start = indices[i]\n        end = indices[-i-1]\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    removed_node = new_solution[node_to_insert]\n\n    # Find best insertion position\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_insert or i == node_to_insert - 1:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_to_insert)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4663647449256162,
            3.295327305793762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective path inversion with weighted node insertion\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))\n    indices = sorted(np.random.choice(range(n), k, replace=False))\n\n    # Perform path inversion\n    for i in range(len(indices)//2):\n        start = indices[i]\n        end = indices[-i-1]\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    removed_node = new_solution[node_to_insert]\n\n    # Find best insertion position\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_insert or i == node_to_insert - 1:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_to_insert)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel hybrid algorithm that combines crowding distance-based selection with a multi-objective 3-opt local search to generate high-quality neighbors by intelligently exploring the trade-off space across three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        max_obj = sorted_objectives[-1]\n        min_obj = sorted_objectives[0]\n\n        if max_obj == min_obj:\n            crowding_distances[sorted_indices] += 0\n        else:\n            crowding_distances[sorted_indices[0]] = float('inf')\n            crowding_distances[sorted_indices[-1]] = float('inf')\n            for j in range(1, len(sorted_indices)-1):\n                crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (max_obj - min_obj)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Generate all possible 3-opt moves\n    candidates = [\n        # Reverse segments between a-b, b-c, and a-c\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]]),\n        # Reverse a-b and insert c\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], [new_solution[c]], new_solution[b:c], new_solution[c+1:]]),\n        # Reverse b-c and insert a\n        np.concatenate([new_solution[:b], new_solution[b:c][::-1], [new_solution[a]], new_solution[c:]]),\n        # Reverse a-c and insert b\n        np.concatenate([new_solution[:a], new_solution[a:c][::-1], [new_solution[b]], new_solution[c:]])\n    ]\n\n    # Evaluate all candidates based on all three objectives\n    best_candidate = None\n    best_improvement = -float('inf')\n\n    for candidate in candidates:\n        if len(np.unique(candidate)) != n:\n            continue\n\n        # Calculate total improvement across all three objectives\n        improvement = 0\n        for i, matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            current_cost = 0\n            new_cost = 0\n\n            for j in range(n):\n                current_cost += matrix[base_solution[j], base_solution[(j+1)%n]]\n                new_cost += matrix[candidate[j], candidate[(j+1)%n]]\n\n            improvement += (current_cost - new_cost) / (current_cost + 1e-6)  # Normalized improvement\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate.copy()\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.632068621345834,
            3.9519680380821227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        max_obj = sorted_objectives[-1]\n        min_obj = sorted_objectives[0]\n\n        if max_obj == min_obj:\n            crowding_distances[sorted_indices] += 0\n        else:\n            crowding_distances[sorted_indices[0]] = float('inf')\n            crowding_distances[sorted_indices[-1]] = float('inf')\n            for j in range(1, len(sorted_indices)-1):\n                crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (max_obj - min_obj)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Generate all possible 3-opt moves\n    candidates = [\n        # Reverse segments between a-b, b-c, and a-c\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]]),\n        # Reverse a-b and insert c\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], [new_solution[c]], new_solution[b:c], new_solution[c+1:]]),\n        # Reverse b-c and insert a\n        np.concatenate([new_solution[:b], new_solution[b:c][::-1], [new_solution[a]], new_solution[c:]]),\n        # Reverse a-c and insert b\n        np.concatenate([new_solution[:a], new_solution[a:c][::-1], [new_solution[b]], new_solution[c:]])\n    ]\n\n    # Evaluate all candidates based on all three objectives\n    best_candidate = None\n    best_improvement = -float('inf')\n\n    for candidate in candidates:\n        if len(np.unique(candidate)) != n:\n            continue\n\n        # Calculate total improvement across all three objectives\n        improvement = 0\n        for i, matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            current_cost = 0\n            new_cost = 0\n\n            for j in range(n):\n                current_cost += matrix[base_solution[j], base_solution[(j+1)%n]]\n                new_cost += matrix[candidate[j], candidate[(j+1)%n]]\n\n            improvement += (current_cost - new_cost) / (current_cost + 1e-6)  # Normalized improvement\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate.copy()\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective diversity analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment rotation and node reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_idx = np.argmax(objectives.max(axis=1))\n    base_solution = archive[worst_obj_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[worst_obj_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it by one position\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least dominant objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm employs a multi-objective aware segment inversion strategy that combines 3-opt local search with a novel objective-balancing mechanism, selecting solutions based on their diversity in objective space and applying a hybrid operator that inverts segments while considering the trade-offs between objectives to create balanced improvements across all three dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    hypervolumes = np.prod(normalized_obj, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 3-opt with objective-aware segment inversion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Three possible 3-opt moves\n    options = [\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n    ]\n\n    # Evaluate each option based on objective trade-offs\n    best_option = None\n    best_score = float('inf')\n\n    for option in options:\n        # Calculate objective costs\n        cost1 = sum(distance_matrix_1[option[l], option[l+1]] for l in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[l], option[l+1]] for l in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n        cost3 = sum(distance_matrix_3[option[l], option[l+1]] for l in range(n-1)) + distance_matrix_3[option[-1], option[0]]\n\n        # Balance objectives using weighted sum (weights inversely proportional to current solution's objectives)\n        current_costs = objectives[selected_idx]\n        weights = 1 / (current_costs + 1e-8)\n        weights /= weights.sum()\n        score = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n\n        if score < best_score:\n            best_score = score\n            best_option = option\n\n    new_solution = best_option.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6612136040293378,
            2.932639002799988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    hypervolumes = np.prod(normalized_obj, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 3-opt with objective-aware segment inversion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Three possible 3-opt moves\n    options = [\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n    ]\n\n    # Evaluate each option based on objective trade-offs\n    best_option = None\n    best_score = float('inf')\n\n    for option in options:\n        # Calculate objective costs\n        cost1 = sum(distance_matrix_1[option[l], option[l+1]] for l in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[l], option[l+1]] for l in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n        cost3 = sum(distance_matrix_3[option[l], option[l+1]] for l in range(n-1)) + distance_matrix_3[option[-1], option[0]]\n\n        # Balance objectives using weighted sum (weights inversely proportional to current solution's objectives)\n        current_costs = objectives[selected_idx]\n        weights = 1 / (current_costs + 1e-8)\n        weights /= weights.sum()\n        score = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n\n        if score < best_score:\n            best_score = score\n            best_option = option\n\n    new_solution = best_option.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a multi-objective 3-opt move with a weighted edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(normalized_obj * (1 - normalized_obj), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective 3-opt with weighted edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    node = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node and pos != (node + 1) % n:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[pos]] - distance_matrix_1[new_solution[node-1], new_solution[node]] -\n                distance_matrix_1[new_solution[node], new_solution[(node+1)%n]] + distance_matrix_1[new_solution[node-1], new_solution[(node+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[pos]] - distance_matrix_2[new_solution[node-1], new_solution[node]] -\n                distance_matrix_2[new_solution[node], new_solution[(node+1)%n]] + distance_matrix_2[new_solution[node-1], new_solution[(node+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_3[new_solution[pos-1], new_solution[pos]] - distance_matrix_3[new_solution[node-1], new_solution[node]] -\n                distance_matrix_3[new_solution[node], new_solution[(node+1)%n]] + distance_matrix_3[new_solution[node-1], new_solution[(node+1)%n]]))\n\n        if cost < 0:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, pos, base_solution[node])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6602387518911336,
            2.5569488525390627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(normalized_obj * (1 - normalized_obj), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective 3-opt with weighted edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    node = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node and pos != (node + 1) % n:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[pos]] - distance_matrix_1[new_solution[node-1], new_solution[node]] -\n                distance_matrix_1[new_solution[node], new_solution[(node+1)%n]] + distance_matrix_1[new_solution[node-1], new_solution[(node+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[pos]] - distance_matrix_2[new_solution[node-1], new_solution[node]] -\n                distance_matrix_2[new_solution[node], new_solution[(node+1)%n]] + distance_matrix_2[new_solution[node-1], new_solution[(node+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_3[new_solution[pos-1], new_solution[pos]] - distance_matrix_3[new_solution[node-1], new_solution[node]] -\n                distance_matrix_3[new_solution[node], new_solution[(node+1)%n]] + distance_matrix_3[new_solution[node-1], new_solution[(node+1)%n]]))\n\n        if cost < 0:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, pos, base_solution[node])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{The new algorithm selects a solution from the archive based on the most under-explored objective trade-off, then applies a hybrid local search combining multi-objective-aware segment reversal and targeted node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most under-explored trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(np.prod(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective-aware segment reversal and targeted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal with objective awareness\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Perform targeted node relocation\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Calculate potential insertion positions based on all three objectives\n        potential_positions = []\n        for pos in range(n-1):\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            cost3 = distance_matrix_3[new_solution[pos-1], node] + distance_matrix_3[node, new_solution[pos]]\n            potential_positions.append((cost1 + cost2 + cost3, pos))\n\n        # Select best position based on combined objectives\n        best_pos = min(potential_positions, key=lambda x: x[0])[1]\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5948598011001589,
            2.8008198022842405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most under-explored trade-off\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmax(np.prod(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective-aware segment reversal and targeted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal with objective awareness\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Perform targeted node relocation\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Calculate potential insertion positions based on all three objectives\n        potential_positions = []\n        for pos in range(n-1):\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            cost3 = distance_matrix_3[new_solution[pos-1], node] + distance_matrix_3[node, new_solution[pos]]\n            potential_positions.append((cost1 + cost2 + cost3, pos))\n\n        # Select best position based on combined objectives\n        best_pos = min(potential_positions, key=lambda x: x[0])[1]\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel multi-objective Pareto front diversity metric, then applies a hybrid local search combining a weighted segment reversal with a novel three-dimensional node insertion heuristic to generate a neighbor solution while ensuring feasibility across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto front diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted segment reversal with 3D node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Weighted segment reversal\n    weights = np.random.rand(3)\n    original_cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                    weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                    weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n    reversed_cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) +\n                   weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) +\n                   weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]))\n\n    if reversed_cost < original_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3D node insertion\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n               weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n               weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([new_solution[:best_pos], [removed_node], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7118310723648857,
            3.7675082087516785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto front diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted segment reversal with 3D node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Weighted segment reversal\n    weights = np.random.rand(3)\n    original_cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                    weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                    weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n    reversed_cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) +\n                   weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) +\n                   weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]))\n\n    if reversed_cost < original_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3D node insertion\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n               weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n               weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([new_solution[:best_pos], [removed_node], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm employs a three-stage local search process (2-opt, insertion, and node swap) with objective-aware selection, combined with a dominance-based solution selection mechanism to generate high-quality neighbors while maintaining feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with weighted objective improvement\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) + \\\n               (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) + \\\n               (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n    if new_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with objective balance\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.6 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.1\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversification\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        a, b = swap_positions\n        obj_a = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]) + \\\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]) + \\\n                (distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        obj_b = (distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]) + \\\n                (distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]) + \\\n                (distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        if obj_a > obj_b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7350740776685964,
            1.1007269501686097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with weighted objective improvement\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) + \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) + \\\n               (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) + \\\n               (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n    if new_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with objective balance\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.6 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.1\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversification\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        a, b = swap_positions\n        obj_a = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]) + \\\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]) + \\\n                (distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        obj_b = (distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]) + \\\n                (distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]) + \\\n                (distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        if obj_a > obj_b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective dominance metric combined with a greedy improvement criterion, then applies a hybrid local search operator that dynamically combines 2-opt moves with adaptive node insertion, ensuring feasibility while exploring trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a != b:\n            segment = new_solution[a:b+1]\n            new_segment = segment[::-1]\n            new_solution[a:b+1] = new_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a != b:\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7343993567427821,
            3.318227005004883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a != b:\n            segment = new_solution[a:b+1]\n            new_segment = segment[::-1]\n            new_solution[a:b+1] = new_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a != b:\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest crowding distance in objective space, then applies a novel adaptive segment swap operator that dynamically adjusts segment length based on objective correlation, followed by a multi-objective-aware node insertion heuristic to ensure balanced improvement across all objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n_obj = objectives.shape[1]\n    n_sol = objectives.shape[0]\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(n_sol)\n    for m in range(n_obj):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, n_sol-1):\n            if sorted_obj[-1] == sorted_obj[0]:\n                crowding_distances[sorted_idx[i]] += 0\n            else:\n                crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlations\n    corr_matrix = np.corrcoef(objectives.T)\n    avg_corr = np.mean(np.abs(corr_matrix[np.triu_indices(n_obj, 1)]))\n\n    # Adaptive segment swap\n    n = len(new_solution)\n    seg_length = max(2, min(5, int(3 + avg_corr * (n//3))))  # Adjust based on correlation\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Swap segments\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Multi-objective-aware node insertion\n    for _ in range(2):  # Perform multiple insertions\n        # Select node to move based on worst objective\n        obj_values = np.array([objectives[selected_idx]])\n        worst_obj = np.argmax(obj_values)\n        node_to_move = new_solution[np.random.randint(0, n)]\n\n        # Find best insertion position\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start1 and i < start1+seg_length:\n                continue\n            if i >= start2 and i < start2+seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] -\n                    distance_matrix_1[prev_node, next_node]) * (1 + worst_obj == 0) + \\\n                   (distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] -\n                    distance_matrix_2[prev_node, next_node]) * (1 + worst_obj == 1) + \\\n                   (distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node] -\n                    distance_matrix_3[prev_node, next_node]) * (1 + worst_obj == 2)\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6349819767211133,
            4.065127217769623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n_obj = objectives.shape[1]\n    n_sol = objectives.shape[0]\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(n_sol)\n    for m in range(n_obj):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, n_sol-1):\n            if sorted_obj[-1] == sorted_obj[0]:\n                crowding_distances[sorted_idx[i]] += 0\n            else:\n                crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlations\n    corr_matrix = np.corrcoef(objectives.T)\n    avg_corr = np.mean(np.abs(corr_matrix[np.triu_indices(n_obj, 1)]))\n\n    # Adaptive segment swap\n    n = len(new_solution)\n    seg_length = max(2, min(5, int(3 + avg_corr * (n//3))))  # Adjust based on correlation\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Swap segments\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Multi-objective-aware node insertion\n    for _ in range(2):  # Perform multiple insertions\n        # Select node to move based on worst objective\n        obj_values = np.array([objectives[selected_idx]])\n        worst_obj = np.argmax(obj_values)\n        node_to_move = new_solution[np.random.randint(0, n)]\n\n        # Find best insertion position\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start1 and i < start1+seg_length:\n                continue\n            if i >= start2 and i < start2+seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] -\n                    distance_matrix_1[prev_node, next_node]) * (1 + worst_obj == 0) + \\\n                   (distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] -\n                    distance_matrix_2[prev_node, next_node]) * (1 + worst_obj == 1) + \\\n                   (distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node] -\n                    distance_matrix_3[prev_node, next_node]) * (1 + worst_obj == 2)\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that balances all three objectives, then applies a hybrid local search combining adaptive segment reversal with multi-objective-aware node insertion, ensuring feasibility while exploring diverse trade-offs across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-10)\n    sum_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(sum_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    if np.random.random() < 0.5:\n        new_solution[i:j+1] = segment[::-1]\n    else:\n        k = np.random.randint(i, j+1)\n        new_solution[i:j+1] = np.roll(segment, k-i)\n\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        if b - a > 1:\n            pos = np.random.randint(a+1, b)\n            node = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6510943437525645,
            2.871896731853485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-10)\n    sum_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(sum_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n    if np.random.random() < 0.5:\n        new_solution[i:j+1] = segment[::-1]\n    else:\n        k = np.random.randint(i, j+1)\n        new_solution[i:j+1] = np.roll(segment, k-i)\n\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        if b - a > 1:\n            pos = np.random.randint(a+1, b)\n            node = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This new algorithm prioritizes solutions with balanced objective values using a weighted dominance score, then applies a hybrid local search that adaptively selects between segment reversal and node reinsertion based on the relative improvement potential across all three objectives, with a focus on the most underperforming objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weighted dominance score (prioritize balanced solutions)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = normalized.std(axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine which search operator to use (50% chance for each)\n    if np.random.rand() < 0.5:\n        # Segment reversal with adaptive length\n        n = len(new_solution)\n        seg_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        new_solution[start:start+seg_length] = segment[::-1]\n    else:\n        # Node reinsertion targeting the most underperforming objective\n        worst_obj = objectives[selected_idx]\n        least_dominant = np.argmax(worst_obj)\n        node_to_move = np.random.choice(new_solution)\n        new_solution = np.setdiff1d(new_solution, [node_to_move])\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution)-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7054739234438314,
            3.0011852622032165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weighted dominance score (prioritize balanced solutions)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = normalized.std(axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine which search operator to use (50% chance for each)\n    if np.random.rand() < 0.5:\n        # Segment reversal with adaptive length\n        n = len(new_solution)\n        seg_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        new_solution[start:start+seg_length] = segment[::-1]\n    else:\n        # Node reinsertion targeting the most underperforming objective\n        worst_obj = objectives[selected_idx]\n        least_dominant = np.argmax(worst_obj)\n        node_to_move = np.random.choice(new_solution)\n        new_solution = np.setdiff1d(new_solution, [node_to_move])\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution)-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced trade-off across objectives, then applies a hybrid local search strategy combining segment inversion and node swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7304399911896462,
            2.545139753818512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) using weighted objective contributions and adaptive selection pressure to balance exploration and exploitation across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    weights = np.array([0.4, 0.3, 0.3])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{A novel three-phase local search algorithm that combines adaptive dominance-aware selection with weighted multi-objective edge swapping, dynamic insertion, and probabilistic node repositioning to balance exploration and exploitation across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    dominance_scores = 1 - normalized_obj\n    weights = np.array([0.5, 0.3, 0.2])\n    selection_prob = (dominance_scores * weights).sum(axis=1)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    if np.random.rand() < 0.6:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if np.random.rand() < 0.4:\n        removed_node = new_solution[i]\n        best_pos = i\n        min_cost = float('inf')\n\n        for k in range(n):\n            if k == i or k == j:\n                continue\n\n            prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n                   (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n                   (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node]) * 0.2\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = k\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.2:\n        segment_start = np.random.randint(0, n-2)\n        segment_length = np.random.randint(2, n-segment_start)\n        segment = new_solution[segment_start:segment_start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            segment[::-1],\n            new_solution[segment_start+segment_length:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7460574342164921,
            2.4109435081481934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    dominance_scores = 1 - normalized_obj\n    weights = np.array([0.5, 0.3, 0.2])\n    selection_prob = (dominance_scores * weights).sum(axis=1)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    if np.random.rand() < 0.6:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if np.random.rand() < 0.4:\n        removed_node = new_solution[i]\n        best_pos = i\n        min_cost = float('inf')\n\n        for k in range(n):\n            if k == i or k == j:\n                continue\n\n            prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n                   (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n                   (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node]) * 0.2\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = k\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.2:\n        segment_start = np.random.randint(0, n-2)\n        segment_length = np.random.randint(2, n-segment_start)\n        segment = new_solution[segment_start:segment_start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            segment[::-1],\n            new_solution[segment_start+segment_length:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted combination of normalized objective values, then applies a hybrid local search that combines 3-opt with a multi-objective edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with dynamic weighted performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(normalized_objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_config = new_solution\n    min_cost = float('inf')\n\n    for config in configurations:\n        total_cost = 0\n        for m in range(n):\n            prev = config[m-1]\n            curr = config[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_config = config\n\n    if min_cost < sum(objectives[selected_idx]):\n        new_solution = best_config\n    else:\n        # Multi-objective edge insertion\n        edge_to_remove = np.random.randint(0, n)\n        removed_edge = (new_solution[edge_to_remove-1], new_solution[edge_to_remove])\n\n        best_insert_pos = 0\n        min_insert_cost = float('inf')\n\n        for pos in range(n):\n            if pos == edge_to_remove-1 or pos == edge_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_edge[0]] + distance_matrix_1[removed_edge[1], next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_edge[0]] + distance_matrix_2[removed_edge[1], next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_edge[0]] + distance_matrix_3[removed_edge[1], next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_insert_cost:\n                min_insert_cost = cost\n                best_insert_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            [removed_edge[0], removed_edge[1]],\n            new_solution[best_insert_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6210793938098872,
            1.25506649017334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with dynamic weighted performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(normalized_objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_config = new_solution\n    min_cost = float('inf')\n\n    for config in configurations:\n        total_cost = 0\n        for m in range(n):\n            prev = config[m-1]\n            curr = config[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_config = config\n\n    if min_cost < sum(objectives[selected_idx]):\n        new_solution = best_config\n    else:\n        # Multi-objective edge insertion\n        edge_to_remove = np.random.randint(0, n)\n        removed_edge = (new_solution[edge_to_remove-1], new_solution[edge_to_remove])\n\n        best_insert_pos = 0\n        min_insert_cost = float('inf')\n\n        for pos in range(n):\n            if pos == edge_to_remove-1 or pos == edge_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_edge[0]] + distance_matrix_1[removed_edge[1], next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_edge[0]] + distance_matrix_2[removed_edge[1], next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_edge[0]] + distance_matrix_3[removed_edge[1], next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_insert_cost:\n                min_insert_cost = cost\n                best_insert_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            [removed_edge[0], removed_edge[1]],\n            new_solution[best_insert_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search strategy that combines segment rotation and multi-objective-aware node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment rotation and multi-objective-aware node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Perform multi-objective-aware node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective ranking, then applies a novel multi-objective-aware local search strategy that combines adaptive segment inversion with dynamic node relocation, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n    new_solution[i:j+1] = inverted_segment\n\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if np.random.random() < 0.3:\n            if sum(new_costs) < sum(current_costs):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            obj_weights = np.random.dirichlet(np.ones(3), size=1)[0]\n            if np.dot(new_costs, obj_weights) < np.dot(current_costs, obj_weights):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6628989193629695,
            3.05070241689682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n    new_solution[i:j+1] = inverted_segment\n\n    for _ in range(2):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if np.random.random() < 0.3:\n            if sum(new_costs) < sum(current_costs):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            obj_weights = np.random.dirichlet(np.ones(3), size=1)[0]\n            if np.dot(new_costs, obj_weights) < np.dot(current_costs, obj_weights):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel objective diversity metric that considers both objective values and their distribution in the archive, then applies a hybrid local search combining a multi-objective segment insertion with a weighted edge swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * obj_range, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - seg_length)\n    while insert_pos >= start and insert_pos < start + seg_length:\n        insert_pos = np.random.randint(0, n - seg_length)\n\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        np.delete(new_solution, np.arange(start, start+seg_length))\n    ])\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        if cost < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.666955987255546,
            1.0424012422561646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * obj_range, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - seg_length)\n    while insert_pos >= start and insert_pos < start + seg_length:\n        insert_pos = np.random.randint(0, n - seg_length)\n\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        np.delete(new_solution, np.arange(start, start+seg_length))\n    ])\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        if cost < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm uses a multi-objective selection criterion based on crowding distance and objective diversity, combined with a hybrid local search operator that performs adaptive segment swaps and node reinsertions to balance improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify objectives with high diversity\n    obj_diversity = objectives.std(axis=0)\n    priority_obj = np.argmax(obj_diversity)\n\n    # Perform hybrid local search\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(8, n//3))\n\n    # Random segment swap\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length]\n    segment2 = new_solution[start2:start2+seg_length]\n\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Reinsert nodes to optimize priority objective\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        removed_node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n-1):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-2 else new_solution[0]\n\n            if priority_obj == 0:\n                cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif priority_obj == 1:\n                cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [removed_node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6801153386324412,
            4.333707666397094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify objectives with high diversity\n    obj_diversity = objectives.std(axis=0)\n    priority_obj = np.argmax(obj_diversity)\n\n    # Perform hybrid local search\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(8, n//3))\n\n    # Random segment swap\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length]\n    segment2 = new_solution[start2:start2+seg_length]\n\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Reinsert nodes to optimize priority objective\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        removed_node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n-1):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-2 else new_solution[0]\n\n            if priority_obj == 0:\n                cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif priority_obj == 1:\n                cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [removed_node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) using weighted objective contributions and adaptive selection pressure to balance exploration and exploitation across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    weights = np.array([0.4, 0.3, 0.3])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{A new algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) using adaptive objective weights and non-linear improvement potential to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj ** 2\n    weights = np.array([0.5, 0.3, 0.2])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7242270390705882,
            1.0454744219779968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj ** 2\n    weights = np.array([0.5, 0.3, 0.2])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best dominance-aware objective selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    dominance_scores = np.sum(normalized_obj <= normalized_obj, axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal with objective-aware selection\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    cost = 0\n    for k in range(len(segment)-1):\n        cost += (distance_matrix_1[segment[k], segment[k+1]] + distance_matrix_2[segment[k], segment[k+1]] + distance_matrix_3[segment[k], segment[k+1]]) - \\\n               (distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] + distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] + distance_matrix_3[reversed_segment[k], reversed_segment[k+1]])\n\n    if cost > 0:\n        new_solution[i:j+1] = reversed_segment\n\n    # Weighted node exchange with objective diversity\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6694268589708442,
            4.1855028629302975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best dominance-aware objective selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    dominance_scores = np.sum(normalized_obj <= normalized_obj, axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal with objective-aware selection\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    cost = 0\n    for k in range(len(segment)-1):\n        cost += (distance_matrix_1[segment[k], segment[k+1]] + distance_matrix_2[segment[k], segment[k+1]] + distance_matrix_3[segment[k], segment[k+1]]) - \\\n               (distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] + distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] + distance_matrix_3[reversed_segment[k], reversed_segment[k+1]])\n\n    if cost > 0:\n        new_solution[i:j+1] = reversed_segment\n\n    # Weighted node exchange with objective diversity\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) using weighted objective contributions and adaptive selection pressure to balance exploration and exploitation across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    weights = np.array([0.4, 0.3, 0.3])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.4 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.4:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel algorithm that leverages multi-objective crowding distance to select a solution from the archive, then applies a probabilistic segment inversion and adaptive node insertion heuristic that dynamically adjusts operator probabilities based on the current solution's objective trade-offs to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2])\n\n    # Select solution with highest crowding distance (well-distributed in objective space)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Calculate objective trade-off ratios\n    obj_ratios = objectives[selected_idx] / (objectives[selected_idx].sum() + 1e-10)\n\n    # Adaptive operator selection probabilities based on trade-off\n    prob_inversion = 0.5 + 0.3 * obj_ratios[0] - 0.2 * obj_ratios[1]\n    prob_insertion = 0.4 + 0.3 * obj_ratios[1] - 0.2 * obj_ratios[2]\n\n    # Apply probabilistic segment inversion\n    if np.random.rand() < prob_inversion:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply adaptive node insertion\n    if np.random.rand() < prob_insertion:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6394407314156145,
            3.679132080078125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2])\n\n    # Select solution with highest crowding distance (well-distributed in objective space)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Calculate objective trade-off ratios\n    obj_ratios = objectives[selected_idx] / (objectives[selected_idx].sum() + 1e-10)\n\n    # Adaptive operator selection probabilities based on trade-off\n    prob_inversion = 0.5 + 0.3 * obj_ratios[0] - 0.2 * obj_ratios[1]\n    prob_insertion = 0.4 + 0.3 * obj_ratios[1] - 0.2 * obj_ratios[2]\n\n    # Apply probabilistic segment inversion\n    if np.random.rand() < prob_inversion:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply adaptive node insertion\n    if np.random.rand() < prob_insertion:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    tradeoff_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment reversal with objective-aware selection\n    n = len(new_solution)\n    segment_lengths = np.random.randint(2, min(10, n//2), size=3)\n    for length in segment_lengths:\n        i = np.random.randint(0, n - length)\n        j = i + length - 1\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the impact on all three objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(i, j+2))\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(i, j+2))\n        ]\n\n        # Apply if improvement in at least one objective\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution = temp_solution\n\n    # Dynamic node swapping with objective prioritization\n    for _ in range(5):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        weighted_improvement = sum((current_cost - new_cost) * weight for current_cost, new_cost, weight in zip(current_costs, new_costs, obj_weights))\n        if weighted_improvement > 0 or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7685865396275859,
            4.232226634025574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    tradeoff_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment reversal with objective-aware selection\n    n = len(new_solution)\n    segment_lengths = np.random.randint(2, min(10, n//2), size=3)\n    for length in segment_lengths:\n        i = np.random.randint(0, n - length)\n        j = i + length - 1\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the impact on all three objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(i, j+2))\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(i, j+2)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(i, j+2))\n        ]\n\n        # Apply if improvement in at least one objective\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution = temp_solution\n\n    # Dynamic node swapping with objective prioritization\n    for _ in range(5):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        weighted_improvement = sum((current_cost - new_cost) * weight for current_cost, new_cost, weight in zip(current_costs, new_costs, obj_weights))\n        if weighted_improvement > 0 or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a novel objective diversity metric that considers both objective values and their distribution in the archive, then applies a hybrid local search combining a multi-objective segment insertion with a weighted edge swap heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * obj_range, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - seg_length)\n    while insert_pos >= start and insert_pos < start + seg_length:\n        insert_pos = np.random.randint(0, n - seg_length)\n\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        np.delete(new_solution, np.arange(start, start+seg_length))\n    ])\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        if cost < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective balance metric that considers the relative improvement potential of each objective, then applies a hybrid local search combining a multi-objective node relocation with a weighted segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    improvement_potential = obj_range / (1 + objectives)\n    balance_scores = np.sum(improvement_potential, axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    new_solution[start:start+seg_length] = rotated_segment\n\n    weights = np.random.rand(3)\n    for _ in range(3):\n        node_pos = np.random.randint(0, n)\n        if node_pos >= start and node_pos < start + seg_length:\n            continue\n\n        removed_node = new_solution[node_pos]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i == node_pos or (i >= start and i < start + seg_length):\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:],\n                [removed_node]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [removed_node],\n                new_solution[best_pos:]\n            ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6463467382808581,
            1.3026607155799865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    improvement_potential = obj_range / (1 + objectives)\n    balance_scores = np.sum(improvement_potential, axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    new_solution[start:start+seg_length] = rotated_segment\n\n    weights = np.random.rand(3)\n    for _ in range(3):\n        node_pos = np.random.randint(0, n)\n        if node_pos >= start and node_pos < start + seg_length:\n            continue\n\n        removed_node = new_solution[node_pos]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i == node_pos or (i >= start and i < start + seg_length):\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:],\n                [removed_node]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [removed_node],\n                new_solution[best_pos:]\n            ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm prioritizes solutions with balanced objective values, then applies a multi-phase local search combining adaptive segment reversal, dynamic node insertion, and objective-aware edge swapping to simultaneously optimize all three objectives while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    balance_scores = np.linalg.norm(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment reversal\n    obj_weights = objectives[selected_idx] / np.sum(objectives[selected_idx])\n    seg_length = max(2, int(np.random.normal(n/4, n/8)))\n    seg_length = min(seg_length, n-1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    if np.random.random() < 0.7:\n        reversed_segment = segment[::-1]\n        new_solution[start:start+seg_length] = reversed_segment\n\n    # Phase 2: Dynamic node insertion\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution)-1 else new_solution[0]\n\n            cost = (obj_weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    obj_weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    obj_weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Phase 3: Objective-aware edge swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(len(new_solution)), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if (sum(new_costs) < sum(current_costs) or\n            (np.random.random() < 0.2 and any(nc < cc for nc, cc in zip(new_costs, current_costs)))):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.723984152057532,
            4.316595482826233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    balance_scores = np.linalg.norm(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment reversal\n    obj_weights = objectives[selected_idx] / np.sum(objectives[selected_idx])\n    seg_length = max(2, int(np.random.normal(n/4, n/8)))\n    seg_length = min(seg_length, n-1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    if np.random.random() < 0.7:\n        reversed_segment = segment[::-1]\n        new_solution[start:start+seg_length] = reversed_segment\n\n    # Phase 2: Dynamic node insertion\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution)-1 else new_solution[0]\n\n            cost = (obj_weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    obj_weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    obj_weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Phase 3: Objective-aware edge swapping\n    for _ in range(3):\n        a, b = np.random.choice(range(len(new_solution)), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if (sum(new_costs) < sum(current_costs) or\n            (np.random.random() < 0.2 and any(nc < cc for nc, cc in zip(new_costs, current_costs)))):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm uses a multi-objective aware segment exchange strategy that adaptively selects and swaps segments between two randomly chosen solutions from the archive, prioritizing improvements in the least dominant objective while ensuring feasibility through careful segment validation and reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two random solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), size=2, replace=False)\n    sol1, obj1 = archive[idx1]\n    sol2, obj2 = archive[idx2]\n\n    # Identify the least dominant objective for each solution\n    least_dominant1 = np.argmax(obj1)\n    least_dominant2 = np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = sol1.copy()\n    new_solution[start1:start1+seg_length] = seg2\n\n    # Validate and repair the solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, try to repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Find best insertion position based on least dominant objective\n            best_pos = -1\n            min_cost = float('inf')\n            for i in range(n):\n                if new_solution[i] in seg2:\n                    continue\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n                if least_dominant1 == 0:\n                    cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                elif least_dominant1 == 1:\n                    cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                else:\n                    cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    [node],\n                    new_solution[best_pos:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.6414762897625579,
            1.9861053228378296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two random solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), size=2, replace=False)\n    sol1, obj1 = archive[idx1]\n    sol2, obj2 = archive[idx2]\n\n    # Identify the least dominant objective for each solution\n    least_dominant1 = np.argmax(obj1)\n    least_dominant2 = np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = sol1.copy()\n    new_solution[start1:start1+seg_length] = seg2\n\n    # Validate and repair the solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, try to repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Find best insertion position based on least dominant objective\n            best_pos = -1\n            min_cost = float('inf')\n            for i in range(n):\n                if new_solution[i] in seg2:\n                    continue\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n                if least_dominant1 == 0:\n                    cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                elif least_dominant1 == 1:\n                    cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                else:\n                    cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    [node],\n                    new_solution[best_pos:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted combination of normalized objective values, then applies a hybrid local search that combines 3-opt with a multi-objective displacement heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize and select solution with dynamic weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Dynamic weights based on current archive diversity\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective displacement\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different 3-opt configurations\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k:], new_solution[i:j][::-1], new_solution[j:k]]),\n    ]\n\n    best_candidate = None\n    best_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_candidate = candidate\n\n    if best_cost < sum(objectives[selected_idx]):\n        new_solution = best_candidate\n    else:\n        # Multi-objective displacement\n        node_to_displace = np.random.randint(0, n)\n        displaced_node = new_solution[node_to_displace]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_displace:\n                continue\n\n            prev_pos = (pos - 1) % n\n            next_pos = (pos + 1) % n\n\n            cost = (distance_matrix_1[new_solution[prev_pos], displaced_node] +\n                    distance_matrix_1[displaced_node, new_solution[next_pos]] -\n                    distance_matrix_1[new_solution[prev_pos], new_solution[next_pos]] +\n                    distance_matrix_2[new_solution[prev_pos], displaced_node] +\n                    distance_matrix_2[displaced_node, new_solution[next_pos]] -\n                    distance_matrix_2[new_solution[prev_pos], new_solution[next_pos]] +\n                    distance_matrix_3[new_solution[prev_pos], displaced_node] +\n                    distance_matrix_3[displaced_node, new_solution[next_pos]] -\n                    distance_matrix_3[new_solution[prev_pos], new_solution[next_pos]])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [displaced_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6414930343394636,
            1.7262929916381835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize and select solution with dynamic weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Dynamic weights based on current archive diversity\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective displacement\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different 3-opt configurations\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k:], new_solution[i:j][::-1], new_solution[j:k]]),\n    ]\n\n    best_candidate = None\n    best_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_candidate = candidate\n\n    if best_cost < sum(objectives[selected_idx]):\n        new_solution = best_candidate\n    else:\n        # Multi-objective displacement\n        node_to_displace = np.random.randint(0, n)\n        displaced_node = new_solution[node_to_displace]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_displace:\n                continue\n\n            prev_pos = (pos - 1) % n\n            next_pos = (pos + 1) % n\n\n            cost = (distance_matrix_1[new_solution[prev_pos], displaced_node] +\n                    distance_matrix_1[displaced_node, new_solution[next_pos]] -\n                    distance_matrix_1[new_solution[prev_pos], new_solution[next_pos]] +\n                    distance_matrix_2[new_solution[prev_pos], displaced_node] +\n                    distance_matrix_2[displaced_node, new_solution[next_pos]] -\n                    distance_matrix_2[new_solution[prev_pos], new_solution[next_pos]] +\n                    distance_matrix_3[new_solution[prev_pos], displaced_node] +\n                    distance_matrix_3[displaced_node, new_solution[next_pos]] -\n                    distance_matrix_3[new_solution[prev_pos], new_solution[next_pos]])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [displaced_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel objective diversity-aware selection strategy, then applies a hybrid local search that combines a multi-objective node chain reversal with an adaptive weighted insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node chain reversal with adaptive weighted insertion\n    n = len(new_solution)\n    chain_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - chain_length)\n\n    # Reverse the chain\n    chain = new_solution[start:start+chain_length]\n    reversed_chain = chain[::-1]\n    new_solution[start:start+chain_length] = reversed_chain\n\n    # Adaptive weighted insertion\n    weights = np.random.rand(3)\n    weights /= weights.sum()\n\n    for i in range(chain_length):\n        node = reversed_chain[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= start and pos < start + chain_length:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos != -1 and best_pos != start + i:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n            start = best_pos if best_pos < start else start\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6208066251222192,
            1.5633286118507386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node chain reversal with adaptive weighted insertion\n    n = len(new_solution)\n    chain_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - chain_length)\n\n    # Reverse the chain\n    chain = new_solution[start:start+chain_length]\n    reversed_chain = chain[::-1]\n    new_solution[start:start+chain_length] = reversed_chain\n\n    # Adaptive weighted insertion\n    weights = np.random.rand(3)\n    weights /= weights.sum()\n\n    for i in range(chain_length):\n        node = reversed_chain[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= start and pos < start + chain_length:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                    weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                    weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos != -1 and best_pos != start + i:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n            start = best_pos if best_pos < start else start\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4862404694182144,
            2.8279234528541566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (1 + diversity_scores), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    # Rotate segment\n    rotated_segment = np.roll(segment, np.random.randint(1, k))\n    new_solution[start:start+k] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.choice(new_solution)\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos >= start and pos < start + k:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] -\n                              distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] -\n                              distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] -\n                              distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if min_cost < 0:\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n        if len(new_solution) > n:\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6941743989128211,
            2.932728850841522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware performance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (1 + diversity_scores), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    # Rotate segment\n    rotated_segment = np.roll(segment, np.random.randint(1, k))\n    new_solution[start:start+k] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.choice(new_solution)\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos >= start and pos < start + k:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] -\n                              distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] -\n                              distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] -\n                              distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if min_cost < 0:\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n        if len(new_solution) > n:\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Perform a novel local search combining segment reversal and node relinking\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start = np.random.randint(0, n - seg_length)\n\n    # Reverse the selected segment\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Relink nodes to optimize the least dominant objective\n    for i in range(start, start + seg_length):\n        node = new_solution[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        # Find best position for the node in the remaining tour\n        for j in range(n):\n            if j >= start and j < start + seg_length:\n                continue\n\n            prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = j\n\n        if best_pos != -1:\n            # Remove the node and insert it at the best position\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+1:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.671364029911474,
            1.6690631628036499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Perform a novel local search combining segment reversal and node relinking\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start = np.random.randint(0, n - seg_length)\n\n    # Reverse the selected segment\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Relink nodes to optimize the least dominant objective\n    for i in range(start, start + seg_length):\n        node = new_solution[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        # Find best position for the node in the remaining tour\n        for j in range(n):\n            if j >= start and j < start + seg_length:\n                continue\n\n            prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = j\n\n        if best_pos != -1:\n            # Remove the node and insert it at the best position\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+1:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search: combine segment reversal with node swapping\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best swap between two random nodes in the reversed segment\n    swap_positions = np.random.choice(range(i, j+1), 2, replace=False)\n    a, b = swap_positions[0], swap_positions[1]\n\n    # Calculate cost difference for the swap\n    prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n    next_a = new_solution[a+1] if a < n-1 else new_solution[0]\n    prev_b = new_solution[b-1] if b > 0 else new_solution[-1]\n    next_b = new_solution[b+1] if b < n-1 else new_solution[0]\n\n    original_cost = (distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[a], next_a] +\n                     distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[a], next_a] +\n                     distance_matrix_3[prev_a, new_solution[a]] + distance_matrix_3[new_solution[a], next_a] +\n                     distance_matrix_1[prev_b, new_solution[b]] + distance_matrix_1[new_solution[b], next_b] +\n                     distance_matrix_2[prev_b, new_solution[b]] + distance_matrix_2[new_solution[b], next_b] +\n                     distance_matrix_3[prev_b, new_solution[b]] + distance_matrix_3[new_solution[b], next_b])\n\n    swapped_cost = (distance_matrix_1[prev_a, new_solution[b]] + distance_matrix_1[new_solution[b], next_a] +\n                   distance_matrix_2[prev_a, new_solution[b]] + distance_matrix_2[new_solution[b], next_a] +\n                   distance_matrix_3[prev_a, new_solution[b]] + distance_matrix_3[new_solution[b], next_a] +\n                   distance_matrix_1[prev_b, new_solution[a]] + distance_matrix_1[new_solution[a], next_b] +\n                   distance_matrix_2[prev_b, new_solution[a]] + distance_matrix_2[new_solution[a], next_b] +\n                   distance_matrix_3[prev_b, new_solution[a]] + distance_matrix_3[new_solution[a], next_b])\n\n    # Apply swap if it improves the total cost across all objectives\n    if swapped_cost < original_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.598988308758553,
            3.2885863900184633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search: combine segment reversal with node swapping\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best swap between two random nodes in the reversed segment\n    swap_positions = np.random.choice(range(i, j+1), 2, replace=False)\n    a, b = swap_positions[0], swap_positions[1]\n\n    # Calculate cost difference for the swap\n    prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n    next_a = new_solution[a+1] if a < n-1 else new_solution[0]\n    prev_b = new_solution[b-1] if b > 0 else new_solution[-1]\n    next_b = new_solution[b+1] if b < n-1 else new_solution[0]\n\n    original_cost = (distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[a], next_a] +\n                     distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[a], next_a] +\n                     distance_matrix_3[prev_a, new_solution[a]] + distance_matrix_3[new_solution[a], next_a] +\n                     distance_matrix_1[prev_b, new_solution[b]] + distance_matrix_1[new_solution[b], next_b] +\n                     distance_matrix_2[prev_b, new_solution[b]] + distance_matrix_2[new_solution[b], next_b] +\n                     distance_matrix_3[prev_b, new_solution[b]] + distance_matrix_3[new_solution[b], next_b])\n\n    swapped_cost = (distance_matrix_1[prev_a, new_solution[b]] + distance_matrix_1[new_solution[b], next_a] +\n                   distance_matrix_2[prev_a, new_solution[b]] + distance_matrix_2[new_solution[b], next_a] +\n                   distance_matrix_3[prev_a, new_solution[b]] + distance_matrix_3[new_solution[b], next_a] +\n                   distance_matrix_1[prev_b, new_solution[a]] + distance_matrix_1[new_solution[a], next_b] +\n                   distance_matrix_2[prev_b, new_solution[a]] + distance_matrix_2[new_solution[a], next_b] +\n                   distance_matrix_3[prev_b, new_solution[a]] + distance_matrix_3[new_solution[a], next_b])\n\n    # Apply swap if it improves the total cost across all objectives\n    if swapped_cost < original_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a novel objective diversity metric that considers both objective values and their distribution in the archive, then applies a hybrid local search combining a multi-objective segment insertion with a weighted edge swap heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * obj_range, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - seg_length)\n    while insert_pos >= start and insert_pos < start + seg_length:\n        insert_pos = np.random.randint(0, n - seg_length)\n\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        np.delete(new_solution, np.arange(start, start+seg_length))\n    ])\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        if cost < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) using adaptive objective weights and non-linear improvement potential to balance exploration and exploitation across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj ** 2\n    weights = np.array([0.5, 0.3, 0.2])\n    scores = (improvement_potential * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novelty-aware objective balance metric that considers both the objective values and their variance in the archive, then applies a multi-phase local search combining a weighted node relocation, a dominance-preserving edge swap, and a probabilistic segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    obj_mean = np.mean(objectives, axis=0)\n    obj_variance = np.var(objectives, axis=0)\n    novelty_scores = np.sum((objectives - obj_mean) ** 2 / (obj_variance + 1e-10), axis=1)\n    selected_idx = np.argmax(novelty_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    weights = np.random.dirichlet([1.0, 0.8, 0.6])\n\n    # Weighted node relocation\n    node_to_move = np.random.randint(0, n)\n    best_pos = node_to_move\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_move or pos == (node_to_move - 1) % n or pos == (node_to_move + 1) % n:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, new_solution[node_to_move]] + distance_matrix_1[new_solution[node_to_move], next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, new_solution[node_to_move]] + distance_matrix_2[new_solution[node_to_move], next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, new_solution[node_to_move]] + distance_matrix_3[new_solution[node_to_move], next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if best_pos != node_to_move:\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([\n            new_solution[:node_to_move],\n            new_solution[node_to_move+1:],\n            [node]\n        ])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dominance-preserving edge swap\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        cost1 = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]))\n\n        cost2 = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]))\n\n        if cost2 < cost1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment reversal\n    if np.random.rand() < 0.4:\n        seg_length = np.random.randint(2, min(4, n//2))\n        start = np.random.randint(0, n - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6958329624356002,
            1.8763978362083436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    obj_mean = np.mean(objectives, axis=0)\n    obj_variance = np.var(objectives, axis=0)\n    novelty_scores = np.sum((objectives - obj_mean) ** 2 / (obj_variance + 1e-10), axis=1)\n    selected_idx = np.argmax(novelty_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    weights = np.random.dirichlet([1.0, 0.8, 0.6])\n\n    # Weighted node relocation\n    node_to_move = np.random.randint(0, n)\n    best_pos = node_to_move\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_move or pos == (node_to_move - 1) % n or pos == (node_to_move + 1) % n:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, new_solution[node_to_move]] + distance_matrix_1[new_solution[node_to_move], next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, new_solution[node_to_move]] + distance_matrix_2[new_solution[node_to_move], next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, new_solution[node_to_move]] + distance_matrix_3[new_solution[node_to_move], next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if best_pos != node_to_move:\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([\n            new_solution[:node_to_move],\n            new_solution[node_to_move+1:],\n            [node]\n        ])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dominance-preserving edge swap\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        cost1 = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]))\n\n        cost2 = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]))\n\n        if cost2 < cost1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment reversal\n    if np.random.rand() < 0.4:\n        seg_length = np.random.randint(2, min(4, n//2))\n        start = np.random.randint(0, n - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and insertion heuristic\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find best insertion point for the first node of the reversed segment\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node] +\n                distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node] +\n                distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    # Create new solution with the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (diversity) and lowest objective sum\n    objectives = np.array([obj for _, obj in archive])\n    objective_sum = objectives.sum(axis=1)\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    selection_scores = crowding_distances - 0.5 * objective_sum\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt and relocation heuristic for multi-objective optimization\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move (reverse segments between i-j, j-k, and k-i)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Find best relocation for a randomly selected segment\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    best_pos = start_pos\n    min_cost = float('inf')\n\n    for pos in range(n - segment_length + 1):\n        if pos == start_pos:\n            continue\n\n        # Calculate cost for each objective space\n        cost1 = 0\n        cost2 = 0\n        cost3 = 0\n\n        # Original segment connections\n        if start_pos > 0:\n            prev_node = new_solution[start_pos-1]\n            cost1 += distance_matrix_1[prev_node, new_solution[start_pos]]\n            cost2 += distance_matrix_2[prev_node, new_solution[start_pos]]\n            cost3 += distance_matrix_3[prev_node, new_solution[start_pos]]\n        if start_pos + segment_length < n:\n            next_node = new_solution[start_pos + segment_length]\n            cost1 += distance_matrix_1[new_solution[start_pos + segment_length - 1], next_node]\n            cost2 += distance_matrix_2[new_solution[start_pos + segment_length - 1], next_node]\n            cost3 += distance_matrix_3[new_solution[start_pos + segment_length - 1], next_node]\n\n        # New segment connections\n        if pos > 0:\n            prev_node = new_solution[pos-1]\n            cost1 -= distance_matrix_1[prev_node, segment[0]]\n            cost2 -= distance_matrix_2[prev_node, segment[0]]\n            cost3 -= distance_matrix_3[prev_node, segment[0]]\n        if pos + segment_length < n:\n            next_node = new_solution[pos + segment_length] if pos + segment_length < n else new_solution[0]\n            cost1 -= distance_matrix_1[segment[-1], next_node]\n            cost2 -= distance_matrix_2[segment[-1], next_node]\n            cost3 -= distance_matrix_3[segment[-1], next_node]\n\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Create new solution with the best relocation\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        segment,\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6219835498803784,
            2.9101177215576173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (diversity) and lowest objective sum\n    objectives = np.array([obj for _, obj in archive])\n    objective_sum = objectives.sum(axis=1)\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    selection_scores = crowding_distances - 0.5 * objective_sum\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt and relocation heuristic for multi-objective optimization\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move (reverse segments between i-j, j-k, and k-i)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Find best relocation for a randomly selected segment\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    best_pos = start_pos\n    min_cost = float('inf')\n\n    for pos in range(n - segment_length + 1):\n        if pos == start_pos:\n            continue\n\n        # Calculate cost for each objective space\n        cost1 = 0\n        cost2 = 0\n        cost3 = 0\n\n        # Original segment connections\n        if start_pos > 0:\n            prev_node = new_solution[start_pos-1]\n            cost1 += distance_matrix_1[prev_node, new_solution[start_pos]]\n            cost2 += distance_matrix_2[prev_node, new_solution[start_pos]]\n            cost3 += distance_matrix_3[prev_node, new_solution[start_pos]]\n        if start_pos + segment_length < n:\n            next_node = new_solution[start_pos + segment_length]\n            cost1 += distance_matrix_1[new_solution[start_pos + segment_length - 1], next_node]\n            cost2 += distance_matrix_2[new_solution[start_pos + segment_length - 1], next_node]\n            cost3 += distance_matrix_3[new_solution[start_pos + segment_length - 1], next_node]\n\n        # New segment connections\n        if pos > 0:\n            prev_node = new_solution[pos-1]\n            cost1 -= distance_matrix_1[prev_node, segment[0]]\n            cost2 -= distance_matrix_2[prev_node, segment[0]]\n            cost3 -= distance_matrix_3[prev_node, segment[0]]\n        if pos + segment_length < n:\n            next_node = new_solution[pos + segment_length] if pos + segment_length < n else new_solution[0]\n            cost1 -= distance_matrix_1[segment[-1], next_node]\n            cost2 -= distance_matrix_2[segment[-1], next_node]\n            cost3 -= distance_matrix_3[segment[-1], next_node]\n\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Create new solution with the best relocation\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        segment,\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a novel objective diversity metric that considers both objective values and their distribution in the archive, then applies a hybrid local search combining a multi-objective segment insertion with a weighted edge swap heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * obj_range, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - seg_length)\n    while insert_pos >= start and insert_pos < start + seg_length:\n        insert_pos = np.random.randint(0, n - seg_length)\n\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        np.delete(new_solution, np.arange(start, start+seg_length))\n    ])\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        if cost < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel objective balance metric that considers the normalized deviation of each objective from the archive's mean, then applies a hybrid local search combining a multi-objective segment reversal with a Pareto-optimal edge swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective balance\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    balance_scores = np.sum(np.abs((objectives - mean_obj) / (std_obj + 1e-10)), axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with Pareto-optimal edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_segment = np.flip(segment)\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_segment,\n        new_solution[start+seg_length:]\n    ])\n\n    # Pareto-optimal edge swap\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        old_costs = [\n            distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]],\n            distance_matrix_2[old_edges[2][0], old_edges[2][1]] + distance_matrix_2[old_edges[3][0], old_edges[3][1]],\n            distance_matrix_3[old_edges[0][0], old_edges[0][1]] + distance_matrix_3[old_edges[1][0], old_edges[1][1]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_2[new_edges[2][0], new_edges[2][1]] + distance_matrix_2[new_edges[3][0], new_edges[3][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n        ]\n\n        if all(new_cost <= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6155256566531561,
            3.311613142490387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective balance\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n    balance_scores = np.sum(np.abs((objectives - mean_obj) / (std_obj + 1e-10)), axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with Pareto-optimal edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_segment = np.flip(segment)\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_segment,\n        new_solution[start+seg_length:]\n    ])\n\n    # Pareto-optimal edge swap\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        old_costs = [\n            distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]],\n            distance_matrix_2[old_edges[2][0], old_edges[2][1]] + distance_matrix_2[old_edges[3][0], old_edges[3][1]],\n            distance_matrix_3[old_edges[0][0], old_edges[0][1]] + distance_matrix_3[old_edges[1][0], old_edges[1][1]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_2[new_edges[2][0], new_edges[2][1]] + distance_matrix_2[new_edges[3][0], new_edges[3][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n        ]\n\n        if all(new_cost <= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective performance, then applies a hybrid local search that combines 3-opt with a multi-objective swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different 3-opt configurations\n    configs = [\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:b], new_solution[a:b][::-1], new_solution[c:], new_solution[b:c][::-1]])\n    ]\n\n    # Evaluate all configurations\n    best_config = new_solution\n    min_cost = float('inf')\n\n    for config in configs:\n        total_cost = 0\n        for k in range(n):\n            prev = config[k-1]\n            curr = config[k]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_config = config\n\n    new_solution = best_config\n\n    # If no improvement, try multi-objective swap\n    if min_cost >= sum(objectives[selected_idx]):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Evaluate swap cost\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        cost = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n                distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n        if cost >= sum(objectives[selected_idx]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7335353727455775,
            1.1512895703315735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different 3-opt configurations\n    configs = [\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:b], new_solution[a:b][::-1], new_solution[c:], new_solution[b:c][::-1]])\n    ]\n\n    # Evaluate all configurations\n    best_config = new_solution\n    min_cost = float('inf')\n\n    for config in configs:\n        total_cost = 0\n        for k in range(n):\n            prev = config[k-1]\n            curr = config[k]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_config = config\n\n    new_solution = best_config\n\n    # If no improvement, try multi-objective swap\n    if min_cost >= sum(objectives[selected_idx]):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Evaluate swap cost\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        cost = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j] +\n                distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n        if cost >= sum(objectives[selected_idx]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novelty-aware selection strategy that prioritizes solutions with high objective diversity, then applies a hybrid local search that combines a multi-objective-aware insertion heuristic with a dynamic segment rotation operator to generate a neighbor solution while ensuring feasibility and exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            current_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n            new_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n                distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n                distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n            ]\n\n            if sum(new_costs) < sum(current_costs) + np.random.normal(0, 0.1):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7728310638260497,
            2.7381707549095156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            current_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n            new_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n                distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n                distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n            ]\n\n            if sum(new_costs) < sum(current_costs) + np.random.normal(0, 0.1):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a hybrid local search that combines a novel multi-objective edge insertion heuristic with a weighted segment rotation operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-10), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge insertion with weighted segment rotation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Weighted segment rotation\n    rotation_dir = np.random.choice([-1, 1])\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, rotation_dir)\n    new_solution[i:j+1] = rotated_segment\n\n    # Edge insertion heuristic\n    a, b = np.random.choice(range(n), 2, replace=False)\n    if a != b:\n        # Calculate multi-objective cost\n        cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]) * 0.5 + \\\n               (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]) * 0.3 + \\\n               (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]) * 0.2\n\n        if cost < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6070352466860536,
            2.92218416929245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-10), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge insertion with weighted segment rotation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Weighted segment rotation\n    rotation_dir = np.random.choice([-1, 1])\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, rotation_dir)\n    new_solution[i:j+1] = rotated_segment\n\n    # Edge insertion heuristic\n    a, b = np.random.choice(range(n), 2, replace=False)\n    if a != b:\n        # Calculate multi-objective cost\n        cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]) * 0.5 + \\\n               (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]) * 0.3 + \\\n               (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]) * 0.2\n\n        if cost < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective Pareto front proximity measure, then applies a hybrid local search that combines a novel adaptive segment rotation with a dominance-aware node swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.min(objectives, axis=0)\n    distances = np.linalg.norm(objectives - pareto_front, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment rotation with dominance-aware node swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n\n    # Rotate segment\n    segment = new_solution[start:start+seg_length]\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Dominance-aware node swap\n    for _ in range(3):\n        node_a, node_b = np.random.choice(range(n), 2, replace=False)\n        if node_a == node_b:\n            continue\n\n        # Calculate dominance before swap\n        prev_a = new_solution[node_a-1] if node_a > 0 else new_solution[-1]\n        next_a = new_solution[node_a+1] if node_a < n-1 else new_solution[0]\n        prev_b = new_solution[node_b-1] if node_b > 0 else new_solution[-1]\n        next_b = new_solution[node_b+1] if node_b < n-1 else new_solution[0]\n\n        old_costs = [\n            distance_matrix_1[prev_a, new_solution[node_a]] + distance_matrix_1[new_solution[node_a], next_a],\n            distance_matrix_2[prev_a, new_solution[node_a]] + distance_matrix_2[new_solution[node_a], next_a],\n            distance_matrix_3[prev_a, new_solution[node_a]] + distance_matrix_3[new_solution[node_a], next_a]\n        ]\n\n        # Calculate dominance after swap\n        new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n        new_costs = [\n            distance_matrix_1[prev_a, new_solution[node_a]] + distance_matrix_1[new_solution[node_a], next_a],\n            distance_matrix_2[prev_a, new_solution[node_a]] + distance_matrix_2[new_solution[node_a], next_a],\n            distance_matrix_3[prev_a, new_solution[node_a]] + distance_matrix_3[new_solution[node_a], next_a]\n        ]\n        new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n        # Accept if improves at least one objective without worsening others\n        if (any(nc < oc for nc, oc in zip(new_costs, old_costs)) and\n            not any(nc > oc for nc, oc in zip(new_costs, old_costs))):\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6305099331613856,
            3.4907805562019347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.min(objectives, axis=0)\n    distances = np.linalg.norm(objectives - pareto_front, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment rotation with dominance-aware node swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n\n    # Rotate segment\n    segment = new_solution[start:start+seg_length]\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Dominance-aware node swap\n    for _ in range(3):\n        node_a, node_b = np.random.choice(range(n), 2, replace=False)\n        if node_a == node_b:\n            continue\n\n        # Calculate dominance before swap\n        prev_a = new_solution[node_a-1] if node_a > 0 else new_solution[-1]\n        next_a = new_solution[node_a+1] if node_a < n-1 else new_solution[0]\n        prev_b = new_solution[node_b-1] if node_b > 0 else new_solution[-1]\n        next_b = new_solution[node_b+1] if node_b < n-1 else new_solution[0]\n\n        old_costs = [\n            distance_matrix_1[prev_a, new_solution[node_a]] + distance_matrix_1[new_solution[node_a], next_a],\n            distance_matrix_2[prev_a, new_solution[node_a]] + distance_matrix_2[new_solution[node_a], next_a],\n            distance_matrix_3[prev_a, new_solution[node_a]] + distance_matrix_3[new_solution[node_a], next_a]\n        ]\n\n        # Calculate dominance after swap\n        new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n        new_costs = [\n            distance_matrix_1[prev_a, new_solution[node_a]] + distance_matrix_1[new_solution[node_a], next_a],\n            distance_matrix_2[prev_a, new_solution[node_a]] + distance_matrix_2[new_solution[node_a], next_a],\n            distance_matrix_3[prev_a, new_solution[node_a]] + distance_matrix_3[new_solution[node_a], next_a]\n        ]\n        new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n        # Accept if improves at least one objective without worsening others\n        if (any(nc < oc for nc, oc in zip(new_costs, old_costs)) and\n            not any(nc > oc for nc, oc in zip(new_costs, old_costs))):\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a novel objective diversity metric that considers both objective values and their distribution in the archive, then applies a hybrid local search combining a multi-objective segment insertion with a weighted edge swap heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * obj_range, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted edge swap\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - seg_length)\n    while insert_pos >= start and insert_pos < start + seg_length:\n        insert_pos = np.random.randint(0, n - seg_length)\n\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        np.delete(new_solution, np.arange(start, start+seg_length))\n    ])\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == j or (i >= start and i < start+seg_length) or (j >= start and j < start+seg_length):\n            continue\n\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        if cost < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel multi-objective balance metric that considers both objective values and their trade-off relationships, then applies a hybrid local search combining a weighted node block relocation with a multi-objective edge reversal heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest multi-objective balance\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    balance_scores = np.sum((objectives - np.mean(objectives, axis=0))**2 / (obj_range + 1e-10), axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted node block relocation with multi-objective edge reversal\n    n = len(new_solution)\n    block_size = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - block_size)\n    block = new_solution[start_pos:start_pos+block_size]\n\n    # Relocate block to a new position\n    insert_pos = np.random.randint(0, n - block_size)\n    while insert_pos >= start_pos and insert_pos < start_pos + block_size:\n        insert_pos = np.random.randint(0, n - block_size)\n\n    new_solution = np.concatenate([\n        new_solution[:start_pos],\n        new_solution[start_pos+block_size:],\n        block\n    ])\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        block,\n        new_solution[insert_pos:]\n    ])\n\n    # Multi-objective edge reversal\n    weights = np.random.rand(3)\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or abs(i - j) < 2:\n            continue\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost for all three objectives\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j+1]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j+1]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[j+1]]))\n\n        if cost < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7341872422541702,
            0.9216205239295959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest multi-objective balance\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    balance_scores = np.sum((objectives - np.mean(objectives, axis=0))**2 / (obj_range + 1e-10), axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted node block relocation with multi-objective edge reversal\n    n = len(new_solution)\n    block_size = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - block_size)\n    block = new_solution[start_pos:start_pos+block_size]\n\n    # Relocate block to a new position\n    insert_pos = np.random.randint(0, n - block_size)\n    while insert_pos >= start_pos and insert_pos < start_pos + block_size:\n        insert_pos = np.random.randint(0, n - block_size)\n\n    new_solution = np.concatenate([\n        new_solution[:start_pos],\n        new_solution[start_pos+block_size:],\n        block\n    ])\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        block,\n        new_solution[insert_pos:]\n    ])\n\n    # Multi-objective edge reversal\n    weights = np.random.rand(3)\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or abs(i - j) < 2:\n            continue\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost for all three objectives\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j+1]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j+1]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[j+1]]))\n\n        if cost < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This new algorithm selects a solution from the archive based on the diversity of its objective values, then applies a hybrid local search that combines 3-opt with a multi-objective swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_config = None\n    best_cost = float('inf')\n\n    for config in configurations:\n        total_cost = 0\n        for l in range(n):\n            prev = config[l-1]\n            curr = config[l]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_config = config\n\n    if best_config is not None:\n        new_solution = best_config.copy()\n    else:\n        # Multi-objective swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4937788680945485,
            3.0596557021141053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try different 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_config = None\n    best_cost = float('inf')\n\n    for config in configurations:\n        total_cost = 0\n        for l in range(n):\n            prev = config[l-1]\n            curr = config[l]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_config = config\n\n    if best_config is not None:\n        new_solution = best_config.copy()\n    else:\n        # Multi-objective swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143598294159826,
            0.6853143692016601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that balances improvement potential across all three objectives, then applies a hybrid local search that combines 3-opt with a multi-objective edge insertion heuristic to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt configurations\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_candidate = None\n    min_total_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n    else:\n        # Multi-objective edge insertion\n        edge_to_remove = np.random.choice(n)\n        node_a = new_solution[edge_to_remove-1]\n        node_b = new_solution[edge_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == edge_to_remove or pos == (edge_to_remove-1) % n:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, node_a] + distance_matrix_1[node_a, node_b] + distance_matrix_1[node_b, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, node_a] + distance_matrix_2[node_a, node_b] + distance_matrix_2[node_b, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, node_a] + distance_matrix_3[node_a, node_b] + distance_matrix_3[node_b, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [node_a, node_b],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6510882020078169,
            3.024270975589752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt configurations\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    best_candidate = None\n    min_total_cost = float('inf')\n\n    for candidate in candidates:\n        total_cost = 0\n        for m in range(n):\n            prev = candidate[m-1]\n            curr = candidate[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n    else:\n        # Multi-objective edge insertion\n        edge_to_remove = np.random.choice(n)\n        node_a = new_solution[edge_to_remove-1]\n        node_b = new_solution[edge_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == edge_to_remove or pos == (edge_to_remove-1) % n:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, node_a] + distance_matrix_1[node_a, node_b] + distance_matrix_1[node_b, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, node_a] + distance_matrix_2[node_a, node_b] + distance_matrix_2[node_b, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, node_a] + distance_matrix_3[node_a, node_b] + distance_matrix_3[node_b, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [node_a, node_b],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(5):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7552928417060905,
            3.149601364135742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(5):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6841760525677987,
            0.6360628724098205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6841760525677987,
            0.6360628724098205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search that combines 2-opt with a multi-objective insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(3)\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segment and evaluate\n    reversed_segment = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    # Evaluate cost for all three objectives\n    total_cost = 0\n    for k in range(n):\n        prev = reversed_segment[k-1]\n        curr = reversed_segment[k]\n        total_cost += (distance_matrix_1[prev, curr] +\n                       distance_matrix_2[prev, curr] +\n                       distance_matrix_3[prev, curr])\n\n    # If improvement, accept; otherwise try insertion\n    if total_cost < sum(objectives[selected_idx]):\n        new_solution = reversed_segment\n    else:\n        # Multi-objective insertion\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and adaptive weighted combination of objective values, then applies a hybrid local search that combines 3-opt with a multi-objective edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best adaptive weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(normalized_objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Generate 3-opt variations\n    variations = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    # Evaluate all variations\n    best_variation = new_solution\n    min_cost = float('inf')\n\n    for var in variations:\n        total_cost = 0\n        for m in range(n):\n            prev = var[m-1]\n            curr = var[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_variation = var\n\n    new_solution = best_variation.copy()\n\n    # If no improvement, try edge insertion\n    if np.array_equal(new_solution, base_solution):\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7163442808887606,
            1.5312414169311523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best adaptive weighted objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(normalized_objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Generate 3-opt variations\n    variations = [\n        np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]])\n    ]\n\n    # Evaluate all variations\n    best_variation = new_solution\n    min_cost = float('inf')\n\n    for var in variations:\n        total_cost = 0\n        for m in range(n):\n            prev = var[m-1]\n            curr = var[m]\n            total_cost += (distance_matrix_1[prev, curr] +\n                          distance_matrix_2[prev, curr] +\n                          distance_matrix_3[prev, curr])\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_variation = var\n\n    new_solution = best_variation.copy()\n\n    # If no improvement, try edge insertion\n    if np.array_equal(new_solution, base_solution):\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_remove:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node] +\n                    distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node] +\n                    distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier aware selection strategy, then applies a hybrid local search that combines a novel multi-objective edge insertion with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best Pareto-frontier diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.sum(np.all(objectives[:, None, :] <= objectives, axis=2), axis=1)\n    selected_idx = np.argmax(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge insertion with weighted node insertion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Perform edge insertion\n    if i != j:\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if node != pos:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[pos]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[pos]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[pos]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[pos]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node]] + distance_matrix_3[new_solution[node], new_solution[pos]] -\n                distance_matrix_3[new_solution[pos-1], new_solution[pos]]))\n\n        if cost < 0:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7506001803047999,
            2.3011289119720457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best Pareto-frontier diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.sum(np.all(objectives[:, None, :] <= objectives, axis=2), axis=1)\n    selected_idx = np.argmax(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge insertion with weighted node insertion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Perform edge insertion\n    if i != j:\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if node != pos:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[pos]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[pos]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[pos]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[pos]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node]] + distance_matrix_3[new_solution[node], new_solution[pos]] -\n                distance_matrix_3[new_solution[pos-1], new_solution[pos]]))\n\n        if cost < 0:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment inversion with a weighted node relocation heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_idx, i]\n\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives_sorted[j+1] - objectives_sorted[j-1]) / (objectives_sorted[-1] - objectives_sorted[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment inversion with weighted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node relocation\n    weights = np.random.rand(3)\n    node_to_relocate = np.random.randint(0, n)\n    removed_node = new_solution[node_to_relocate]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_relocate:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.650134236828578,
            2.9477084398269655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_idx, i]\n\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives_sorted[j+1] - objectives_sorted[j-1]) / (objectives_sorted[-1] - objectives_sorted[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment inversion with weighted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node relocation\n    weights = np.random.rand(3)\n    node_to_relocate = np.random.randint(0, n)\n    removed_node = new_solution[node_to_relocate]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_relocate:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid algorithm that combines multi-objective dominance scoring with a three-phase local search (2-opt, insertion, and node swap) to intelligently explore the solution space while maintaining feasibility across all objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = 1 - normalized_obj\n    scores = improvement_potential.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Best insertion with multi-objective cost\n    removed_node = new_solution[i]\n    best_pos = i\n    min_cost = float('inf')\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n        next_node = new_solution[k] if k < n-1 else new_solution[0]\n\n        cost = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) * 0.5 + \\\n               (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) * 0.3 + \\\n               (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]) * 0.2\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = k\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Phase 3: Node swap with objective diversity\n    if np.random.rand() < 0.3:\n        swap_positions = np.random.choice(n, 2, replace=False)\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = \\\n            new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933550602033838,
            1.7132596492767334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8067558780615164,
            3.270241045951843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance count and diversity, then applies a hybrid local search combining 2-opt and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7458494812559454,
            3.456210219860077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This new algorithm employs a multi-objective adaptive path segmentation and reconfiguration strategy that dynamically selects and reconfigures segments based on objective performance, followed by a targeted node insertion that prioritizes improvement in the most balanced objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most balanced objective for this solution\n    balanced_obj = objectives[selected_idx]\n    most_balanced = np.argmin(np.abs(balanced_obj - np.mean(balanced_obj)))\n\n    # Adaptive path segmentation and reconfiguration\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Reconfigure segment with probability based on objective balance\n    if np.random.random() < 0.6 * (1 - np.std(balanced_obj) / np.max(balanced_obj)):\n        # Circular shift the segment\n        shift = np.random.randint(1, seg_length)\n        new_segment = np.roll(segment, shift)\n        new_solution[start:start+seg_length] = new_segment\n\n    # Targeted node insertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_balanced == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_balanced == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7286927539821446,
            1.9565234899520874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most balanced objective for this solution\n    balanced_obj = objectives[selected_idx]\n    most_balanced = np.argmin(np.abs(balanced_obj - np.mean(balanced_obj)))\n\n    # Adaptive path segmentation and reconfiguration\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Reconfigure segment with probability based on objective balance\n    if np.random.random() < 0.6 * (1 - np.std(balanced_obj) / np.max(balanced_obj)):\n        # Circular shift the segment\n        shift = np.random.randint(1, seg_length)\n        new_segment = np.roll(segment, shift)\n        new_solution[start:start+seg_length] = new_segment\n\n    # Targeted node insertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_balanced == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_balanced == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm employs a multi-objective adaptive path relinking strategy that dynamically selects and combines segments from different solutions based on objective performance, followed by a dominance-aware edge insertion that prioritizes improvement in the least dominated objective while maintaining feasibility through careful edge selection and dominance-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive path relinking with segment combination\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    # Select another solution from archive for segment exchange\n    other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0]\n\n    # Find similar segment in other solution\n    for i in range(len(other_solution) - seg_length + 1):\n        if np.array_equal(base_solution[start:start+seg_length], other_solution[i:i+seg_length]):\n            new_solution[start:start+seg_length] = other_solution[i:i+seg_length]\n            break\n\n    # Dominance-aware edge insertion\n    removed_edge = np.random.choice(range(n))\n    candidate_edges = []\n\n    for i in range(n):\n        if i == removed_edge or i == (removed_edge + 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n        removed_node = new_solution[removed_edge]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_edges.append((cost, i))\n\n    if candidate_edges:\n        candidate_edges.sort()\n        best_pos = candidate_edges[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_edge]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7768714526782245,
            1.8677146911621094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive path relinking with segment combination\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    # Select another solution from archive for segment exchange\n    other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0]\n\n    # Find similar segment in other solution\n    for i in range(len(other_solution) - seg_length + 1):\n        if np.array_equal(base_solution[start:start+seg_length], other_solution[i:i+seg_length]):\n            new_solution[start:start+seg_length] = other_solution[i:i+seg_length]\n            break\n\n    # Dominance-aware edge insertion\n    removed_edge = np.random.choice(range(n))\n    candidate_edges = []\n\n    for i in range(n):\n        if i == removed_edge or i == (removed_edge + 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n        removed_node = new_solution[removed_edge]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_edges.append((cost, i))\n\n    if candidate_edges:\n        candidate_edges.sort()\n        best_pos = candidate_edges[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_edge]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt with distance-based swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate distance savings across all objectives\n    def calculate_savings(a, b, c, d):\n        savings = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            savings += (dm[a, b] + dm[c, d]) - (dm[a, c] + dm[b, d])\n        return savings\n\n    a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n    if calculate_savings(a, b, c, d) > 0:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Dynamic segment rotation based on objective balance\n    k = np.random.randint(1, n)\n    new_solution = np.roll(new_solution, k)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5622649321403193,
            3.512642872333527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt with distance-based swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate distance savings across all objectives\n    def calculate_savings(a, b, c, d):\n        savings = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            savings += (dm[a, b] + dm[c, d]) - (dm[a, c] + dm[b, d])\n        return savings\n\n    a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n    if calculate_savings(a, b, c, d) > 0:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Dynamic segment rotation based on objective balance\n    k = np.random.randint(1, n)\n    new_solution = np.roll(new_solution, k)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This algorithm employs a novel adaptive cluster-based local search that dynamically partitions the tour into clusters based on spatial proximity in all three objective spaces, then applies a hybrid of cluster rotation and node swapping to improve the least dominant objective while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Dynamic cluster formation based on spatial proximity in all objectives\n    n = len(new_solution)\n    cluster_size = max(3, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Select a random cluster and rotate it\n    selected_cluster_idx = np.random.randint(len(clusters))\n    selected_cluster = clusters[selected_cluster_idx]\n    rotated_cluster = np.roll(selected_cluster, 1)\n\n    # Replace the cluster in the solution\n    start_idx = selected_cluster_idx * cluster_size\n    end_idx = min(start_idx + cluster_size, n)\n    new_solution[start_idx:end_idx] = rotated_cluster\n\n    # Perform node swapping optimization for the least dominant objective\n    for _ in range(2):  # Perform multiple swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for the least dominant objective\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost_change = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                          distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                         (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n        elif least_dominant == 1:\n            cost_change = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                          distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                         (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                          distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n        else:\n            cost_change = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                          distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                         (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                          distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n        if cost_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5588313396310082,
            3.2402191758155823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Dynamic cluster formation based on spatial proximity in all objectives\n    n = len(new_solution)\n    cluster_size = max(3, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Select a random cluster and rotate it\n    selected_cluster_idx = np.random.randint(len(clusters))\n    selected_cluster = clusters[selected_cluster_idx]\n    rotated_cluster = np.roll(selected_cluster, 1)\n\n    # Replace the cluster in the solution\n    start_idx = selected_cluster_idx * cluster_size\n    end_idx = min(start_idx + cluster_size, n)\n    new_solution[start_idx:end_idx] = rotated_cluster\n\n    # Perform node swapping optimization for the least dominant objective\n    for _ in range(2):  # Perform multiple swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for the least dominant objective\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost_change = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                          distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                         (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n        elif least_dominant == 1:\n            cost_change = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                          distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                         (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                          distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n        else:\n            cost_change = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                          distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                         (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                          distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n        if cost_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel adaptive segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal, node reinsertion, and objective-specific segment length adaptation based on Pareto front proximity and objective correlation analysis.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlations\n    obj_corr = np.corrcoef(objectives.T)\n    avg_corr = np.mean(np.abs(obj_corr[np.triu_indices(3, 1)]))\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment length based on objective correlation\n    n = len(new_solution)\n    if avg_corr > 0.7:\n        seg_length = np.random.randint(3, min(9, n//2))\n    else:\n        seg_length = np.random.randint(2, min(5, n//3))\n\n    # Select a random segment and reverse it\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Additional local search: swap nodes based on objective correlations\n    if avg_corr > 0.5 and np.random.random() < 0.3:\n        swap_pos1 = np.random.randint(0, n)\n        swap_pos2 = np.random.randint(0, n)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6328594624297202,
            2.019034767150879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlations\n    obj_corr = np.corrcoef(objectives.T)\n    avg_corr = np.mean(np.abs(obj_corr[np.triu_indices(3, 1)]))\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment length based on objective correlation\n    n = len(new_solution)\n    if avg_corr > 0.7:\n        seg_length = np.random.randint(3, min(9, n//2))\n    else:\n        seg_length = np.random.randint(2, min(5, n//3))\n\n    # Select a random segment and reverse it\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Additional local search: swap nodes based on objective correlations\n    if avg_corr > 0.5 and np.random.random() < 0.3:\n        swap_pos1 = np.random.randint(0, n)\n        swap_pos2 = np.random.randint(0, n)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and dominance, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node insertion, ensuring feasibility while exploring diverse trade-offs across all three objectives by prioritizing the least improved objective and using a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n\n    # Select solution with highest diversity in objectives\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Identify the least improved objective\n    current_obj = objectives[selected_idx]\n    avg_obj = np.mean(objectives, axis=0)\n    least_improved = np.argmax(avg_obj - current_obj)\n\n    # Insert a node to optimize the least improved objective\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        if least_improved == 0:\n            cost = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_improved == 1:\n            cost = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if best_pos != -1 and (min_cost < 0 or np.random.random() < 0.3):\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5556060524757381,
            3.9462126016616823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n\n    # Select solution with highest diversity in objectives\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Identify the least improved objective\n    current_obj = objectives[selected_idx]\n    avg_obj = np.mean(objectives, axis=0)\n    least_improved = np.argmax(avg_obj - current_obj)\n\n    # Insert a node to optimize the least improved objective\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        if least_improved == 0:\n            cost = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_improved == 1:\n            cost = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    if best_pos != -1 and (min_cost < 0 or np.random.random() < 0.3):\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a solution from the archive based on its spread across objectives, applies a hybrid local search combining segment reversal with adaptive node reinsertion, and prioritizes improvement in the most underperforming objective while ensuring feasibility through dominance-aware segment selection and objective-specific cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest spread (max range of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most underperforming objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_underperforming = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the middle node of the reversed segment to optimize the most underperforming objective\n    removed_node = reversed_segment[len(reversed_segment)//2]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_underperforming == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_underperforming == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7452180264928494,
            0.9742550730705262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest spread (max range of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most underperforming objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_underperforming = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the middle node of the reversed segment to optimize the most underperforming objective\n    removed_node = reversed_segment[len(reversed_segment)//2]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_underperforming == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_underperforming == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective selection, then applies a hybrid local search that combines a novel multi-objective 2-opt* move with a weighted edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        min_obj, max_obj = objectives[sorted_idx[0], m], objectives[sorted_idx[-1], m]\n        if max_obj == min_obj:\n            continue\n        crowding_distances[sorted_idx[1:-1]] += (objectives[sorted_idx[2:], m] - objectives[sorted_idx[:-2], m]) / (max_obj - min_obj)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt* with weighted edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt* move\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    edge_a = new_solution[a]\n    edge_b = new_solution[b]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == a or pos == b:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, edge_a] + distance_matrix_1[edge_b, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, edge_a] + distance_matrix_2[edge_b, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, edge_a] + distance_matrix_3[edge_b, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [edge_a, edge_b],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6902706308079212,
            1.5444681882858275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        min_obj, max_obj = objectives[sorted_idx[0], m], objectives[sorted_idx[-1], m]\n        if max_obj == min_obj:\n            continue\n        crowding_distances[sorted_idx[1:-1]] += (objectives[sorted_idx[2:], m] - objectives[sorted_idx[:-2], m]) / (max_obj - min_obj)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt* with weighted edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt* move\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n    # Weighted edge insertion\n    weights = np.random.rand(3)\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    edge_a = new_solution[a]\n    edge_b = new_solution[b]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == a or pos == b:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, edge_a] + distance_matrix_1[edge_b, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, edge_a] + distance_matrix_2[edge_b, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, edge_a] + distance_matrix_3[edge_b, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [edge_a, edge_b],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a novel multi-objective balance metric that considers both objective values and their trade-off relationships, then applies a hybrid local search combining a weighted node block relocation with a multi-objective edge reversal heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest multi-objective balance\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    balance_scores = np.sum((objectives - np.mean(objectives, axis=0))**2 / (obj_range + 1e-10), axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted node block relocation with multi-objective edge reversal\n    n = len(new_solution)\n    block_size = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - block_size)\n    block = new_solution[start_pos:start_pos+block_size]\n\n    # Relocate block to a new position\n    insert_pos = np.random.randint(0, n - block_size)\n    while insert_pos >= start_pos and insert_pos < start_pos + block_size:\n        insert_pos = np.random.randint(0, n - block_size)\n\n    new_solution = np.concatenate([\n        new_solution[:start_pos],\n        new_solution[start_pos+block_size:],\n        block\n    ])\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        block,\n        new_solution[insert_pos:]\n    ])\n\n    # Multi-objective edge reversal\n    weights = np.random.rand(3)\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or abs(i - j) < 2:\n            continue\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost for all three objectives\n        cost = (weights[0] * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j+1]]) +\n                weights[1] * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j+1]]) +\n                weights[2] * (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[j+1]]))\n\n        if cost < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search combining a novel multi-objective path inversion with a weighted segment rotation heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective path inversion with weighted segment rotation\n    n = len(new_solution)\n    k = np.random.randint(3, min(7, n//2))\n    segments = []\n    for _ in range(k):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segments.append((i, j))\n\n    # Apply path inversion to segments\n    for i, j in segments:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted segment rotation\n    weights = np.random.rand(3)\n    segment_size = np.random.randint(2, min(5, n//3))\n    start_pos = np.random.randint(0, n - segment_size)\n    segment = new_solution[start_pos:start_pos+segment_size]\n\n    # Calculate cost for all three objectives\n    cost = (weights[0] * (distance_matrix_1[new_solution[start_pos-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(start_pos+segment_size)%n]] -\n            distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] - distance_matrix_1[new_solution[start_pos+segment_size-1], new_solution[(start_pos+segment_size)%n]]) +\n            weights[1] * (distance_matrix_2[new_solution[start_pos-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(start_pos+segment_size)%n]] -\n            distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] - distance_matrix_2[new_solution[start_pos+segment_size-1], new_solution[(start_pos+segment_size)%n]]) +\n            weights[2] * (distance_matrix_3[new_solution[start_pos-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(start_pos+segment_size)%n]] -\n            distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] - distance_matrix_3[new_solution[start_pos+segment_size-1], new_solution[(start_pos+segment_size)%n]]))\n\n    if cost < 0:\n        new_segment = np.roll(segment, np.random.randint(1, segment_size))\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            new_segment,\n            new_solution[start_pos+segment_size:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5548563618469492,
            4.227303063869476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective path inversion with weighted segment rotation\n    n = len(new_solution)\n    k = np.random.randint(3, min(7, n//2))\n    segments = []\n    for _ in range(k):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segments.append((i, j))\n\n    # Apply path inversion to segments\n    for i, j in segments:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted segment rotation\n    weights = np.random.rand(3)\n    segment_size = np.random.randint(2, min(5, n//3))\n    start_pos = np.random.randint(0, n - segment_size)\n    segment = new_solution[start_pos:start_pos+segment_size]\n\n    # Calculate cost for all three objectives\n    cost = (weights[0] * (distance_matrix_1[new_solution[start_pos-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(start_pos+segment_size)%n]] -\n            distance_matrix_1[new_solution[start_pos-1], new_solution[start_pos]] - distance_matrix_1[new_solution[start_pos+segment_size-1], new_solution[(start_pos+segment_size)%n]]) +\n            weights[1] * (distance_matrix_2[new_solution[start_pos-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(start_pos+segment_size)%n]] -\n            distance_matrix_2[new_solution[start_pos-1], new_solution[start_pos]] - distance_matrix_2[new_solution[start_pos+segment_size-1], new_solution[(start_pos+segment_size)%n]]) +\n            weights[2] * (distance_matrix_3[new_solution[start_pos-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(start_pos+segment_size)%n]] -\n            distance_matrix_3[new_solution[start_pos-1], new_solution[start_pos]] - distance_matrix_3[new_solution[start_pos+segment_size-1], new_solution[(start_pos+segment_size)%n]]))\n\n    if cost < 0:\n        new_segment = np.roll(segment, np.random.randint(1, segment_size))\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            new_segment,\n            new_solution[start_pos+segment_size:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier proximity strategy, then applies a hybrid local search that combines a novel multi-objective segment inversion with a weighted node relocation heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.min(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmin(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment inversion with weighted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node relocation\n    weights = np.random.rand(3)\n    node_to_relocate = np.random.randint(0, n)\n    removed_node = new_solution[node_to_relocate]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_relocate:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6705349560725875,
            1.3069730401039124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.min(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmin(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment inversion with weighted node relocation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node relocation\n    weights = np.random.rand(3)\n    node_to_relocate = np.random.randint(0, n)\n    removed_node = new_solution[node_to_relocate]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_relocate:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[i:j+1] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_remove = np.random.randint(0, n)\n    removed_node = new_solution[node_to_remove]\n\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_remove:\n            continue\n\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] -\n                distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        [removed_node],\n        new_solution[best_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a hybrid local search that combines a novel multi-objective segment inversion with a dynamic node relocation heuristic to generate a neighbor solution while ensuring feasibility, using an adaptive weighting strategy to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n    new_solution[i:j+1] = inverted_segment\n\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        node_to_relocate = new_solution[a]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == a:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (weights[0] * (distance_matrix_1[prev_node, node_to_relocate] + distance_matrix_1[node_to_relocate, next_node] -\n                    distance_matrix_1[prev_node, next_node]) +\n                    weights[1] * (distance_matrix_2[prev_node, node_to_relocate] + distance_matrix_2[node_to_relocate, next_node] -\n                    distance_matrix_2[prev_node, next_node]) +\n                    weights[2] * (distance_matrix_3[prev_node, node_to_relocate] + distance_matrix_3[node_to_relocate, next_node] -\n                    distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[a+1:best_pos],\n            [node_to_relocate],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7443690776472305,
            4.294786608219146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n    new_solution[i:j+1] = inverted_segment\n\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        node_to_relocate = new_solution[a]\n\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == a:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost = (weights[0] * (distance_matrix_1[prev_node, node_to_relocate] + distance_matrix_1[node_to_relocate, next_node] -\n                    distance_matrix_1[prev_node, next_node]) +\n                    weights[1] * (distance_matrix_2[prev_node, node_to_relocate] + distance_matrix_2[node_to_relocate, next_node] -\n                    distance_matrix_2[prev_node, next_node]) +\n                    weights[2] * (distance_matrix_3[prev_node, node_to_relocate] + distance_matrix_3[node_to_relocate, next_node] -\n                    distance_matrix_3[prev_node, next_node]))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[a+1:best_pos],\n            [node_to_relocate],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm uses a hybrid approach combining segment reversal with adaptive segment length selection based on objective performance, prioritizing improvement of the worst-performing objective while maintaining feasibility through a novel dominance-aware node reinsertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it with adaptive length\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6069647019470544,
            1.2299680352210998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it with adaptive length\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity-aware selection strategy, then applies a hybrid local search that combines adaptive multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (largest range of values across objectives)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment rotation with weighted node insertion\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [node_to_insert],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7376317157627337,
            1.233436119556427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (largest range of values across objectives)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment rotation with weighted node insertion\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [node_to_insert],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel cluster-based local search that prioritizes improving the least dominant objective by selectively relocating clusters of nodes while maintaining feasibility, using a hybrid approach of cluster swapping and adaptive cluster size selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    cluster_size = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - cluster_size)\n    cluster = new_solution[start:start+cluster_size]\n\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + cluster_size:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = (distance_matrix_1[prev_node, cluster[0]] + distance_matrix_1[cluster[-1], next_node] -\n                    distance_matrix_1[prev_node, next_node])\n        elif least_dominant == 1:\n            cost = (distance_matrix_2[prev_node, cluster[0]] + distance_matrix_2[cluster[-1], next_node] -\n                    distance_matrix_2[prev_node, next_node])\n        else:\n            cost = (distance_matrix_3[prev_node, cluster[0]] + distance_matrix_3[cluster[-1], next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            cluster,\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6865740066847739,
            0.8886519074440002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    cluster_size = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - cluster_size)\n    cluster = new_solution[start:start+cluster_size]\n\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + cluster_size:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = (distance_matrix_1[prev_node, cluster[0]] + distance_matrix_1[cluster[-1], next_node] -\n                    distance_matrix_1[prev_node, next_node])\n        elif least_dominant == 1:\n            cost = (distance_matrix_2[prev_node, cluster[0]] + distance_matrix_2[cluster[-1], next_node] -\n                    distance_matrix_2[prev_node, next_node])\n        else:\n            cost = (distance_matrix_3[prev_node, cluster[0]] + distance_matrix_3[cluster[-1], next_node] -\n                    distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            cluster,\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on weighted objective sum\n    weighted_objectives = [(i, sum(obj)) for i, (_, obj) in enumerate(archive)]\n    weighted_objectives.sort(key=lambda x: x[1])\n    best_idx = weighted_objectives[0][0]\n    sol1 = archive[best_idx][0].copy()\n\n    # Select a random solution for segment exchange\n    random_idx = np.random.randint(0, len(archive))\n    sol2 = archive[random_idx][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(3, min(7, n // 2))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[best_idx][1]\n    objectives2 = archive[random_idx][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6042067065501355,
            1.3578242182731628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on weighted objective sum\n    weighted_objectives = [(i, sum(obj)) for i, (_, obj) in enumerate(archive)]\n    weighted_objectives.sort(key=lambda x: x[1])\n    best_idx = weighted_objectives[0][0]\n    sol1 = archive[best_idx][0].copy()\n\n    # Select a random solution for segment exchange\n    random_idx = np.random.randint(0, len(archive))\n    sol2 = archive[random_idx][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(3, min(7, n // 2))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[best_idx][1]\n    objectives2 = archive[random_idx][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on the most diverse objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n\n    # Find the worst edge in terms of combined distance across objectives\n    worst_edge = -1\n    worst_cost = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        cost = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        if cost > worst_cost:\n            worst_cost = cost\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt swap to replace the worst edge\n        i, j = worst_edge, (worst_edge + 1) % n\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6307792115686994,
            3.9046958565711973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on the most diverse objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n\n    # Find the worst edge in terms of combined distance across objectives\n    worst_edge = -1\n    worst_cost = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        cost = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        if cost > worst_cost:\n            worst_cost = cost\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt swap to replace the worst edge\n        i, j = worst_edge, (worst_edge + 1) % n\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted dominance score that considers both the objective values and their relative improvement potential, then applies a hybrid local search combining segment reversal with adaptive node reinsertion, prioritizing the objective with the highest normalized improvement potential while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weighted dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized\n    weights = 1 / (1 + np.exp(-improvement_potential))\n    weighted_scores = (weights * normalized).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify objective with highest improvement potential\n    improvement_scores = improvement_potential[selected_idx]\n    target_obj = np.argmax(improvement_scores)\n\n    # Hybrid local search\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert nodes to optimize target objective\n    for node in reversed_segment:\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            if target_obj == 0:\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif target_obj == 1:\n                cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7510347327394677,
            1.6730835556983947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weighted dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized\n    weights = 1 / (1 + np.exp(-improvement_potential))\n    weighted_scores = (weights * normalized).sum(axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify objective with highest improvement potential\n    improvement_scores = improvement_potential[selected_idx]\n    target_obj = np.argmax(improvement_scores)\n\n    # Hybrid local search\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert nodes to optimize target objective\n    for node in reversed_segment:\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            if target_obj == 0:\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif target_obj == 1:\n                cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment fusion strategy that dynamically combines segments from multiple solutions in the archive, using a weighted combination of objectives to guide the fusion while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple solutions from the archive\n    num_solutions = min(3, len(archive))\n    selected_indices = np.random.choice(len(archive), num_solutions, replace=False)\n    selected_solutions = [archive[i][0].copy() for i in selected_indices]\n\n    # Determine segment lengths based on solution quality\n    n = len(selected_solutions[0])\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from each solution\n    segments = []\n    for sol in selected_solutions:\n        start = np.random.randint(0, n - seg_length)\n        segments.append(sol[start:start+seg_length])\n\n    # Create new solution by interleaving segments\n    new_solution = []\n    for i in range(seg_length):\n        for seg in segments:\n            if i < len(seg):\n                new_solution.append(seg[i])\n\n    # Fill remaining positions with nodes not in the segments\n    remaining_nodes = np.setdiff1d(selected_solutions[0], new_solution, assume_unique=True)\n    new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    # Ensure feasibility by checking uniqueness\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, perform a simple repair\n        for i in range(n):\n            while np.sum(new_solution == new_solution[i]) > 1:\n                new_solution[i] = np.random.choice(np.setdiff1d(selected_solutions[0], new_solution))\n\n    # Further optimize by checking if the fusion improves any objective\n    improved = False\n    for idx in selected_indices:\n        objectives = archive[idx][1]\n        for i in range(3):\n            if objectives[i] < np.inf:  # Simple check for improvement\n                improved = True\n                break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6987580862813593,
            1.385967481136322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple solutions from the archive\n    num_solutions = min(3, len(archive))\n    selected_indices = np.random.choice(len(archive), num_solutions, replace=False)\n    selected_solutions = [archive[i][0].copy() for i in selected_indices]\n\n    # Determine segment lengths based on solution quality\n    n = len(selected_solutions[0])\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from each solution\n    segments = []\n    for sol in selected_solutions:\n        start = np.random.randint(0, n - seg_length)\n        segments.append(sol[start:start+seg_length])\n\n    # Create new solution by interleaving segments\n    new_solution = []\n    for i in range(seg_length):\n        for seg in segments:\n            if i < len(seg):\n                new_solution.append(seg[i])\n\n    # Fill remaining positions with nodes not in the segments\n    remaining_nodes = np.setdiff1d(selected_solutions[0], new_solution, assume_unique=True)\n    new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    # Ensure feasibility by checking uniqueness\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, perform a simple repair\n        for i in range(n):\n            while np.sum(new_solution == new_solution[i]) > 1:\n                new_solution[i] = np.random.choice(np.setdiff1d(selected_solutions[0], new_solution))\n\n    # Further optimize by checking if the fusion improves any objective\n    improved = False\n    for idx in selected_indices:\n        objectives = archive[idx][1]\n        for i in range(3):\n            if objectives[i] < np.inf:  # Simple check for improvement\n                improved = True\n                break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, enhanced by a dynamic objective weighting mechanism that adjusts segment operations based on current objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weights based on objective trade-offs\n    obj_weights = np.max(objectives, axis=0) - objectives[selected_idx]\n    obj_weights = obj_weights / np.sum(obj_weights) if np.sum(obj_weights) > 0 else np.ones(3)/3\n\n    # Select segment length based on objective weights\n    n = len(new_solution)\n    seg_length = max(2, min(5, int(n * np.random.choice([0.2, 0.3, 0.4], p=obj_weights))))\n\n    # Select a random segment and reverse it\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the weighted objectives\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (obj_weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                obj_weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                obj_weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7597982238467667,
            2.2911738753318787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weights based on objective trade-offs\n    obj_weights = np.max(objectives, axis=0) - objectives[selected_idx]\n    obj_weights = obj_weights / np.sum(obj_weights) if np.sum(obj_weights) > 0 else np.ones(3)/3\n\n    # Select segment length based on objective weights\n    n = len(new_solution)\n    seg_length = max(2, min(5, int(n * np.random.choice([0.2, 0.3, 0.4], p=obj_weights))))\n\n    # Select a random segment and reverse it\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the weighted objectives\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (obj_weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                obj_weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                obj_weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel adaptive segment-based local search that dynamically balances improvements across all three objectives by prioritizing the least dominant objective while maintaining feasibility through a hybrid approach of segment reversal, node reinsertion, and adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    removed_nodes = new_solution[start:start+seg_length]\n    for node in removed_nodes:\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            total_cost = (cost1 + cost2 + cost3) / 3\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6445785236601684,
            1.6539072871208191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    removed_nodes = new_solution[start:start+seg_length]\n    for node in removed_nodes:\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            total_cost = (cost1 + cost2 + cost3) / 3\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This algorithm implements a novel multi-objective TSP local search that combines adaptive segment swapping with objective-aware node relocation, dynamically balancing improvements across all three objectives by prioritizing segments that show the most balanced objective performance, while ensuring feasibility through constrained segment selection and dominance-aware reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (lowest standard deviation)\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective improvements for each segment\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n\n    # Find segment that improves all objectives when moved\n    best_seg_start = -1\n    best_improvement = -float('inf')\n\n    for start in range(n - seg_length):\n        segment = new_solution[start:start+seg_length]\n        prev_node = new_solution[start-1] if start > 0 else new_solution[-1]\n        next_node = new_solution[start+seg_length] if start+seg_length < n-1 else new_solution[0]\n\n        # Calculate original costs\n        orig_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node]\n        orig_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node]\n        orig_cost3 = distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node]\n\n        # Calculate new costs if segment is moved to random position\n        new_pos = np.random.randint(0, n - seg_length)\n        if new_pos >= start and new_pos < start + seg_length:\n            continue\n\n        new_prev = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n        new_next = new_solution[new_pos] if new_pos < n-1 else new_solution[0]\n\n        new_cost1 = distance_matrix_1[new_prev, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], new_next]\n        new_cost3 = distance_matrix_3[new_prev, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], new_next]\n\n        # Calculate total improvement\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2) + (orig_cost3 - new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_seg_start = start\n\n    if best_seg_start != -1:\n        # Move the selected segment to a new position\n        segment = new_solution[best_seg_start:best_seg_start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:best_seg_start],\n            new_solution[best_seg_start+seg_length:]\n        ])\n\n        new_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8622477179292419,
            4.143181598186493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (lowest standard deviation)\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective improvements for each segment\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n\n    # Find segment that improves all objectives when moved\n    best_seg_start = -1\n    best_improvement = -float('inf')\n\n    for start in range(n - seg_length):\n        segment = new_solution[start:start+seg_length]\n        prev_node = new_solution[start-1] if start > 0 else new_solution[-1]\n        next_node = new_solution[start+seg_length] if start+seg_length < n-1 else new_solution[0]\n\n        # Calculate original costs\n        orig_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node]\n        orig_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node]\n        orig_cost3 = distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node]\n\n        # Calculate new costs if segment is moved to random position\n        new_pos = np.random.randint(0, n - seg_length)\n        if new_pos >= start and new_pos < start + seg_length:\n            continue\n\n        new_prev = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n        new_next = new_solution[new_pos] if new_pos < n-1 else new_solution[0]\n\n        new_cost1 = distance_matrix_1[new_prev, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], new_next]\n        new_cost3 = distance_matrix_3[new_prev, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], new_next]\n\n        # Calculate total improvement\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2) + (orig_cost3 - new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_seg_start = start\n\n    if best_seg_start != -1:\n        # Move the selected segment to a new position\n        segment = new_solution[best_seg_start:best_seg_start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:best_seg_start],\n            new_solution[best_seg_start+seg_length:]\n        ])\n\n        new_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm employs a multi-objective adaptive path insertion strategy that dynamically selects and reinserts segments from multiple solutions in the archive, using a weighted combination of objectives to guide the insertion while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution and a reference solution\n    base_idx = np.random.randint(len(archive))\n    base_sol = archive[base_idx][0].copy()\n    ref_idx = np.random.choice([i for i in range(len(archive)) if i != base_idx])\n    ref_sol = archive[ref_idx][0].copy()\n\n    n = len(base_sol)\n    seg_length = max(2, min(5, n // 4))\n\n    # Select a segment from the reference solution\n    start_ref = np.random.randint(0, n - seg_length)\n    seg = ref_sol[start_ref:start_ref+seg_length]\n\n    # Find the best insertion point in the base solution\n    min_cost = float('inf')\n    best_pos = 0\n\n    for i in range(n - seg_length + 1):\n        candidate = np.concatenate([base_sol[:i], seg, base_sol[i+seg_length:]])\n        cost = 0\n        for j in range(n):\n            cost += distance_matrix_1[candidate[j-1], candidate[j]]\n            cost += distance_matrix_2[candidate[j-1], candidate[j]]\n            cost += distance_matrix_3[candidate[j-1], candidate[j]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    new_solution = np.concatenate([base_sol[:best_pos], seg, base_sol[best_pos+seg_length:]])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # Perform a simple swap if insertion causes duplicates\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the insertion improves any objective\n    base_objectives = archive[base_idx][1]\n    ref_objectives = archive[ref_idx][1]\n\n    improved = False\n    for i in range(3):\n        if ref_objectives[i] < base_objectives[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6582563905236144,
            3.2462915420532226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution and a reference solution\n    base_idx = np.random.randint(len(archive))\n    base_sol = archive[base_idx][0].copy()\n    ref_idx = np.random.choice([i for i in range(len(archive)) if i != base_idx])\n    ref_sol = archive[ref_idx][0].copy()\n\n    n = len(base_sol)\n    seg_length = max(2, min(5, n // 4))\n\n    # Select a segment from the reference solution\n    start_ref = np.random.randint(0, n - seg_length)\n    seg = ref_sol[start_ref:start_ref+seg_length]\n\n    # Find the best insertion point in the base solution\n    min_cost = float('inf')\n    best_pos = 0\n\n    for i in range(n - seg_length + 1):\n        candidate = np.concatenate([base_sol[:i], seg, base_sol[i+seg_length:]])\n        cost = 0\n        for j in range(n):\n            cost += distance_matrix_1[candidate[j-1], candidate[j]]\n            cost += distance_matrix_2[candidate[j-1], candidate[j]]\n            cost += distance_matrix_3[candidate[j-1], candidate[j]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    new_solution = np.concatenate([base_sol[:best_pos], seg, base_sol[best_pos+seg_length:]])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # Perform a simple swap if insertion causes duplicates\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the insertion improves any objective\n    base_objectives = archive[base_idx][1]\n    ref_objectives = archive[ref_idx][1]\n\n    improved = False\n    for i in range(3):\n        if ref_objectives[i] < base_objectives[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm employs an adaptive k-opt local search strategy that dynamically selects segment lengths (k) based on objective performance, followed by a dominance-aware node reinsertion that prioritizes improvement in the most improved objective while maintaining feasibility through segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    n = len(new_solution)\n    max_k = min(5, n // 3)\n    k = np.random.randint(2, max_k + 1)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    if np.random.random() < 0.6 * (1 - worst_obj[most_improved] / np.max(worst_obj)):\n        new_solution[start:start+k] = segment[::-1]\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + k:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6997745213346741,
            1.2444549918174743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    n = len(new_solution)\n    max_k = min(5, n // 3)\n    k = np.random.randint(2, max_k + 1)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    if np.random.random() < 0.6 * (1 - worst_obj[most_improved] / np.max(worst_obj)):\n        new_solution[start:start+k] = segment[::-1]\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + k:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm employs a multi-objective adaptive path relinking strategy that dynamically combines segments from multiple solutions in the archive, weighted by their objective dominance, while periodically applying a randomized 3-opt move to escape local optima and maintain diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions based on objective dominance\n    weights = np.array([np.random.uniform(0.3, 0.7) for _ in range(len(archive))])\n    weighted_scores = np.array([sum(w * obj for w, obj in zip(weights, sol[1])) for sol in archive])\n    selected_indices = np.argsort(weighted_scores)[:3]\n    selected_solutions = [archive[i][0].copy() for i in selected_indices]\n\n    # Combine segments from selected solutions\n    n = len(selected_solutions[0])\n    seg_length = max(3, min(7, n // 4))\n    new_solution = selected_solutions[0].copy()\n\n    for i in range(1, len(selected_solutions)):\n        start = np.random.randint(0, n - seg_length)\n        seg = selected_solutions[i][start:start+seg_length]\n        new_solution[start:start+seg_length] = seg\n\n    # Apply 3-opt move with probability\n    if np.random.random() < 0.4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicate nodes, perform a random 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6700821348515211,
            4.338142788410186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions based on objective dominance\n    weights = np.array([np.random.uniform(0.3, 0.7) for _ in range(len(archive))])\n    weighted_scores = np.array([sum(w * obj for w, obj in zip(weights, sol[1])) for sol in archive])\n    selected_indices = np.argsort(weighted_scores)[:3]\n    selected_solutions = [archive[i][0].copy() for i in selected_indices]\n\n    # Combine segments from selected solutions\n    n = len(selected_solutions[0])\n    seg_length = max(3, min(7, n // 4))\n    new_solution = selected_solutions[0].copy()\n\n    for i in range(1, len(selected_solutions)):\n        start = np.random.randint(0, n - seg_length)\n        seg = selected_solutions[i][start:start+seg_length]\n        new_solution[start:start+seg_length] = seg\n\n    # Apply 3-opt move with probability\n    if np.random.random() < 0.4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicate nodes, perform a random 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    k = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node_a and pos != (node_a + 1) % n:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(pos+1)%n]] -\n                              distance_matrix_1[new_solution[pos-1], new_solution[(pos+1)%n]] - distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] -\n                              distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(pos+1)%n]] -\n                              distance_matrix_2[new_solution[pos-1], new_solution[(pos+1)%n]] - distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] -\n                              distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(pos+1)%n]] -\n                              distance_matrix_3[new_solution[pos-1], new_solution[(pos+1)%n]] - distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] -\n                              distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]]))\n\n        if cost < 0:\n            node = new_solution[node_a]\n            new_solution = np.concatenate([new_solution[:node_a], new_solution[node_a+1:]])\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4935151573377369,
            3.2095396757125854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    k = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node_a and pos != (node_a + 1) % n:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(pos+1)%n]] -\n                              distance_matrix_1[new_solution[pos-1], new_solution[(pos+1)%n]] - distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] -\n                              distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(pos+1)%n]] -\n                              distance_matrix_2[new_solution[pos-1], new_solution[(pos+1)%n]] - distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] -\n                              distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(pos+1)%n]] -\n                              distance_matrix_3[new_solution[pos-1], new_solution[(pos+1)%n]] - distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] -\n                              distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]]))\n\n        if cost < 0:\n            node = new_solution[node_a]\n            new_solution = np.concatenate([new_solution[:node_a], new_solution[node_a+1:]])\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This algorithm employs a multi-objective dynamic path decomposition strategy that adaptively partitions the tour into segments based on objective-specific distance patterns, then applies a hybrid of inter-segment crossover and intra-segment inversion, with segment selection prioritizing those showing the most promising objective improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (largest range of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic path decomposition based on objective-specific distance patterns\n    n = len(new_solution)\n    segment_lengths = np.random.randint(3, min(8, n//2), size=3)\n    segment_lengths[-1] = n - sum(segment_lengths[:-1])\n    segments = []\n    start = 0\n    for length in segment_lengths:\n        segments.append(new_solution[start:start+length])\n        start += length\n\n    # Evaluate segments across all objectives\n    segment_scores = []\n    for i, seg in enumerate(segments):\n        seg_score = 0\n        for j in range(len(seg)-1):\n            seg_score += (distance_matrix_1[seg[j], seg[j+1]] +\n                          distance_matrix_2[seg[j], seg[j+1]] +\n                          distance_matrix_3[seg[j], seg[j+1]])\n        segment_scores.append(seg_score)\n\n    # Identify segment with most potential for improvement\n    worst_segment = np.argmax(segment_scores)\n    target_segment = segments[worst_segment]\n\n    # Hybrid local search: inter-segment crossover and intra-segment inversion\n    if len(segments) > 1:\n        # Inter-segment crossover\n        other_seg = np.random.choice([i for i in range(len(segments)) if i != worst_segment])\n        crossover_point = np.random.randint(1, min(len(target_segment), len(segments[other_seg]))-1)\n        segments[worst_segment][:crossover_point], segments[other_seg][:crossover_point] = (\n            segments[other_seg][:crossover_point].copy(),\n            segments[worst_segment][:crossover_point].copy()\n        )\n\n    # Intra-segment inversion\n    if len(target_segment) > 2:\n        inv_start, inv_end = sorted(np.random.choice(range(len(target_segment)), 2, replace=False))\n        target_segment[inv_start:inv_end+1] = target_segment[inv_start:inv_end+1][::-1]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5120555385486,
            3.075271689891815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (largest range of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic path decomposition based on objective-specific distance patterns\n    n = len(new_solution)\n    segment_lengths = np.random.randint(3, min(8, n//2), size=3)\n    segment_lengths[-1] = n - sum(segment_lengths[:-1])\n    segments = []\n    start = 0\n    for length in segment_lengths:\n        segments.append(new_solution[start:start+length])\n        start += length\n\n    # Evaluate segments across all objectives\n    segment_scores = []\n    for i, seg in enumerate(segments):\n        seg_score = 0\n        for j in range(len(seg)-1):\n            seg_score += (distance_matrix_1[seg[j], seg[j+1]] +\n                          distance_matrix_2[seg[j], seg[j+1]] +\n                          distance_matrix_3[seg[j], seg[j+1]])\n        segment_scores.append(seg_score)\n\n    # Identify segment with most potential for improvement\n    worst_segment = np.argmax(segment_scores)\n    target_segment = segments[worst_segment]\n\n    # Hybrid local search: inter-segment crossover and intra-segment inversion\n    if len(segments) > 1:\n        # Inter-segment crossover\n        other_seg = np.random.choice([i for i in range(len(segments)) if i != worst_segment])\n        crossover_point = np.random.randint(1, min(len(target_segment), len(segments[other_seg]))-1)\n        segments[worst_segment][:crossover_point], segments[other_seg][:crossover_point] = (\n            segments[other_seg][:crossover_point].copy(),\n            segments[worst_segment][:crossover_point].copy()\n        )\n\n    # Intra-segment inversion\n    if len(target_segment) > 2:\n        inv_start, inv_end = sorted(np.random.choice(range(len(target_segment)), 2, replace=False))\n        target_segment[inv_start:inv_end+1] = target_segment[inv_start:inv_end+1][::-1]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier aware selection criterion that considers the normalized hypervolume contribution of each solution, then applies an adaptive multi-segment reversal operator with dynamic node insertion to explore diverse trade-offs across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-8)\n\n    crowding_dist = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    combined_score = normalized.sum(axis=1) + crowding_dist\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segments = np.random.randint(1, 4)\n    for _ in range(segments):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n    for _ in range(2):\n        pos = np.random.randint(1, n-1)\n        node = new_solution[pos]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:], [node]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7316984420954422,
            3.9627744793891906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-8)\n\n    crowding_dist = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    combined_score = normalized.sum(axis=1) + crowding_dist\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segments = np.random.randint(1, 4)\n    for _ in range(segments):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n    for _ in range(2):\n        pos = np.random.randint(1, n-1)\n        node = new_solution[pos]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:], [node]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6500582681583938,
            0.8365290641784668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective diversity-aware selection strategy, then applies a novel hybrid local search that combines a multi-dimensional node insertion with a probabilistic segment rotation heuristic to generate a neighbor solution while ensuring feasibility through a dominance-preserving validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-dimensional node insertion\n    n = len(new_solution)\n    node_to_insert = np.random.randint(0, n)\n    removed_node = new_solution[node_to_insert]\n\n    # Find best insertion position across all objectives\n    best_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_insert:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Probabilistic segment rotation\n    if np.random.random() < 0.5:\n        seg_length = np.random.randint(2, min(10, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Rotate segment based on objective weights\n        weights = np.random.rand(3)\n        weights /= weights.sum()\n\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(seg_length-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(seg_length-1))\n        obj3 = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(seg_length-1))\n\n        total_obj = weights[0]*obj1 + weights[1]*obj2 + weights[2]*obj3\n\n        if np.random.random() < 0.3 * (1 - total_obj/np.max([obj1, obj2, obj3])):\n            rotated = np.roll(segment, np.random.randint(1, seg_length))\n            new_solution[start:start+seg_length] = rotated\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7088305504156028,
            1.3571663975715638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-dimensional node insertion\n    n = len(new_solution)\n    node_to_insert = np.random.randint(0, n)\n    removed_node = new_solution[node_to_insert]\n\n    # Find best insertion position across all objectives\n    best_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(n):\n        if i == node_to_insert:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Probabilistic segment rotation\n    if np.random.random() < 0.5:\n        seg_length = np.random.randint(2, min(10, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Rotate segment based on objective weights\n        weights = np.random.rand(3)\n        weights /= weights.sum()\n\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(seg_length-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(seg_length-1))\n        obj3 = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(seg_length-1))\n\n        total_obj = weights[0]*obj1 + weights[1]*obj2 + weights[2]*obj3\n\n        if np.random.random() < 0.3 * (1 - total_obj/np.max([obj1, obj2, obj3])):\n            rotated = np.roll(segment, np.random.randint(1, seg_length))\n            new_solution[start:start+seg_length] = rotated\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance-aware selection strategy, then applies a hybrid local search that combines a novel multi-objective node insertion with a weighted edge swap heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best dominance-aware score\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.sum(objectives <= objectives.mean(axis=0), axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node insertion with weighted edge swap\n    n = len(new_solution)\n    node_to_move = np.random.randint(0, n)\n    insert_pos = np.random.randint(0, n)\n\n    # Perform node insertion\n    node = new_solution[node_to_move]\n    new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    edge_a = np.random.randint(0, n-1)\n    edge_b = np.random.randint(0, n-1)\n\n    if edge_a != edge_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[edge_a], new_solution[edge_b]] + distance_matrix_1[new_solution[edge_b+1], new_solution[edge_a+1]] -\n                distance_matrix_1[new_solution[edge_a], new_solution[edge_a+1]] - distance_matrix_1[new_solution[edge_b], new_solution[edge_b+1]]) +\n                weights[1] * (distance_matrix_2[new_solution[edge_a], new_solution[edge_b]] + distance_matrix_2[new_solution[edge_b+1], new_solution[edge_a+1]] -\n                distance_matrix_2[new_solution[edge_a], new_solution[edge_a+1]] - distance_matrix_2[new_solution[edge_b], new_solution[edge_b+1]]) +\n                weights[2] * (distance_matrix_3[new_solution[edge_a], new_solution[edge_b]] + distance_matrix_3[new_solution[edge_b+1], new_solution[edge_a+1]] -\n                distance_matrix_3[new_solution[edge_a], new_solution[edge_a+1]] - distance_matrix_3[new_solution[edge_b], new_solution[edge_b+1]]))\n\n        if cost < 0:\n            new_solution[edge_a+1], new_solution[edge_b] = new_solution[edge_b], new_solution[edge_a+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6612856663028653,
            3.9670501351356506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best dominance-aware score\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.sum(objectives <= objectives.mean(axis=0), axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node insertion with weighted edge swap\n    n = len(new_solution)\n    node_to_move = np.random.randint(0, n)\n    insert_pos = np.random.randint(0, n)\n\n    # Perform node insertion\n    node = new_solution[node_to_move]\n    new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Weighted edge swap\n    weights = np.random.rand(3)\n    edge_a = np.random.randint(0, n-1)\n    edge_b = np.random.randint(0, n-1)\n\n    if edge_a != edge_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[edge_a], new_solution[edge_b]] + distance_matrix_1[new_solution[edge_b+1], new_solution[edge_a+1]] -\n                distance_matrix_1[new_solution[edge_a], new_solution[edge_a+1]] - distance_matrix_1[new_solution[edge_b], new_solution[edge_b+1]]) +\n                weights[1] * (distance_matrix_2[new_solution[edge_a], new_solution[edge_b]] + distance_matrix_2[new_solution[edge_b+1], new_solution[edge_a+1]] -\n                distance_matrix_2[new_solution[edge_a], new_solution[edge_a+1]] - distance_matrix_2[new_solution[edge_b], new_solution[edge_b+1]]) +\n                weights[2] * (distance_matrix_3[new_solution[edge_a], new_solution[edge_b]] + distance_matrix_3[new_solution[edge_b+1], new_solution[edge_a+1]] -\n                distance_matrix_3[new_solution[edge_a], new_solution[edge_a+1]] - distance_matrix_3[new_solution[edge_b], new_solution[edge_b+1]]))\n\n        if cost < 0:\n            new_solution[edge_a+1], new_solution[edge_b] = new_solution[edge_b], new_solution[edge_a+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This algorithm employs an adaptive multi-segment crossover strategy that dynamically selects and exchanges variable-length segments between solutions, using a weighted objective improvement metric to prioritize exchanges that show potential for better convergence across all three objectives, while incorporating a probabilistic repair mechanism to maintain feasibility and explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    seg_length = np.random.randint(2, min(7, n // 2))\n\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = base_solution[start1:start1+seg_length]\n    seg2 = base_solution[start2:start2+seg_length]\n\n    new_solution = np.concatenate([\n        base_solution[:start1],\n        seg2,\n        base_solution[start1+seg_length:start2],\n        seg1,\n        base_solution[start2+seg_length:]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6345072857917426,
            1.3792976498603822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    seg_length = np.random.randint(2, min(7, n // 2))\n\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = base_solution[start1:start1+seg_length]\n    seg2 = base_solution[start2:start2+seg_length]\n\n    new_solution = np.concatenate([\n        base_solution[:start1],\n        seg2,\n        base_solution[start1+seg_length:start2],\n        seg1,\n        base_solution[start2+seg_length:]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This algorithm uses a multi-objective-aware node swap strategy that selectively swaps nodes based on their performance across objectives, with adaptive selection of swap candidates that prioritize improving the most underperforming objective while maintaining tour feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst objective value in any dimension\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_indices = np.argmax(objectives, axis=1)\n    worst_obj_values = np.max(objectives, axis=1)\n    selected_idx = np.argmax(worst_obj_values)\n    least_dominant = worst_obj_indices[selected_idx]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Find nodes that are worst in their current positions for the least dominant objective\n    n = len(new_solution)\n    node_improvement = np.zeros(n)\n\n    for i in range(n):\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            current_cost = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n            node_improvement[i] = current_cost\n        elif least_dominant == 1:\n            current_cost = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n            node_improvement[i] = current_cost\n        else:\n            current_cost = distance_matrix_3[prev_node, new_solution[i]] + distance_matrix_3[new_solution[i], next_node]\n            node_improvement[i] = current_cost\n\n    # Select top 20% nodes with worst performance for the least dominant objective\n    threshold = np.percentile(node_improvement, 80)\n    candidate_nodes = np.where(node_improvement >= threshold)[0]\n\n    if len(candidate_nodes) < 2:\n        # If not enough candidates, select random nodes\n        candidate_nodes = np.random.choice(n, size=2, replace=False)\n\n    # Perform constrained swap between two candidate nodes\n    i, j = candidate_nodes[:2]\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7740706935892357,
            3.345875251293182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the worst objective value in any dimension\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_indices = np.argmax(objectives, axis=1)\n    worst_obj_values = np.max(objectives, axis=1)\n    selected_idx = np.argmax(worst_obj_values)\n    least_dominant = worst_obj_indices[selected_idx]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Find nodes that are worst in their current positions for the least dominant objective\n    n = len(new_solution)\n    node_improvement = np.zeros(n)\n\n    for i in range(n):\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            current_cost = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n            node_improvement[i] = current_cost\n        elif least_dominant == 1:\n            current_cost = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n            node_improvement[i] = current_cost\n        else:\n            current_cost = distance_matrix_3[prev_node, new_solution[i]] + distance_matrix_3[new_solution[i], next_node]\n            node_improvement[i] = current_cost\n\n    # Select top 20% nodes with worst performance for the least dominant objective\n    threshold = np.percentile(node_improvement, 80)\n    candidate_nodes = np.where(node_improvement >= threshold)[0]\n\n    if len(candidate_nodes) < 2:\n        # If not enough candidates, select random nodes\n        candidate_nodes = np.random.choice(n, size=2, replace=False)\n\n    # Perform constrained swap between two candidate nodes\n    i, j = candidate_nodes[:2]\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, and incorporates a dynamic objective weighting mechanism to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Dynamic objective weighting\n    weights = np.array([1.0, 1.0, 1.0])\n    weights[least_dominant] *= 1.5\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * distance_matrix_1[prev_node, removed_node] + weights[0] * distance_matrix_1[removed_node, next_node] - weights[0] * distance_matrix_1[prev_node, next_node] +\n                weights[1] * distance_matrix_2[prev_node, removed_node] + weights[1] * distance_matrix_2[removed_node, next_node] - weights[1] * distance_matrix_2[prev_node, next_node] +\n                weights[2] * distance_matrix_3[prev_node, removed_node] + weights[2] * distance_matrix_3[removed_node, next_node] - weights[2] * distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6935829579681236,
            1.3161787033081054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Dynamic objective weighting\n    weights = np.array([1.0, 1.0, 1.0])\n    weights[least_dominant] *= 1.5\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * distance_matrix_1[prev_node, removed_node] + weights[0] * distance_matrix_1[removed_node, next_node] - weights[0] * distance_matrix_1[prev_node, next_node] +\n                weights[1] * distance_matrix_2[prev_node, removed_node] + weights[1] * distance_matrix_2[removed_node, next_node] - weights[1] * distance_matrix_2[prev_node, next_node] +\n                weights[2] * distance_matrix_3[prev_node, removed_node] + weights[2] * distance_matrix_3[removed_node, next_node] - weights[2] * distance_matrix_3[prev_node, next_node])\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = min(5, n // 2)\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7512019307564591,
            4.371501636505127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = min(5, n // 2)\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if new_cost < current_cost or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4594672007401154,
            3.6021040558815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This new algorithm selects a solution from the archive using a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment rotation with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    insertion_pos = np.random.randint(0, n)\n\n    if node_to_insert != insertion_pos and node_to_insert != insertion_pos - 1:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_to_insert-1], new_solution[insertion_pos]] +\n                distance_matrix_1[new_solution[insertion_pos-1], new_solution[node_to_insert]] -\n                distance_matrix_1[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                distance_matrix_1[new_solution[insertion_pos-1], new_solution[insertion_pos]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_to_insert-1], new_solution[insertion_pos]] +\n                distance_matrix_2[new_solution[insertion_pos-1], new_solution[node_to_insert]] -\n                distance_matrix_2[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                distance_matrix_2[new_solution[insertion_pos-1], new_solution[insertion_pos]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_to_insert-1], new_solution[insertion_pos]] +\n                distance_matrix_3[new_solution[insertion_pos-1], new_solution[node_to_insert]] -\n                distance_matrix_3[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                distance_matrix_3[new_solution[insertion_pos-1], new_solution[insertion_pos]]))\n\n        if cost < 0:\n            # Remove node from original position and insert at new position\n            new_solution = np.delete(new_solution, node_to_insert)\n            new_solution = np.insert(new_solution, insertion_pos, base_solution[node_to_insert])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4304912875555827,
            4.029879891872406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment rotation with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment rotation\n    segment = new_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    insertion_pos = np.random.randint(0, n)\n\n    if node_to_insert != insertion_pos and node_to_insert != insertion_pos - 1:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_to_insert-1], new_solution[insertion_pos]] +\n                distance_matrix_1[new_solution[insertion_pos-1], new_solution[node_to_insert]] -\n                distance_matrix_1[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                distance_matrix_1[new_solution[insertion_pos-1], new_solution[insertion_pos]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_to_insert-1], new_solution[insertion_pos]] +\n                distance_matrix_2[new_solution[insertion_pos-1], new_solution[node_to_insert]] -\n                distance_matrix_2[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                distance_matrix_2[new_solution[insertion_pos-1], new_solution[insertion_pos]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_to_insert-1], new_solution[insertion_pos]] +\n                distance_matrix_3[new_solution[insertion_pos-1], new_solution[node_to_insert]] -\n                distance_matrix_3[new_solution[node_to_insert-1], new_solution[node_to_insert]] -\n                distance_matrix_3[new_solution[insertion_pos-1], new_solution[insertion_pos]]))\n\n        if cost < 0:\n            # Remove node from original position and insert at new position\n            new_solution = np.delete(new_solution, node_to_insert)\n            new_solution = np.insert(new_solution, insertion_pos, base_solution[node_to_insert])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This algorithm employs a multi-objective aware segment-based local search that adaptively selects segments to optimize based on objective performance, combining segment reversal with node reinsertion while prioritizing improvement in the most critical objective dimension through dynamic segment length selection and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most critical objective dimension to improve\n    worst_obj = objectives[selected_idx]\n    critical_obj = np.argmax(worst_obj)\n\n    # Adaptive segment selection based on objective performance\n    n = len(new_solution)\n    seg_length = min(5, n // 3) if worst_obj[critical_obj] > np.median(objectives[:, critical_obj]) else np.random.randint(2, 5)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Apply segment reversal with 70% probability\n    if np.random.rand() < 0.7:\n        new_solution[start:start+seg_length] = segment[::-1]\n        segment = new_solution[start:start+seg_length]\n\n    # Node reinsertion to optimize the critical objective\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if critical_obj == 0:\n            cost = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n        elif critical_obj == 1:\n            cost = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        # Remove the segment and insert at best position\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7109854191548198,
            1.290904939174652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most critical objective dimension to improve\n    worst_obj = objectives[selected_idx]\n    critical_obj = np.argmax(worst_obj)\n\n    # Adaptive segment selection based on objective performance\n    n = len(new_solution)\n    seg_length = min(5, n // 3) if worst_obj[critical_obj] > np.median(objectives[:, critical_obj]) else np.random.randint(2, 5)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Apply segment reversal with 70% probability\n    if np.random.rand() < 0.7:\n        new_solution[start:start+seg_length] = segment[::-1]\n        segment = new_solution[start:start+seg_length]\n\n    # Node reinsertion to optimize the critical objective\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if critical_obj == 0:\n            cost = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n        elif critical_obj == 1:\n            cost = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        # Remove the segment and insert at best position\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive path relinking strategy that dynamically selects and combines segments from different solutions based on objective performance, followed by a dominance-aware edge insertion that prioritizes improvement in the least dominated objective while maintaining feasibility through careful edge selection and dominance-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive path relinking with segment combination\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    # Select another solution from archive for segment exchange\n    other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0]\n\n    # Find similar segment in other solution\n    for i in range(len(other_solution) - seg_length + 1):\n        if np.array_equal(base_solution[start:start+seg_length], other_solution[i:i+seg_length]):\n            new_solution[start:start+seg_length] = other_solution[i:i+seg_length]\n            break\n\n    # Dominance-aware edge insertion\n    removed_edge = np.random.choice(range(n))\n    candidate_edges = []\n\n    for i in range(n):\n        if i == removed_edge or i == (removed_edge + 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n        removed_node = new_solution[removed_edge]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_edges.append((cost, i))\n\n    if candidate_edges:\n        candidate_edges.sort()\n        best_pos = candidate_edges[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_edge]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm employs a hybrid local search strategy that combines objective-specific 2-opt moves with a dominance-aware insertion heuristic, prioritizing improvement in the least dominated objective while maintaining feasibility through careful edge selection and dominance-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n\n    # Select solution with highest potential for improvement\n    selected_idx = np.random.choice(np.where(dominance_scores == dominance_scores.min())[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_segments = min(5, n // 4)\n    num_segments = np.random.randint(1, max_segments + 1)\n\n    # Perform objective-specific 2-opt moves\n    for _ in range(num_segments):\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Evaluate move based on least dominant objective\n        if least_dominant == 0:\n            current_cost = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif least_dominant == 1:\n            current_cost = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            current_cost = distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform dominance-aware insertion\n    removed_edge = np.random.choice(range(n))\n    candidate_edges = []\n\n    for i in range(n):\n        if i == removed_edge or i == (removed_edge + 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n        removed_node = new_solution[removed_edge]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_edges.append((cost, i))\n\n    if candidate_edges:\n        candidate_edges.sort()\n        best_pos = candidate_edges[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_edge]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7787098234828456,
            2.7203067541122437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n\n    # Select solution with highest potential for improvement\n    selected_idx = np.random.choice(np.where(dominance_scores == dominance_scores.min())[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_segments = min(5, n // 4)\n    num_segments = np.random.randint(1, max_segments + 1)\n\n    # Perform objective-specific 2-opt moves\n    for _ in range(num_segments):\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Evaluate move based on least dominant objective\n        if least_dominant == 0:\n            current_cost = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif least_dominant == 1:\n            current_cost = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            current_cost = distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform dominance-aware insertion\n    removed_edge = np.random.choice(range(n))\n    candidate_edges = []\n\n    for i in range(n):\n        if i == removed_edge or i == (removed_edge + 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n        removed_node = new_solution[removed_edge]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_edges.append((cost, i))\n\n    if candidate_edges:\n        candidate_edges.sort()\n        best_pos = candidate_edges[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_edge]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This algorithm employs a hybrid of objective-specific segment swapping and dominance-aware node reinsertion, where segments are selected based on their contribution to the most improved objective, followed by reinsertion that prioritizes the least dominated objective while dynamically adjusting segment sizes based on solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    quality_scores = 1 - normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = min(5, n // 3)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    best_obj = np.argmin(objectives[selected_idx])\n    if best_obj == 0:\n        matrix = distance_matrix_1\n    elif best_obj == 1:\n        matrix = distance_matrix_2\n    else:\n        matrix = distance_matrix_3\n\n    best_swap = None\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        for j in range(len(segment)):\n            node = segment[j]\n            cost = (matrix[prev_node, node] + matrix[node, next_node] - matrix[prev_node, next_node] +\n                    matrix[node, segment[j-1]] + matrix[segment[j-1], node] - matrix[node, segment[j-1]])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        node = segment[j]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            [node],\n            new_solution[i:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6924479299974651,
            2.418639624118805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    quality_scores = 1 - normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = min(5, n // 3)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    best_obj = np.argmin(objectives[selected_idx])\n    if best_obj == 0:\n        matrix = distance_matrix_1\n    elif best_obj == 1:\n        matrix = distance_matrix_2\n    else:\n        matrix = distance_matrix_3\n\n    best_swap = None\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        for j in range(len(segment)):\n            node = segment[j]\n            cost = (matrix[prev_node, node] + matrix[node, next_node] - matrix[prev_node, next_node] +\n                    matrix[node, segment[j-1]] + matrix[segment[j-1], node] - matrix[node, segment[j-1]])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        node = segment[j]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            [node],\n            new_solution[i:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm implements a novel multi-objective TSP local search that combines adaptive segment swapping with objective-aware node relocation, dynamically balancing improvements across all three objectives by prioritizing segments that show the most balanced objective performance, while ensuring feasibility through constrained segment selection and dominance-aware reinsertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (lowest standard deviation)\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective improvements for each segment\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n\n    # Find segment that improves all objectives when moved\n    best_seg_start = -1\n    best_improvement = -float('inf')\n\n    for start in range(n - seg_length):\n        segment = new_solution[start:start+seg_length]\n        prev_node = new_solution[start-1] if start > 0 else new_solution[-1]\n        next_node = new_solution[start+seg_length] if start+seg_length < n-1 else new_solution[0]\n\n        # Calculate original costs\n        orig_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node]\n        orig_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node]\n        orig_cost3 = distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node]\n\n        # Calculate new costs if segment is moved to random position\n        new_pos = np.random.randint(0, n - seg_length)\n        if new_pos >= start and new_pos < start + seg_length:\n            continue\n\n        new_prev = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n        new_next = new_solution[new_pos] if new_pos < n-1 else new_solution[0]\n\n        new_cost1 = distance_matrix_1[new_prev, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], new_next]\n        new_cost3 = distance_matrix_3[new_prev, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], new_next]\n\n        # Calculate total improvement\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2) + (orig_cost3 - new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_seg_start = start\n\n    if best_seg_start != -1:\n        # Move the selected segment to a new position\n        segment = new_solution[best_seg_start:best_seg_start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:best_seg_start],\n            new_solution[best_seg_start+seg_length:]\n        ])\n\n        new_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance-aware objective selection strategy, then applies a novel multi-objective path inversion with adaptive node insertion that dynamically balances improvements across all three objectives by prioritizing segments that show the most balanced objective performance, while ensuring feasibility through constrained segment selection and dominance-aware reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (lowest standard deviation)\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective improvements for each segment\n    n = len(new_solution)\n    max_seg_length = min(5, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n\n    # Find segment that improves all objectives when inverted\n    best_seg_start = -1\n    best_improvement = -float('inf')\n\n    for start in range(n - seg_length):\n        segment = new_solution[start:start+seg_length]\n        prev_node = new_solution[start-1] if start > 0 else new_solution[-1]\n        next_node = new_solution[start+seg_length] if start+seg_length < n-1 else new_solution[0]\n\n        # Calculate original costs\n        orig_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node]\n        orig_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node]\n        orig_cost3 = distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node]\n\n        # Calculate new costs if segment is inverted\n        inverted_segment = segment[::-1]\n        new_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n        new_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n        new_cost3 = distance_matrix_3[prev_node, inverted_segment[0]] + distance_matrix_3[inverted_segment[-1], next_node]\n\n        # Calculate total improvement\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2) + (orig_cost3 - new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_seg_start = start\n\n    if best_seg_start != -1:\n        # Invert the selected segment\n        segment = new_solution[best_seg_start:best_seg_start+seg_length]\n        new_solution[best_seg_start:best_seg_start+seg_length] = segment[::-1]\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.5:\n        node_to_move = np.random.randint(0, n)\n        insertion_pos = np.random.randint(0, n-1)\n        if insertion_pos >= node_to_move:\n            insertion_pos += 1\n\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([\n            new_solution[:node_to_move],\n            new_solution[node_to_move+1:]\n        ])\n\n        new_solution = np.concatenate([\n            new_solution[:insertion_pos],\n            [node],\n            new_solution[insertion_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7187313203137371,
            4.341052377223969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives (lowest standard deviation)\n    objectives = np.array([obj for _, obj in archive])\n    std_devs = np.std(objectives, axis=1)\n    selected_idx = np.argmin(std_devs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective improvements for each segment\n    n = len(new_solution)\n    max_seg_length = min(5, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n\n    # Find segment that improves all objectives when inverted\n    best_seg_start = -1\n    best_improvement = -float('inf')\n\n    for start in range(n - seg_length):\n        segment = new_solution[start:start+seg_length]\n        prev_node = new_solution[start-1] if start > 0 else new_solution[-1]\n        next_node = new_solution[start+seg_length] if start+seg_length < n-1 else new_solution[0]\n\n        # Calculate original costs\n        orig_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node]\n        orig_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node]\n        orig_cost3 = distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node]\n\n        # Calculate new costs if segment is inverted\n        inverted_segment = segment[::-1]\n        new_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n        new_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n        new_cost3 = distance_matrix_3[prev_node, inverted_segment[0]] + distance_matrix_3[inverted_segment[-1], next_node]\n\n        # Calculate total improvement\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2) + (orig_cost3 - new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_seg_start = start\n\n    if best_seg_start != -1:\n        # Invert the selected segment\n        segment = new_solution[best_seg_start:best_seg_start+seg_length]\n        new_solution[best_seg_start:best_seg_start+seg_length] = segment[::-1]\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.5:\n        node_to_move = np.random.randint(0, n)\n        insertion_pos = np.random.randint(0, n-1)\n        if insertion_pos >= node_to_move:\n            insertion_pos += 1\n\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([\n            new_solution[:node_to_move],\n            new_solution[node_to_move+1:]\n        ])\n\n        new_solution = np.concatenate([\n            new_solution[:insertion_pos],\n            [node],\n            new_solution[insertion_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective diversity-aware selection strategy, then applies a hybrid local search that combines a novel adaptive segment inversion with a weighted node insertion heuristic, prioritizing objectives with higher variance in the archive while ensuring feasibility through a dynamic feasibility check mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    diversity_scores = np.dot(objectives, objective_variances)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion with weighted node insertion\n    n = len(new_solution)\n    segment_length = min(3, n//3)\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Adaptive segment inversion\n    segment = new_solution[start_pos:start_pos+segment_length]\n    inverted_segment = segment[::-1]\n    new_solution[start_pos:start_pos+segment_length] = inverted_segment\n\n    # Weighted node insertion\n    weights = objective_variances / np.sum(objective_variances)\n    removed_node = inverted_segment[np.random.randint(0, segment_length)]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start_pos and i < start_pos + segment_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Dynamic feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring the original segment\n        new_solution[start_pos:start_pos+segment_length] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6341744946982686,
            1.758176076412201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    diversity_scores = np.dot(objectives, objective_variances)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion with weighted node insertion\n    n = len(new_solution)\n    segment_length = min(3, n//3)\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Adaptive segment inversion\n    segment = new_solution[start_pos:start_pos+segment_length]\n    inverted_segment = segment[::-1]\n    new_solution[start_pos:start_pos+segment_length] = inverted_segment\n\n    # Weighted node insertion\n    weights = objective_variances / np.sum(objective_variances)\n    removed_node = inverted_segment[np.random.randint(0, segment_length)]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start_pos and i < start_pos + segment_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Dynamic feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring the original segment\n        new_solution[start_pos:start_pos+segment_length] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm combines multi-objective Pareto dominance with a novel adaptive segment-based local search that dynamically selects the objective to optimize based on the current solution's performance, using a hybrid approach of segment rotation and node insertion with segment length determined by the objective's relative importance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective importance weights based on normalized performance\n    norm_obj = (objectives[selected_idx] - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    obj_weights = 1 - norm_obj\n    obj_weights = obj_weights / obj_weights.sum()\n\n    # Select objective to optimize based on weights\n    obj_to_optimize = np.random.choice(3, p=obj_weights)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_to_optimize]\n\n    # Adaptive segment selection based on objective importance\n    n = len(new_solution)\n    seg_length = max(2, int(np.random.normal(3, 1.5)) + int(obj_weights[obj_to_optimize] * 4))\n    seg_length = min(seg_length, n//2)\n\n    # Select a random segment and rotate it\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the selected objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = distance_matrix[prev_node, removed_node] + distance_matrix[removed_node, next_node] - distance_matrix[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6905463247899764,
            1.3681172013282776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective importance weights based on normalized performance\n    norm_obj = (objectives[selected_idx] - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    obj_weights = 1 - norm_obj\n    obj_weights = obj_weights / obj_weights.sum()\n\n    # Select objective to optimize based on weights\n    obj_to_optimize = np.random.choice(3, p=obj_weights)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_to_optimize]\n\n    # Adaptive segment selection based on objective importance\n    n = len(new_solution)\n    seg_length = max(2, int(np.random.normal(3, 1.5)) + int(obj_weights[obj_to_optimize] * 4))\n    seg_length = min(seg_length, n//2)\n\n    # Select a random segment and rotate it\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the selected objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = distance_matrix[prev_node, removed_node] + distance_matrix[removed_node, next_node] - distance_matrix[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on the least crowded region in objective space, then applies a hybrid local search combining segment inversion, node swap, and a novel three-objective aware edge reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.linalg.norm(norm_obj - 0.5, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment inversion with objective-aware selection\n    segment = new_solution[i:j+1]\n    if len(segment) > 1:\n        if np.random.rand() < 0.3:  # 30% chance to reverse based on objective trade-off\n            obj_diff = np.array([distance_matrix_3[segment[k], segment[k+1]] - distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)])\n            if np.sum(obj_diff) > 0:\n                new_solution[i:j+1] = segment[::-1]\n\n    # Node swap with multi-objective consideration\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if k != l:\n        total_diff = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l], new_solution[(k+1)%n]])\n        if total_diff < 0 or np.random.rand() < 0.2:  # Accept if improvement or with 20% probability\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Edge reversal operator tailored for three objectives\n    if np.random.rand() < 0.1:  # 10% chance to apply\n        rev_start = np.random.randint(0, n)\n        rev_length = min(5, n-1)\n        rev_end = (rev_start + rev_length) % n\n        if rev_start < rev_end:\n            segment = new_solution[rev_start:rev_end]\n        else:\n            segment = np.concatenate([new_solution[rev_start:], new_solution[:rev_end]])\n\n        # Calculate objective differences for the segment\n        obj1_diff = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) - \\\n                    sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        obj2_diff = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) - \\\n                    sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        obj3_diff = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1)) - \\\n                    sum(distance_matrix_3[segment[i+1], segment[i]] for i in range(len(segment)-1))\n\n        # Accept if at least one objective improves\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0 or np.random.rand() < 0.15:\n            if rev_start < rev_end:\n                new_solution[rev_start:rev_end] = segment[::-1]\n            else:\n                reversed_segment = segment[::-1]\n                new_solution[rev_start:] = reversed_segment[:n-rev_start]\n                new_solution[:rev_end] = reversed_segment[n-rev_start:]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7515088939293937,
            4.307123470306396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.linalg.norm(norm_obj - 0.5, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment inversion with objective-aware selection\n    segment = new_solution[i:j+1]\n    if len(segment) > 1:\n        if np.random.rand() < 0.3:  # 30% chance to reverse based on objective trade-off\n            obj_diff = np.array([distance_matrix_3[segment[k], segment[k+1]] - distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)])\n            if np.sum(obj_diff) > 0:\n                new_solution[i:j+1] = segment[::-1]\n\n    # Node swap with multi-objective consideration\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if k != l:\n        total_diff = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l], new_solution[(k+1)%n]])\n        if total_diff < 0 or np.random.rand() < 0.2:  # Accept if improvement or with 20% probability\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Edge reversal operator tailored for three objectives\n    if np.random.rand() < 0.1:  # 10% chance to apply\n        rev_start = np.random.randint(0, n)\n        rev_length = min(5, n-1)\n        rev_end = (rev_start + rev_length) % n\n        if rev_start < rev_end:\n            segment = new_solution[rev_start:rev_end]\n        else:\n            segment = np.concatenate([new_solution[rev_start:], new_solution[:rev_end]])\n\n        # Calculate objective differences for the segment\n        obj1_diff = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) - \\\n                    sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        obj2_diff = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) - \\\n                    sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        obj3_diff = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1)) - \\\n                    sum(distance_matrix_3[segment[i+1], segment[i]] for i in range(len(segment)-1))\n\n        # Accept if at least one objective improves\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0 or np.random.rand() < 0.15:\n            if rev_start < rev_end:\n                new_solution[rev_start:rev_end] = segment[::-1]\n            else:\n                reversed_segment = segment[::-1]\n                new_solution[rev_start:] = reversed_segment[:n-rev_start]\n                new_solution[:rev_end] = reversed_segment[n-rev_start:]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced trade-off across objectives, then applies a hybrid local search combining segment inversion and node swap to generate a neighbor solution while ensuring feasibility by checking for duplicate nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.749792888847973,
            3.1684930324554443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment relocation strategy that dynamically selects and repositions segments based on objective performance, followed by a targeted node repositioning that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection, and incorporates a novel segment rotation operator to further explore the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and relocation\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Relocate segment with probability based on objective performance\n    if np.random.random() < 0.6 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        target_pos = np.random.randint(0, n - seg_length)\n        if target_pos >= start:\n            target_pos += seg_length\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:target_pos],\n            segment,\n            new_solution[target_pos:]\n        ])\n\n    # Segment rotation\n    if np.random.random() < 0.4:\n        rotation = np.random.randint(1, seg_length)\n        segment = np.roll(segment, rotation)\n        new_solution[start:start+seg_length] = segment\n\n    # Targeted node repositioning\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6693408481234392,
            1.7901143312454224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and relocation\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Relocate segment with probability based on objective performance\n    if np.random.random() < 0.6 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        target_pos = np.random.randint(0, n - seg_length)\n        if target_pos >= start:\n            target_pos += seg_length\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:target_pos],\n            segment,\n            new_solution[target_pos:]\n        ])\n\n    # Segment rotation\n    if np.random.random() < 0.4:\n        rotation = np.random.randint(1, seg_length)\n        segment = np.roll(segment, rotation)\n        new_solution[start:start+seg_length] = segment\n\n    # Targeted node repositioning\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive path relinking strategy that dynamically selects and combines segments from different solutions based on objective performance, followed by a dominance-aware edge insertion that prioritizes improvement in the least dominated objective while maintaining feasibility through careful edge selection and dominance-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive path relinking with segment combination\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    # Select another solution from archive for segment exchange\n    other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0]\n\n    # Find similar segment in other solution\n    for i in range(len(other_solution) - seg_length + 1):\n        if np.array_equal(base_solution[start:start+seg_length], other_solution[i:i+seg_length]):\n            new_solution[start:start+seg_length] = other_solution[i:i+seg_length]\n            break\n\n    # Dominance-aware edge insertion\n    removed_edge = np.random.choice(range(n))\n    candidate_edges = []\n\n    for i in range(n):\n        if i == removed_edge or i == (removed_edge + 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n        removed_node = new_solution[removed_edge]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_edges.append((cost, i))\n\n    if candidate_edges:\n        candidate_edges.sort()\n        best_pos = candidate_edges[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_edge]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive path relinking strategy that dynamically selects and combines segments from different solutions based on objective performance, followed by a dominance-aware edge insertion that prioritizes improvement in the least dominated objective while maintaining feasibility through careful edge selection and dominance-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive path relinking with segment combination\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    # Select another solution from archive for segment exchange\n    other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0]\n\n    # Find similar segment in other solution\n    for i in range(len(other_solution) - seg_length + 1):\n        if np.array_equal(base_solution[start:start+seg_length], other_solution[i:i+seg_length]):\n            new_solution[start:start+seg_length] = other_solution[i:i+seg_length]\n            break\n\n    # Dominance-aware edge insertion\n    removed_edge = np.random.choice(range(n))\n    candidate_edges = []\n\n    for i in range(n):\n        if i == removed_edge or i == (removed_edge + 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n        removed_node = new_solution[removed_edge]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_edges.append((cost, i))\n\n    if candidate_edges:\n        candidate_edges.sort()\n        best_pos = candidate_edges[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_edge]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment exchange strategy that dynamically selects and combines segments from different solutions based on objective performance, followed by a dominance-aware node insertion that prioritizes improvement in the most improved objective while maintaining feasibility through careful node selection and dominance-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement (lowest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    best_obj = objectives[selected_idx]\n    most_improved = np.argmin(best_obj)\n\n    # Adaptive segment exchange with segment combination\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    # Select another solution from archive for segment exchange\n    other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0]\n\n    # Find similar segment in other solution and exchange\n    for i in range(len(other_solution) - seg_length + 1):\n        if np.array_equal(base_solution[start:start+seg_length], other_solution[i:i+seg_length]):\n            new_solution[start:start+seg_length] = other_solution[i:i+seg_length]\n            break\n\n    # Dominance-aware node insertion\n    removed_node = np.random.choice(range(n))\n    candidate_positions = []\n\n    for i in range(n):\n        if i == removed_node or i == (removed_node - 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i]\n        node = new_solution[removed_node]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_positions.append((cost, i))\n\n    if candidate_positions:\n        candidate_positions.sort()\n        best_pos = candidate_positions[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_node]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.660772800436489,
            2.009432578086853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement (lowest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    best_obj = objectives[selected_idx]\n    most_improved = np.argmin(best_obj)\n\n    # Adaptive segment exchange with segment combination\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n\n    # Select another solution from archive for segment exchange\n    other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0]\n\n    # Find similar segment in other solution and exchange\n    for i in range(len(other_solution) - seg_length + 1):\n        if np.array_equal(base_solution[start:start+seg_length], other_solution[i:i+seg_length]):\n            new_solution[start:start+seg_length] = other_solution[i:i+seg_length]\n            break\n\n    # Dominance-aware node insertion\n    removed_node = np.random.choice(range(n))\n    candidate_positions = []\n\n    for i in range(n):\n        if i == removed_node or i == (removed_node - 1) % n:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i]\n        node = new_solution[removed_node]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        candidate_positions.append((cost, i))\n\n    if candidate_positions:\n        candidate_positions.sort()\n        best_pos = candidate_positions[0][1]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[removed_node]],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators, with a focus on balancing exploration and exploitation through adaptive segment lengths and objective-aware segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a higher probability for better solutions\n    weights = [1.0 / (1 + sum(obj)) for _, obj in archive]\n    weights = np.array(weights) / sum(weights)\n    idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[idx][0].copy()\n\n    # Determine adaptive segment lengths based on solution diversity\n    n = len(base_solution)\n    seg_length = max(2, min(7, n // 4))\n\n    # Select a segment to modify\n    start = np.random.randint(0, n - seg_length)\n    segment = base_solution[start:start+seg_length]\n\n    # Generate a new segment by considering all three objectives\n    new_segment = segment.copy()\n    for i in range(seg_length):\n        # Select a node to swap based on objective improvement potential\n        node1 = segment[i]\n        best_node = node1\n        best_improvement = 0\n\n        for node2 in np.random.choice(n, min(5, n), replace=False):\n            if node2 in segment:\n                continue\n\n            # Calculate potential improvement across all three objectives\n            improvement = 0\n            for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n                if i > 0:\n                    improvement += dm[segment[i-1], node2] - dm[segment[i-1], node1]\n                if i < seg_length - 1:\n                    improvement += dm[node2, segment[i+1]] - dm[node1, segment[i+1]]\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_node = node2\n\n        new_segment[i] = best_node\n\n    # Create new solution by replacing the segment\n    new_solution = np.concatenate([\n        base_solution[:start],\n        new_segment,\n        base_solution[start+seg_length:]\n    ])\n\n    # Further optimize with a small probability of 2-opt\n    if np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6152086510513964,
            2.9816028118133544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a higher probability for better solutions\n    weights = [1.0 / (1 + sum(obj)) for _, obj in archive]\n    weights = np.array(weights) / sum(weights)\n    idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[idx][0].copy()\n\n    # Determine adaptive segment lengths based on solution diversity\n    n = len(base_solution)\n    seg_length = max(2, min(7, n // 4))\n\n    # Select a segment to modify\n    start = np.random.randint(0, n - seg_length)\n    segment = base_solution[start:start+seg_length]\n\n    # Generate a new segment by considering all three objectives\n    new_segment = segment.copy()\n    for i in range(seg_length):\n        # Select a node to swap based on objective improvement potential\n        node1 = segment[i]\n        best_node = node1\n        best_improvement = 0\n\n        for node2 in np.random.choice(n, min(5, n), replace=False):\n            if node2 in segment:\n                continue\n\n            # Calculate potential improvement across all three objectives\n            improvement = 0\n            for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n                if i > 0:\n                    improvement += dm[segment[i-1], node2] - dm[segment[i-1], node1]\n                if i < seg_length - 1:\n                    improvement += dm[node2, segment[i+1]] - dm[node1, segment[i+1]]\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_node = node2\n\n        new_segment[i] = best_node\n\n    # Create new solution by replacing the segment\n    new_solution = np.concatenate([\n        base_solution[:start],\n        new_segment,\n        base_solution[start+seg_length:]\n    ])\n\n    # Further optimize with a small probability of 2-opt\n    if np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.717270421433435,
            0.7420053482055664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This algorithm uses a hybrid approach combining segment reversal with adaptive node reinsertion, prioritizing the objective with the highest normalized improvement potential while dynamically adjusting segment length based on the current solution's performance across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    improvement_potential = 1 - normalized_obj\n    potential_scores = improvement_potential.mean(axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    improvement_scores = np.zeros(3)\n    for i in range(3):\n        if i == 0:\n            cost_diff = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]] + distance_matrix_1[new_solution[-1:], new_solution[:1]]) - np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]] + distance_matrix_1[base_solution[-1:], base_solution[:1]])\n        elif i == 1:\n            cost_diff = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]] + distance_matrix_2[new_solution[-1:], new_solution[:1]]) - np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]] + distance_matrix_2[base_solution[-1:], base_solution[:1]])\n        else:\n            cost_diff = np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]] + distance_matrix_3[new_solution[-1:], new_solution[:1]]) - np.sum(distance_matrix_3[base_solution[:-1], base_solution[1:]] + distance_matrix_3[base_solution[-1:], base_solution[:1]])\n        improvement_scores[i] = -cost_diff / objectives[selected_idx][i] if objectives[selected_idx][i] > 0 else 0\n\n    target_obj = np.argmax(improvement_scores)\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if target_obj == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif target_obj == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6894281952402219,
            2.047221040725708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    improvement_potential = 1 - normalized_obj\n    potential_scores = improvement_potential.mean(axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    improvement_scores = np.zeros(3)\n    for i in range(3):\n        if i == 0:\n            cost_diff = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]] + distance_matrix_1[new_solution[-1:], new_solution[:1]]) - np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]] + distance_matrix_1[base_solution[-1:], base_solution[:1]])\n        elif i == 1:\n            cost_diff = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]] + distance_matrix_2[new_solution[-1:], new_solution[:1]]) - np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]] + distance_matrix_2[base_solution[-1:], base_solution[:1]])\n        else:\n            cost_diff = np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]] + distance_matrix_3[new_solution[-1:], new_solution[:1]]) - np.sum(distance_matrix_3[base_solution[:-1], base_solution[1:]] + distance_matrix_3[base_solution[-1:], base_solution[:1]])\n        improvement_scores[i] = -cost_diff / objectives[selected_idx][i] if objectives[selected_idx][i] > 0 else 0\n\n    target_obj = np.argmax(improvement_scores)\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if target_obj == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif target_obj == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel path-swapping mechanism that identifies and exchanges segments between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive segment validation and conflict resolution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7257307064174444,
            0.7975167036056519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    def combined_objective(obj):\n        return sum(obj)  # Simple sum for combined objective\n\n    archive_sorted = sorted(archive, key=lambda x: combined_objective(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Determine segment length based on solution size\n    n = len(base_solution)\n    seg_length = max(2, min(4, n // 4))\n\n    # Randomly select a segment and a position to insert it\n    start = np.random.randint(0, n - seg_length)\n    insert_pos = np.random.randint(0, n - seg_length)\n\n    # Extract the segment\n    segment = base_solution[start:start+seg_length]\n\n    # Create new solution by relocating the segment\n    new_solution = np.concatenate([\n        base_solution[:start],\n        base_solution[start+seg_length:]\n    ])\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the relocation improves any objective\n    base_obj = archive_sorted[0][1]\n    improved = False\n\n    # Calculate new objectives\n    def calculate_objective(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution) - 1):\n            total += distance_matrix[solution[i], solution[i+1]]\n        total += distance_matrix[solution[-1], solution[0]]\n        return total\n\n    new_obj1 = calculate_objective(new_solution, distance_matrix_1)\n    new_obj2 = calculate_objective(new_solution, distance_matrix_2)\n    new_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n    for i in range(3):\n        if [new_obj1, new_obj2, new_obj3][i] < base_obj[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6021221294350532,
            3.6218901753425596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    def combined_objective(obj):\n        return sum(obj)  # Simple sum for combined objective\n\n    archive_sorted = sorted(archive, key=lambda x: combined_objective(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Determine segment length based on solution size\n    n = len(base_solution)\n    seg_length = max(2, min(4, n // 4))\n\n    # Randomly select a segment and a position to insert it\n    start = np.random.randint(0, n - seg_length)\n    insert_pos = np.random.randint(0, n - seg_length)\n\n    # Extract the segment\n    segment = base_solution[start:start+seg_length]\n\n    # Create new solution by relocating the segment\n    new_solution = np.concatenate([\n        base_solution[:start],\n        base_solution[start+seg_length:]\n    ])\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the relocation improves any objective\n    base_obj = archive_sorted[0][1]\n    improved = False\n\n    # Calculate new objectives\n    def calculate_objective(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution) - 1):\n            total += distance_matrix[solution[i], solution[i+1]]\n        total += distance_matrix[solution[-1], solution[0]]\n        return total\n\n    new_obj1 = calculate_objective(new_solution, distance_matrix_1)\n    new_obj2 = calculate_objective(new_solution, distance_matrix_2)\n    new_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n    for i in range(3):\n        if [new_obj1, new_obj2, new_obj3][i] < base_obj[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel adaptive k-opt local search that dynamically selects the number of segments to modify, prioritizes improving the least dominant objective while maintaining feasibility, and uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))  # Randomly select k segments to modify\n\n    for _ in range(k):\n        # Select a random segment and reverse it\n        seg_length = np.random.randint(2, min(7, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+seg_length] = reversed_segment\n\n        # Reinsert the first node of the reversed segment to optimize the least dominant objective\n        removed_node = reversed_segment[0]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [removed_node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6783953517347053,
            1.0969277024269104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n//2))  # Randomly select k segments to modify\n\n    for _ in range(k):\n        # Select a random segment and reverse it\n        seg_length = np.random.randint(2, min(7, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+seg_length] = reversed_segment\n\n        # Reinsert the first node of the reversed segment to optimize the least dominant objective\n        removed_node = reversed_segment[0]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            if least_dominant == 0:\n                cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif least_dominant == 1:\n                cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [removed_node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.8 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6955425610768785,
            0.8461401224136352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.8 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the most critical objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest objective diversity (most spread across objectives)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most critical objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_critical = np.argmax(worst_obj)\n\n    # Adaptive segment selection and rotation\n    n = len(new_solution)\n    max_seg_length = min(15, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate segment with probability based on objective performance\n    if np.random.random() < 0.8 * (worst_obj[most_critical] / np.max(worst_obj)):\n        rotation = np.random.randint(1, seg_length)\n        new_solution[start:start+seg_length] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_critical == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_critical == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7191850739184626,
            1.0178884863853455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest objective diversity (most spread across objectives)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most critical objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_critical = np.argmax(worst_obj)\n\n    # Adaptive segment selection and rotation\n    n = len(new_solution)\n    max_seg_length = min(15, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate segment with probability based on objective performance\n    if np.random.random() < 0.8 * (worst_obj[most_critical] / np.max(worst_obj)):\n        rotation = np.random.randint(1, seg_length)\n        new_solution[start:start+seg_length] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_critical == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_critical == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and dominance, then applies a novel multi-objective-aware local search strategy that combines adaptive segment swapping with dynamic node insertion, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n\n    segment = new_solution[start:start+segment_length]\n    new_position = np.random.randint(0, n - segment_length)\n    if new_position >= start:\n        new_position += segment_length\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:new_position],\n        segment,\n        new_solution[new_position:]\n    ])\n\n    for _ in range(2):\n        node_to_insert = np.random.choice(new_solution)\n        insert_pos = np.random.randint(0, n)\n        if insert_pos > 0 and insert_pos < n:\n            prev_node = new_solution[insert_pos-1]\n            next_node = new_solution[insert_pos]\n            current_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n            new_costs = [\n                distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node],\n                distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node],\n                distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node]\n            ]\n            if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    [node_to_insert],\n                    new_solution[insert_pos:]\n                ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5658419680606469,
            2.8339868068695067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n\n    segment = new_solution[start:start+segment_length]\n    new_position = np.random.randint(0, n - segment_length)\n    if new_position >= start:\n        new_position += segment_length\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:new_position],\n        segment,\n        new_solution[new_position:]\n    ])\n\n    for _ in range(2):\n        node_to_insert = np.random.choice(new_solution)\n        insert_pos = np.random.randint(0, n)\n        if insert_pos > 0 and insert_pos < n:\n            prev_node = new_solution[insert_pos-1]\n            next_node = new_solution[insert_pos]\n            current_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n            new_costs = [\n                distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node],\n                distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node],\n                distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node]\n            ]\n            if sum(new_costs) < sum(current_costs) or np.random.random() < 0.2:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    [node_to_insert],\n                    new_solution[insert_pos:]\n                ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment rotation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Dynamic segment rotation based on distance improvement\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[k:l+1]\n    if np.random.rand() < 0.5:\n        new_solution[k:l+1] = np.roll(segment, np.random.randint(1, len(segment)))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.743581428360229,
            4.479079115390777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and segment rotation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Dynamic segment rotation based on distance improvement\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[k:l+1]\n    if np.random.rand() < 0.5:\n        new_solution[k:l+1] = np.roll(segment, np.random.randint(1, len(segment)))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment crossover strategy that dynamically selects and combines segments from multiple solutions in the archive, using a weighted combination of objectives to guide the crossover while maintaining feasibility and exploring the solution space through a novel segment merging approach.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple solutions from the archive\n    selected_indices = np.random.choice(len(archive), min(3, len(archive)), replace=False)\n    selected_solutions = [archive[i][0].copy() for i in selected_indices]\n\n    # Calculate weights based on objective trade-offs\n    objectives = np.array([archive[i][1] for i in selected_indices])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = objectives @ weights.T\n    best_idx = np.argmin(weighted_scores)\n    base_solution = selected_solutions[best_idx].copy()\n\n    # Determine segment lengths based on solution diversity\n    n = len(base_solution)\n    seg_length = max(2, min(5, n // 4))\n\n    # Extract segments from multiple solutions\n    segments = []\n    for sol in selected_solutions:\n        start = np.random.randint(0, n - seg_length)\n        segments.append(sol[start:start+seg_length])\n\n    # Create new solution by merging segments with dynamic ordering\n    new_solution = np.zeros_like(base_solution)\n    used_nodes = set()\n    position = 0\n\n    for seg in segments:\n        for node in seg:\n            if node not in used_nodes and position < n:\n                new_solution[position] = node\n                used_nodes.add(node)\n                position += 1\n\n    # Fill remaining positions with nodes not in any segment\n    remaining_nodes = [node for node in base_solution if node not in used_nodes]\n    for node in remaining_nodes:\n        if position < n:\n            new_solution[position] = node\n            position += 1\n\n    # Apply adaptive 2.5-opt move based on distance savings\n    if np.random.rand() < 0.3:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt move as fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7646594476845923,
            3.2658461809158323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple solutions from the archive\n    selected_indices = np.random.choice(len(archive), min(3, len(archive)), replace=False)\n    selected_solutions = [archive[i][0].copy() for i in selected_indices]\n\n    # Calculate weights based on objective trade-offs\n    objectives = np.array([archive[i][1] for i in selected_indices])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = objectives @ weights.T\n    best_idx = np.argmin(weighted_scores)\n    base_solution = selected_solutions[best_idx].copy()\n\n    # Determine segment lengths based on solution diversity\n    n = len(base_solution)\n    seg_length = max(2, min(5, n // 4))\n\n    # Extract segments from multiple solutions\n    segments = []\n    for sol in selected_solutions:\n        start = np.random.randint(0, n - seg_length)\n        segments.append(sol[start:start+seg_length])\n\n    # Create new solution by merging segments with dynamic ordering\n    new_solution = np.zeros_like(base_solution)\n    used_nodes = set()\n    position = 0\n\n    for seg in segments:\n        for node in seg:\n            if node not in used_nodes and position < n:\n                new_solution[position] = node\n                used_nodes.add(node)\n                position += 1\n\n    # Fill remaining positions with nodes not in any segment\n    remaining_nodes = [node for node in base_solution if node not in used_nodes]\n    for node in remaining_nodes:\n        if position < n:\n            new_solution[position] = node\n            position += 1\n\n    # Apply adaptive 2.5-opt move based on distance savings\n    if np.random.rand() < 0.3:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt move as fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel multi-objective-aware local search strategy that combines adaptive segment reversal with dynamic node swapping, ensuring feasibility while exploring diverse trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8276747005521683,
            4.270494532585144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    for _ in range(3):\n        a, b = np.random.choice(range(n), 2, replace=False)\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        if sum(new_costs) < sum(current_costs) or np.random.random() < 0.15:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware objective balance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange with objective-specific weights\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for each objective\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46544253091573207,
            3.6057770252227783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware objective balance\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange with objective-specific weights\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for each objective\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm uses a dominance-aware segment swapping strategy that dynamically selects segment lengths based on objective trade-offs, prioritizes the least improved objective for local optimization, and employs a hybrid of 2-opt and node reinsertion with adaptive segment selection to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//4))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Apply 2-opt on the swapped segments to optimize the least improved objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(start1, start1+seg_length):\n        for j in range(start2, start2+seg_length):\n            if i == j:\n                continue\n\n            # Calculate cost difference for the least improved objective\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_improved == 0:\n                delta = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                        (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            elif least_improved == 1:\n                delta = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                        (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            else:\n                delta = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                         distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                        (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                         distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8415409017524699,
            3.0242960453033447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//4))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Apply 2-opt on the swapped segments to optimize the least improved objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(start1, start1+seg_length):\n        for j in range(start2, start2+seg_length):\n            if i == j:\n                continue\n\n            # Calculate cost difference for the least improved objective\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_improved == 0:\n                delta = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                        (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            elif least_improved == 1:\n                delta = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                        (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            else:\n                delta = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                         distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                        (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                         distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    hypervolumes = np.prod(objectives, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with distance-based selection and segment rotation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate total distance savings across all objectives\n    def total_savings(sol, a, b, c, d):\n        savings = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            savings += (dm[sol[a], sol[b]] + dm[sol[c], sol[d]]) - (dm[sol[a], sol[c]] + dm[sol[b], sol[d]])\n        return savings\n\n    # Try 2-opt move if beneficial\n    if i < j - 1:\n        a, b, c, d = i, i+1, j, j+1 if j+1 < n else 0\n        if total_savings(new_solution, a, b, c, d) > 0:\n            new_solution[a+1:c+1] = new_solution[a+1:c+1][::-1]\n\n    # Segment rotation for multi-objective optimization\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, np.random.randint(1, segment_length))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6685816663171887,
            2.895402252674103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    hypervolumes = np.prod(objectives, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with distance-based selection and segment rotation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Calculate total distance savings across all objectives\n    def total_savings(sol, a, b, c, d):\n        savings = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            savings += (dm[sol[a], sol[b]] + dm[sol[c], sol[d]]) - (dm[sol[a], sol[c]] + dm[sol[b], sol[d]])\n        return savings\n\n    # Try 2-opt move if beneficial\n    if i < j - 1:\n        a, b, c, d = i, i+1, j, j+1 if j+1 < n else 0\n        if total_savings(new_solution, a, b, c, d) > 0:\n            new_solution[a+1:c+1] = new_solution[a+1:c+1][::-1]\n\n    # Segment rotation for multi-objective optimization\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, np.random.randint(1, segment_length))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel path-swapping mechanism that identifies and exchanges segments between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive segment validation and conflict resolution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm employs a multi-objective-aware segment reshuffling strategy that combines adaptive segment rotation with dominance-based segment selection, prioritizing the least improved objective while ensuring feasibility through a novel conflict resolution mechanism that considers all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the least improved objective\n    objectives = np.array([obj for _, obj in archive])\n    least_improved = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[least_improved][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[least_improved]\n    least_improved_obj = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Perform rotation (left or right)\n    if np.random.rand() < 0.5:\n        rotated_segment = np.roll(segment, 1)  # Left rotation\n    else:\n        rotated_segment = np.roll(segment, -1)  # Right rotation\n\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least improved objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_improved_obj == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_improved_obj == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7323027085082052,
            0.9729040026664734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the least improved objective\n    objectives = np.array([obj for _, obj in archive])\n    least_improved = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[least_improved][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[least_improved]\n    least_improved_obj = np.argmax(worst_obj)\n\n    # Select a random segment and rotate it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Perform rotation (left or right)\n    if np.random.rand() < 0.5:\n        rotated_segment = np.roll(segment, 1)  # Left rotation\n    else:\n        rotated_segment = np.roll(segment, -1)  # Right rotation\n\n    new_solution[start:start+seg_length] = rotated_segment\n\n    # Reinsert the first node of the rotated segment to optimize the least improved objective\n    removed_node = rotated_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_improved_obj == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_improved_obj == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{A novel heuristic function that selects a solution from the archive based on its objective diversity, then applies a multi-objective-aware local search operator combining segment inversion, node swap, and objective-weighted edge exchange to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.std(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-weighted edge exchange\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if k != l:\n        # Calculate edge costs in all objectives\n        cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[l], new_solution[k]] -\n                distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                distance_matrix_1[new_solution[l], new_solution[l-1]])\n\n        cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[l], new_solution[k]] -\n                distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                distance_matrix_2[new_solution[l], new_solution[l-1]])\n\n        cost3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                distance_matrix_3[new_solution[l], new_solution[k]] -\n                distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                distance_matrix_3[new_solution[l], new_solution[l-1]])\n\n        # Weighted acceptance probability\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < 0 or np.random.rand() < np.exp(-total_cost / 1000):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.49119928077123687,
            3.298053026199341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.std(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-weighted edge exchange\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if k != l:\n        # Calculate edge costs in all objectives\n        cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[l], new_solution[k]] -\n                distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                distance_matrix_1[new_solution[l], new_solution[l-1]])\n\n        cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[l], new_solution[k]] -\n                distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                distance_matrix_2[new_solution[l], new_solution[l-1]])\n\n        cost3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                distance_matrix_3[new_solution[l], new_solution[k]] -\n                distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                distance_matrix_3[new_solution[l], new_solution[l-1]])\n\n        # Weighted acceptance probability\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < 0 or np.random.rand() < np.exp(-total_cost / 1000):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This new algorithm employs a novel multi-objective adaptive k-opt local search that dynamically selects and optimizes segments of varying lengths (k) based on the solution's current objective trade-offs, combining segment reversal, insertion, and weighted node shifting to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.sum(objectives, axis=1) / np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = np.random.randint(2, min(6, n//2))  # Random segment length between 2 and min(6, n//2)\n\n    # Select a random segment\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    # Determine the operation to perform\n    operation = np.random.choice(['reversal', 'insertion', 'shift'])\n\n    if operation == 'reversal':\n        # Reverse the segment\n        new_solution[start:start+k] = segment[::-1]\n    elif operation == 'insertion':\n        # Remove the segment and insert it at a new position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:  # shift\n        # Shift the segment to a new position\n        shift_pos = np.random.randint(0, n - k)\n        if shift_pos != start:\n            # Remove the segment\n            temp = np.concatenate([new_solution[:start], new_solution[start+k:]])\n            # Insert the segment at the new position\n            new_solution = np.insert(temp, shift_pos, segment)\n\n    # Weighted node shifting for further optimization\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]]))\n\n        if cost < 0:\n            # Shift node_a to position after node_b\n            temp = new_solution[node_a]\n            new_solution = np.delete(new_solution, node_a)\n            new_solution = np.insert(new_solution, node_b, temp)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8272183185145142,
            3.4966559171676637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.sum(objectives, axis=1) / np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    k = np.random.randint(2, min(6, n//2))  # Random segment length between 2 and min(6, n//2)\n\n    # Select a random segment\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n\n    # Determine the operation to perform\n    operation = np.random.choice(['reversal', 'insertion', 'shift'])\n\n    if operation == 'reversal':\n        # Reverse the segment\n        new_solution[start:start+k] = segment[::-1]\n    elif operation == 'insertion':\n        # Remove the segment and insert it at a new position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:  # shift\n        # Shift the segment to a new position\n        shift_pos = np.random.randint(0, n - k)\n        if shift_pos != start:\n            # Remove the segment\n            temp = np.concatenate([new_solution[:start], new_solution[start+k:]])\n            # Insert the segment at the new position\n            new_solution = np.insert(temp, shift_pos, segment)\n\n    # Weighted node shifting for further optimization\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]]))\n\n        if cost < 0:\n            # Shift node_a to position after node_b\n            temp = new_solution[node_a]\n            new_solution = np.delete(new_solution, node_a)\n            new_solution = np.insert(new_solution, node_b, temp)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel path-swapping mechanism that identifies and exchanges segments between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive segment validation and conflict resolution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel adaptive segment exchange mechanism that dynamically selects and exchanges segments between solutions based on their objective performance, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection and conflict resolution through intelligent node redistribution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    tradeoff_scores = normalized_obj.mean(axis=1)\n    selected_idx = np.argmin(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the objective with the largest relative improvement potential\n    worst_obj = objectives[selected_idx]\n    obj_improvement = worst_obj / (objectives.mean(axis=0) + 1e-8)\n    target_obj = np.argmax(obj_improvement)\n\n    # Select adaptive segment length based on solution size and objective performance\n    n = len(new_solution)\n    seg_length = max(2, min(10, int(n * 0.3 * (1 - obj_improvement[target_obj]))))\n\n    # Perform segment exchange with another random solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        start1 = np.random.randint(0, n - seg_length)\n        start2 = np.random.randint(0, n - seg_length)\n        seg1 = new_solution[start1:start1+seg_length]\n        seg2 = other_solution[start2:start2+seg_length]\n\n        # Create new solution with exchanged segments\n        new_solution = np.concatenate([\n            new_solution[:start1],\n            seg2,\n            new_solution[start1+seg_length:]\n        ])\n\n        # Reinsert missing nodes intelligently\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        if len(missing_nodes) > 0:\n            # Insert missing nodes at positions that minimize the target objective\n            for node in missing_nodes:\n                best_pos = 0\n                min_cost = float('inf')\n                for i in range(1, len(new_solution)):\n                    if target_obj == 0:\n                        cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                    elif target_obj == 1:\n                        cost = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                    else:\n                        cost = distance_matrix_3[new_solution[i-1], node] + distance_matrix_3[node, new_solution[i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal with adaptive probability\n    if np.random.rand() < 0.4 * (1 - obj_improvement[target_obj]):\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference for target objective\n        prev_node = new_solution[start-1] if start > 0 else new_solution[-1]\n        next_node = new_solution[start+seg_length] if start+seg_length < n else new_solution[0]\n\n        if target_obj == 0:\n            original_cost = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            new_cost = distance_matrix_1[prev_node, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_node]\n        elif target_obj == 1:\n            original_cost = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n            new_cost = distance_matrix_2[prev_node, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_node]\n        else:\n            original_cost = distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node]\n            new_cost = distance_matrix_3[prev_node, reversed_segment[0]] + distance_matrix_3[reversed_segment[-1], next_node]\n\n        if new_cost < original_cost:\n            new_solution[start:start+seg_length] = reversed_segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6651490667875407,
            2.2458155751228333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    tradeoff_scores = normalized_obj.mean(axis=1)\n    selected_idx = np.argmin(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the objective with the largest relative improvement potential\n    worst_obj = objectives[selected_idx]\n    obj_improvement = worst_obj / (objectives.mean(axis=0) + 1e-8)\n    target_obj = np.argmax(obj_improvement)\n\n    # Select adaptive segment length based on solution size and objective performance\n    n = len(new_solution)\n    seg_length = max(2, min(10, int(n * 0.3 * (1 - obj_improvement[target_obj]))))\n\n    # Perform segment exchange with another random solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        start1 = np.random.randint(0, n - seg_length)\n        start2 = np.random.randint(0, n - seg_length)\n        seg1 = new_solution[start1:start1+seg_length]\n        seg2 = other_solution[start2:start2+seg_length]\n\n        # Create new solution with exchanged segments\n        new_solution = np.concatenate([\n            new_solution[:start1],\n            seg2,\n            new_solution[start1+seg_length:]\n        ])\n\n        # Reinsert missing nodes intelligently\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        if len(missing_nodes) > 0:\n            # Insert missing nodes at positions that minimize the target objective\n            for node in missing_nodes:\n                best_pos = 0\n                min_cost = float('inf')\n                for i in range(1, len(new_solution)):\n                    if target_obj == 0:\n                        cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                    elif target_obj == 1:\n                        cost = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                    else:\n                        cost = distance_matrix_3[new_solution[i-1], node] + distance_matrix_3[node, new_solution[i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal with adaptive probability\n    if np.random.rand() < 0.4 * (1 - obj_improvement[target_obj]):\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference for target objective\n        prev_node = new_solution[start-1] if start > 0 else new_solution[-1]\n        next_node = new_solution[start+seg_length] if start+seg_length < n else new_solution[0]\n\n        if target_obj == 0:\n            original_cost = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            new_cost = distance_matrix_1[prev_node, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_node]\n        elif target_obj == 1:\n            original_cost = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n            new_cost = distance_matrix_2[prev_node, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_node]\n        else:\n            original_cost = distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node]\n            new_cost = distance_matrix_3[prev_node, reversed_segment[0]] + distance_matrix_3[reversed_segment[-1], next_node]\n\n        if new_cost < original_cost:\n            new_solution[start:start+seg_length] = reversed_segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm employs a multi-objective adaptive path relinking strategy that combines solution segments from diverse non-dominated solutions while prioritizing improvement in the least dominant objective through a weighted segment insertion mechanism, ensuring feasibility through a novel node reallocation procedure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two diverse solutions from the archive\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_indices = np.argsort(diversity_scores)[-2:]\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Create a new solution by combining segments from both solutions\n    n = len(sol1)\n    split_point = np.random.randint(1, n-1)\n    new_solution = np.concatenate([sol1[:split_point], sol2[split_point:]])\n\n    # Identify the least dominant objective for the new solution\n    new_obj = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() + distance_matrix_1[new_solution[-1], new_solution[0]],\n               distance_matrix_2[new_solution[:-1], new_solution[1:]].sum() + distance_matrix_2[new_solution[-1], new_solution[0]],\n               distance_matrix_3[new_solution[:-1], new_solution[1:]].sum() + distance_matrix_3[new_solution[-1], new_solution[0]])\n    least_dominant = np.argmax(new_obj)\n\n    # Apply weighted segment insertion based on the least dominant objective\n    if np.random.random() < 0.7:  # 70% chance of applying the operation\n        seg_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Calculate insertion weights based on the least dominant objective\n        weights = []\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n            if least_dominant == 0:\n                w = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]\n            elif least_dominant == 1:\n                w = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]]\n            else:\n                w = distance_matrix_3[new_solution[i-1], segment[0]] + distance_matrix_3[segment[-1], new_solution[i]] - distance_matrix_3[new_solution[i-1], new_solution[i]]\n            weights.append((i, w))\n\n        weights.sort(key=lambda x: x[1])\n        best_pos = weights[0][0] if weights else start\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility by removing duplicates\n    unique_nodes = []\n    seen = set()\n    for node in new_solution:\n        if node not in seen:\n            seen.add(node)\n            unique_nodes.append(node)\n\n    # Reconstruct the solution if duplicates were found\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - seen\n        new_solution = np.array(unique_nodes + list(missing_nodes))\n\n    return new_solution\n\n",
        "score": [
            -0.6093593069155256,
            3.5734767436981203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two diverse solutions from the archive\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_indices = np.argsort(diversity_scores)[-2:]\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Create a new solution by combining segments from both solutions\n    n = len(sol1)\n    split_point = np.random.randint(1, n-1)\n    new_solution = np.concatenate([sol1[:split_point], sol2[split_point:]])\n\n    # Identify the least dominant objective for the new solution\n    new_obj = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() + distance_matrix_1[new_solution[-1], new_solution[0]],\n               distance_matrix_2[new_solution[:-1], new_solution[1:]].sum() + distance_matrix_2[new_solution[-1], new_solution[0]],\n               distance_matrix_3[new_solution[:-1], new_solution[1:]].sum() + distance_matrix_3[new_solution[-1], new_solution[0]])\n    least_dominant = np.argmax(new_obj)\n\n    # Apply weighted segment insertion based on the least dominant objective\n    if np.random.random() < 0.7:  # 70% chance of applying the operation\n        seg_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Calculate insertion weights based on the least dominant objective\n        weights = []\n        for i in range(n):\n            if i >= start and i < start + seg_length:\n                continue\n            if least_dominant == 0:\n                w = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]\n            elif least_dominant == 1:\n                w = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]]\n            else:\n                w = distance_matrix_3[new_solution[i-1], segment[0]] + distance_matrix_3[segment[-1], new_solution[i]] - distance_matrix_3[new_solution[i-1], new_solution[i]]\n            weights.append((i, w))\n\n        weights.sort(key=lambda x: x[1])\n        best_pos = weights[0][0] if weights else start\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility by removing duplicates\n    unique_nodes = []\n    seen = set()\n    for node in new_solution:\n        if node not in seen:\n            seen.add(node)\n            unique_nodes.append(node)\n\n    # Reconstruct the solution if duplicates were found\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - seen\n        new_solution = np.array(unique_nodes + list(missing_nodes))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective dominance analysis with a novel path-swapping mechanism that identifies and exchanges segments between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive segment validation and conflict resolution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select segments from each solution\n    n = len(sol1)\n    seg_length = np.random.randint(3, min(8, n//3))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start1+seg_length+seg_length],\n        seg1,\n        sol1[start1+seg_length+seg_length:]\n    ])\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        # If both have same least dominant objective, randomly choose one\n        least_dom = least_dom1\n    else:\n        # Otherwise, choose the one with better objective value\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply segment inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_start = np.random.randint(0, n - seg_length)\n        invert_end = invert_start + seg_length\n        inverted_segment = new_solution[invert_start:invert_end][::-1]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_start-1] if invert_start > 0 else new_solution[-1]\n        next_node = new_solution[invert_end] if invert_end < n else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = (distance_matrix_1[prev_node, new_solution[invert_start]] +\n                            distance_matrix_1[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                       distance_matrix_1[inverted_segment[-1], next_node])\n        elif least_dom == 1:\n            original_cost = (distance_matrix_2[prev_node, new_solution[invert_start]] +\n                            distance_matrix_2[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                       distance_matrix_2[inverted_segment[-1], next_node])\n        else:\n            original_cost = (distance_matrix_3[prev_node, new_solution[invert_start]] +\n                            distance_matrix_3[new_solution[invert_end-1], next_node])\n            new_cost = (distance_matrix_3[prev_node, inverted_segment[0]] +\n                       distance_matrix_3[inverted_segment[-1], next_node])\n\n        if new_cost < original_cost:\n            new_solution[invert_start:invert_end] = inverted_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel node-swapping mechanism that identifies and exchanges critical nodes between different solutions in the archive to create a hybrid tour, prioritizing improvement in the least dominant objective while maintaining feasibility through adaptive node validation and conflict resolution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select critical nodes from each solution\n    n = len(sol1)\n    critical_nodes1 = np.random.choice(sol1, size=3, replace=False)\n    critical_nodes2 = np.random.choice(sol2, size=3, replace=False)\n\n    # Create new solution by swapping critical nodes\n    new_solution = sol1.copy()\n    for i in range(3):\n        pos1 = np.where(new_solution == critical_nodes1[i])[0][0]\n        pos2 = np.where(new_solution == critical_nodes2[i])[0][0]\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        least_dom = least_dom1\n    else:\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply node inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_pos = np.random.randint(0, n)\n        inverted_node = new_solution[invert_pos]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_pos-1] if invert_pos > 0 else new_solution[-1]\n        next_node = new_solution[invert_pos+1] if invert_pos < n-1 else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = distance_matrix_1[prev_node, inverted_node] + distance_matrix_1[inverted_node, next_node]\n            new_cost = distance_matrix_1[prev_node, next_node]\n        elif least_dom == 1:\n            original_cost = distance_matrix_2[prev_node, inverted_node] + distance_matrix_2[inverted_node, next_node]\n            new_cost = distance_matrix_2[prev_node, next_node]\n        else:\n            original_cost = distance_matrix_3[prev_node, inverted_node] + distance_matrix_3[inverted_node, next_node]\n            new_cost = distance_matrix_3[prev_node, next_node]\n\n        if new_cost < original_cost:\n            new_solution = np.delete(new_solution, invert_pos)\n\n    return new_solution\n\n",
        "score": [
            -0.7092193085312654,
            2.901766264438629
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from archive\n    selected_indices = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Identify least dominant objective for each solution\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[selected_indices[0]], objectives[selected_indices[1]]\n    least_dom1, least_dom2 = np.argmax(obj1), np.argmax(obj2)\n\n    # Select critical nodes from each solution\n    n = len(sol1)\n    critical_nodes1 = np.random.choice(sol1, size=3, replace=False)\n    critical_nodes2 = np.random.choice(sol2, size=3, replace=False)\n\n    # Create new solution by swapping critical nodes\n    new_solution = sol1.copy()\n    for i in range(3):\n        pos1 = np.where(new_solution == critical_nodes1[i])[0][0]\n        pos2 = np.where(new_solution == critical_nodes2[i])[0][0]\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Resolve conflicts and ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Trim to original length\n    new_solution = new_solution[:n]\n\n    # Prioritize improvement in least dominant objective\n    if least_dom1 == least_dom2:\n        least_dom = least_dom1\n    else:\n        least_dom = least_dom1 if obj1[least_dom1] < obj2[least_dom2] else least_dom2\n\n    # Apply node inversion if it improves the least dominant objective\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        invert_pos = np.random.randint(0, n)\n        inverted_node = new_solution[invert_pos]\n\n        # Calculate cost difference\n        prev_node = new_solution[invert_pos-1] if invert_pos > 0 else new_solution[-1]\n        next_node = new_solution[invert_pos+1] if invert_pos < n-1 else new_solution[0]\n\n        if least_dom == 0:\n            original_cost = distance_matrix_1[prev_node, inverted_node] + distance_matrix_1[inverted_node, next_node]\n            new_cost = distance_matrix_1[prev_node, next_node]\n        elif least_dom == 1:\n            original_cost = distance_matrix_2[prev_node, inverted_node] + distance_matrix_2[inverted_node, next_node]\n            new_cost = distance_matrix_2[prev_node, next_node]\n        else:\n            original_cost = distance_matrix_3[prev_node, inverted_node] + distance_matrix_3[inverted_node, next_node]\n            new_cost = distance_matrix_3[prev_node, next_node]\n\n        if new_cost < original_cost:\n            new_solution = np.delete(new_solution, invert_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7020854534148383,
            0.5440329551696778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7020854534148383,
            0.5440329551696778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the most balanced trade-off across objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selected_idx = np.argmin(np.std(norm_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm combines multi-objective dominance analysis with a novel segment-based local search that prioritizes improving the least dominant objective while maintaining feasibility, using a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, and further enhances it by incorporating a dynamic objective weighting mechanism that adjusts based on the relative performance of each objective across the archive to guide the search more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weights based on objective performance\n    mean_obj = objectives.mean(axis=0)\n    std_obj = objectives.std(axis=0)\n    dynamic_weights = std_obj / (mean_obj + 1e-10)  # Higher weight for objectives with higher variance\n    dynamic_weights = dynamic_weights / dynamic_weights.sum()  # Normalize\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = dynamic_weights[0] * cost1 + dynamic_weights[1] * cost2 + dynamic_weights[2] * cost3\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6585213061015027,
            0.9348120331764221
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weights based on objective performance\n    mean_obj = objectives.mean(axis=0)\n    std_obj = objectives.std(axis=0)\n    dynamic_weights = std_obj / (mean_obj + 1e-10)  # Higher weight for objectives with higher variance\n    dynamic_weights = dynamic_weights / dynamic_weights.sum()  # Normalize\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the least dominant objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = dynamic_weights[0] * cost1 + dynamic_weights[1] * cost2 + dynamic_weights[2] * cost3\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment crossover strategy that dynamically combines segments from different solutions based on their objective performance, followed by a dominance-aware node reinsertion that prioritizes improvement in the most underperforming objective while ensuring feasibility through segment length balancing and objective-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most underperforming objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_underperforming = np.argmax(worst_obj)\n\n    # Adaptive segment crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        n = len(new_solution)\n        max_seg_length = min(8, n // 3)\n        seg_length = np.random.randint(2, max_seg_length + 1)\n        start = np.random.randint(0, n - seg_length)\n\n        # Select segment from other solution based on objective performance\n        if np.random.random() < 0.6 * (worst_obj[most_underperforming] / np.max(worst_obj)):\n            segment = other_solution[start:start+seg_length]\n            new_solution[start:start+seg_length] = segment\n\n    # Dominance-aware node reinsertion\n    removed_node = np.random.choice(new_solution)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == removed_node:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < len(new_solution)-1 else new_solution[0]\n\n        if most_underperforming == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_underperforming == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            np.delete(new_solution, np.where(new_solution == removed_node)[0][0])\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7193983246237159,
            1.9402674674987792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most underperforming objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_underperforming = np.argmax(worst_obj)\n\n    # Adaptive segment crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        n = len(new_solution)\n        max_seg_length = min(8, n // 3)\n        seg_length = np.random.randint(2, max_seg_length + 1)\n        start = np.random.randint(0, n - seg_length)\n\n        # Select segment from other solution based on objective performance\n        if np.random.random() < 0.6 * (worst_obj[most_underperforming] / np.max(worst_obj)):\n            segment = other_solution[start:start+seg_length]\n            new_solution[start:start+seg_length] = segment\n\n    # Dominance-aware node reinsertion\n    removed_node = np.random.choice(new_solution)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == removed_node:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < len(new_solution)-1 else new_solution[0]\n\n        if most_underperforming == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_underperforming == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            np.delete(new_solution, np.where(new_solution == removed_node)[0][0])\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment insertion strategy that dynamically selects and inserts segments from diverse solutions in the archive, using a weighted combination of objectives to guide the insertion while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a preference for those with better trade-offs\n    weights = np.array([np.random.random() for _ in archive])\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Determine segment length based on solution size\n    n = len(base_solution)\n    seg_length = max(2, min(5, n // 4))\n\n    # Randomly select segments from other solutions in the archive\n    other_indices = [i for i in range(len(archive)) if i != selected_idx]\n    if not other_indices:\n        other_indices = [selected_idx]\n    donor_idx = np.random.choice(other_indices)\n    donor_solution = archive[donor_idx][0].copy()\n\n    # Find a segment in the donor solution that improves at least one objective\n    best_segment = None\n    best_improvement = 0\n\n    for _ in range(5):  # Try up to 5 random segments\n        start = np.random.randint(0, n - seg_length)\n        segment = donor_solution[start:start+seg_length]\n\n        # Calculate the improvement if this segment is inserted\n        improvement = 0\n        for i in range(3):\n            obj1 = archive[selected_idx][1][i]\n            obj2 = sum(distance_matrix_1[donor_solution[j], donor_solution[j+1]] for j in range(start, start+seg_length-1))\n            if i == 1:\n                obj2 = sum(distance_matrix_2[donor_solution[j], donor_solution[j+1]] for j in range(start, start+seg_length-1))\n            elif i == 2:\n                obj2 = sum(distance_matrix_3[donor_solution[j], donor_solution[j+1]] for j in range(start, start+seg_length-1))\n            improvement += obj1 - obj2\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_segment = segment\n\n    if best_segment is not None:\n        # Insert the best segment at a random position\n        insert_pos = np.random.randint(0, n - seg_length)\n        new_solution = np.concatenate([\n            base_solution[:insert_pos],\n            best_segment,\n            base_solution[insert_pos:]\n        ])\n\n        # Remove duplicates while maintaining tour validity\n        unique, indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(indices)]\n        if len(new_solution) < n:\n            # Add missing nodes at random positions\n            missing = np.setdiff1d(base_solution, new_solution)\n            for node in missing:\n                pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, pos, node)\n    else:\n        # If no improving segment found, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:k+1],\n            base_solution[i:j],\n            base_solution[k+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7820542582273368,
            3.7411476016044616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a preference for those with better trade-offs\n    weights = np.array([np.random.random() for _ in archive])\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Determine segment length based on solution size\n    n = len(base_solution)\n    seg_length = max(2, min(5, n // 4))\n\n    # Randomly select segments from other solutions in the archive\n    other_indices = [i for i in range(len(archive)) if i != selected_idx]\n    if not other_indices:\n        other_indices = [selected_idx]\n    donor_idx = np.random.choice(other_indices)\n    donor_solution = archive[donor_idx][0].copy()\n\n    # Find a segment in the donor solution that improves at least one objective\n    best_segment = None\n    best_improvement = 0\n\n    for _ in range(5):  # Try up to 5 random segments\n        start = np.random.randint(0, n - seg_length)\n        segment = donor_solution[start:start+seg_length]\n\n        # Calculate the improvement if this segment is inserted\n        improvement = 0\n        for i in range(3):\n            obj1 = archive[selected_idx][1][i]\n            obj2 = sum(distance_matrix_1[donor_solution[j], donor_solution[j+1]] for j in range(start, start+seg_length-1))\n            if i == 1:\n                obj2 = sum(distance_matrix_2[donor_solution[j], donor_solution[j+1]] for j in range(start, start+seg_length-1))\n            elif i == 2:\n                obj2 = sum(distance_matrix_3[donor_solution[j], donor_solution[j+1]] for j in range(start, start+seg_length-1))\n            improvement += obj1 - obj2\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_segment = segment\n\n    if best_segment is not None:\n        # Insert the best segment at a random position\n        insert_pos = np.random.randint(0, n - seg_length)\n        new_solution = np.concatenate([\n            base_solution[:insert_pos],\n            best_segment,\n            base_solution[insert_pos:]\n        ])\n\n        # Remove duplicates while maintaining tour validity\n        unique, indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(indices)]\n        if len(new_solution) < n:\n            # Add missing nodes at random positions\n            missing = np.setdiff1d(base_solution, new_solution)\n            for node in missing:\n                pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, pos, node)\n    else:\n        # If no improving segment found, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:k+1],\n            base_solution[i:j],\n            base_solution[k+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm employs a novel multi-objective path inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a hybrid node exchange mechanism that combines 2-opt and 3-opt moves to simultaneously improve all three objectives while maintaining feasibility through dominance-based segment selection and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    if np.random.random() < 0.5:\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        if i < start < j < start + seg_length < k:\n            pass\n        else:\n            new_segment = new_solution[i:j+1][::-1]\n            new_solution[i:j+1] = new_segment\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n        if i < start < j < start + seg_length:\n            pass\n        else:\n            new_segment = new_solution[i:j+1][::-1]\n            new_solution[i:j+1] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.651093688386358,
            2.4526727199554443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    if np.random.random() < 0.5:\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        if i < start < j < start + seg_length < k:\n            pass\n        else:\n            new_segment = new_solution[i:j+1][::-1]\n            new_solution[i:j+1] = new_segment\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = sorted([i, j])\n        if i < start < j < start + seg_length:\n            pass\n        else:\n            new_segment = new_solution[i:j+1][::-1]\n            new_solution[i:j+1] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm employs a multi-objective adaptive path swapping strategy that dynamically selects and swaps disjoint path segments between two solutions from the archive, followed by a targeted node relocation that prioritizes improvement in the most improved objective, while ensuring feasibility through dominance-based selection and careful segment length adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two diverse solutions from the archive\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    diversity_scores = np.max(ranks, axis=1) - np.min(ranks, axis=1)\n    selected_indices = np.argsort(diversity_scores)[-2:]\n    sol1, sol2 = archive[selected_indices[0]][0].copy(), archive[selected_indices[1]][0].copy()\n\n    # Adaptive path swapping\n    n = len(sol1)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Swap segments between solutions\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n    sol1[start1:start1+seg_length] = seg2\n    sol2[start2:start2+seg_length] = seg1\n\n    # Select the better solution based on most improved objective\n    obj1 = archive[selected_indices[0]][1]\n    obj2 = archive[selected_indices[1]][1]\n    improvements = np.array(obj1) - np.array(obj2)\n    most_improved = np.argmin(improvements)\n    new_solution = sol1 if improvements[most_improved] < 0 else sol2\n\n    # Targeted node relocation\n    removed_node = new_solution[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[1:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = archive[0][0].copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6814012729558513,
            4.31386216878891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two diverse solutions from the archive\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    diversity_scores = np.max(ranks, axis=1) - np.min(ranks, axis=1)\n    selected_indices = np.argsort(diversity_scores)[-2:]\n    sol1, sol2 = archive[selected_indices[0]][0].copy(), archive[selected_indices[1]][0].copy()\n\n    # Adaptive path swapping\n    n = len(sol1)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Swap segments between solutions\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n    sol1[start1:start1+seg_length] = seg2\n    sol2[start2:start2+seg_length] = seg1\n\n    # Select the better solution based on most improved objective\n    obj1 = archive[selected_indices[0]][1]\n    obj2 = archive[selected_indices[1]][1]\n    improvements = np.array(obj1) - np.array(obj2)\n    most_improved = np.argmin(improvements)\n    new_solution = sol1 if improvements[most_improved] < 0 else sol2\n\n    # Targeted node relocation\n    removed_node = new_solution[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[1:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = archive[0][0].copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment reordering strategy that dynamically selects and reorders segments based on their contribution to each objective, using a weighted combination of distance improvements to guide the reordering while maintaining feasibility and balancing trade-offs across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum(axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = max(3, min(7, n // 4))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Calculate segment contribution to each objective\n    segment_contributions = [0.0, 0.0, 0.0]\n    for i in range(seg_length - 1):\n        node1 = segment[i]\n        node2 = segment[i+1]\n        segment_contributions[0] += distance_matrix_1[node1, node2]\n        segment_contributions[1] += distance_matrix_2[node1, node2]\n        segment_contributions[2] += distance_matrix_3[node1, node2]\n\n    # Normalize contributions\n    total_contribution = sum(segment_contributions)\n    if total_contribution == 0:\n        weights = [1/3, 1/3, 1/3]\n    else:\n        weights = [c/total_contribution for c in segment_contributions]\n\n    # Reorder segment based on weighted objectives\n    if np.random.random() < 0.8:\n        # Sort segment nodes by weighted sum of distances\n        weighted_distances = np.zeros(seg_length)\n        for i in range(seg_length):\n            node = segment[i]\n            prev_node = segment[i-1] if i > 0 else new_solution[start-1] if start > 0 else new_solution[-1]\n            next_node = segment[i+1] if i < seg_length-1 else new_solution[start+seg_length] if start+seg_length < n else new_solution[0]\n\n            weighted_dist = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) +\n                            weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) +\n                            weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]))\n            weighted_distances[i] = weighted_dist\n\n        # Create new order based on weighted distances\n        new_order = np.argsort(weighted_distances)\n        reordered_segment = segment[new_order]\n\n        # Apply reordering with probability based on improvement potential\n        improvement_prob = 0.5 * (1 - min(segment_contributions) / max(segment_contributions))\n        if np.random.random() < improvement_prob:\n            new_solution[start:start+seg_length] = reordered_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6063242959403666,
            3.2913655996322633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum(axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    seg_length = max(3, min(7, n // 4))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Calculate segment contribution to each objective\n    segment_contributions = [0.0, 0.0, 0.0]\n    for i in range(seg_length - 1):\n        node1 = segment[i]\n        node2 = segment[i+1]\n        segment_contributions[0] += distance_matrix_1[node1, node2]\n        segment_contributions[1] += distance_matrix_2[node1, node2]\n        segment_contributions[2] += distance_matrix_3[node1, node2]\n\n    # Normalize contributions\n    total_contribution = sum(segment_contributions)\n    if total_contribution == 0:\n        weights = [1/3, 1/3, 1/3]\n    else:\n        weights = [c/total_contribution for c in segment_contributions]\n\n    # Reorder segment based on weighted objectives\n    if np.random.random() < 0.8:\n        # Sort segment nodes by weighted sum of distances\n        weighted_distances = np.zeros(seg_length)\n        for i in range(seg_length):\n            node = segment[i]\n            prev_node = segment[i-1] if i > 0 else new_solution[start-1] if start > 0 else new_solution[-1]\n            next_node = segment[i+1] if i < seg_length-1 else new_solution[start+seg_length] if start+seg_length < n else new_solution[0]\n\n            weighted_dist = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) +\n                            weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) +\n                            weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]))\n            weighted_distances[i] = weighted_dist\n\n        # Create new order based on weighted distances\n        new_order = np.argsort(weighted_distances)\n        reordered_segment = segment[new_order]\n\n        # Apply reordering with probability based on improvement potential\n        improvement_prob = 0.5 * (1 - min(segment_contributions) / max(segment_contributions))\n        if np.random.random() < improvement_prob:\n            new_solution[start:start+seg_length] = reordered_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the most improved objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    improvement_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(ranks.sum(axis=1) * improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    best_obj = objectives[selected_idx]\n    most_improved = np.argmin(best_obj)\n\n    # Adaptive segment selection and rotation\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate segment with probability based on objective improvement\n    rotation = np.random.randint(1, seg_length)\n    if np.random.random() < 0.6 * (1 - best_obj[most_improved] / np.max(best_obj)):\n        new_solution[start:start+seg_length] = np.roll(segment, rotation)\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7170952216663553,
            1.2085929751396178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    improvement_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(ranks.sum(axis=1) * improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    best_obj = objectives[selected_idx]\n    most_improved = np.argmin(best_obj)\n\n    # Adaptive segment selection and rotation\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate segment with probability based on objective improvement\n    rotation = np.random.randint(1, seg_length)\n    if np.random.random() < 0.6 * (1 - best_obj[most_improved] / np.max(best_obj)):\n        new_solution[start:start+seg_length] = np.roll(segment, rotation)\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm employs a hybrid of 2-opt and adaptive node swapping, where it first selects a solution based on crowding distance in objective space to balance exploration, then applies a dynamic segment swap operation that prioritizes the objective with the highest improvement potential while ensuring feasibility through a dominance check and a novel segment inversion strategy that considers all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(7, n//2))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length]\n    segment2 = new_solution[start2:start2+seg_length]\n\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Reinsert nodes to optimize the most improved objective\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n-1):\n            if i == node_pos or i+1 == node_pos:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-2 else new_solution[0]\n\n            if most_improved == 0:\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif most_improved == 1:\n                cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos+1],\n                [node],\n                new_solution[best_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6889091601085361,
            3.765720248222351
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(7, n//2))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length]\n    segment2 = new_solution[start2:start2+seg_length]\n\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Reinsert nodes to optimize the most improved objective\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n-1):\n            if i == node_pos or i+1 == node_pos:\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-2 else new_solution[0]\n\n            if most_improved == 0:\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            elif most_improved == 1:\n                cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos+1],\n                [node],\n                new_solution[best_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity metric that combines normalized objective values with a Pareto front approximation, then applies a hybrid local search that combines a multi-objective k-opt move with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility through a dynamic feasibility check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1) * np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective k-opt with weighted node insertion\n    n = len(new_solution)\n    k = np.random.randint(3, min(6, n//2))\n\n    # Select k random positions\n    positions = sorted(np.random.choice(range(n), k, replace=False))\n\n    # Perform k-opt move\n    for i in range(len(positions)-1):\n        if positions[i+1] - positions[i] > 1:\n            new_solution[positions[i]:positions[i+1]] = new_solution[positions[i]:positions[i+1]][::-1]\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i in positions:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[node_to_insert]],\n            np.delete(new_solution, node_to_insert)\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5691968760172206,
            1.6254305481910705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1) * np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective k-opt with weighted node insertion\n    n = len(new_solution)\n    k = np.random.randint(3, min(6, n//2))\n\n    # Select k random positions\n    positions = sorted(np.random.choice(range(n), k, replace=False))\n\n    # Perform k-opt move\n    for i in range(len(positions)-1):\n        if positions[i+1] - positions[i] > 1:\n            new_solution[positions[i]:positions[i+1]] = new_solution[positions[i]:positions[i+1]][::-1]\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node_to_insert = np.random.randint(0, n)\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i in positions:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = (weights[0] * (distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]) +\n                weights[1] * (distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]) +\n                weights[2] * (distance_matrix_3[prev_node, node_to_insert] + distance_matrix_3[node_to_insert, next_node] - distance_matrix_3[prev_node, next_node]))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [new_solution[node_to_insert]],\n            np.delete(new_solution, node_to_insert)\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.45733310441806657,
            3.225831937789917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and dynamic segment inversion\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n    # Dynamic segment inversion based on distance savings\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm employs a multi-objective dynamic segment reallocation strategy that adaptively selects and relocates segments of varying lengths based on objective-specific distance savings, followed by a probabilistic node exchange mechanism that prioritizes nodes with the highest potential for improvement across all objectives, while maintaining feasibility through dominance-aware segment boundary adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Calculate objective-specific savings for the segment\n    savings = np.zeros(3)\n    for i in range(seg_length - 1):\n        node1, node2 = segment[i], segment[i+1]\n        savings[0] += (distance_matrix_1[node1, node2] - distance_matrix_1[node1, node2])\n        savings[1] += (distance_matrix_2[node1, node2] - distance_matrix_2[node1, node2])\n        savings[2] += (distance_matrix_3[node1, node2] - distance_matrix_3[node1, node2])\n\n    # Select objective with highest savings\n    target_obj = np.argmax(savings)\n\n    # Relocate segment to a position that improves the target objective\n    best_pos = -1\n    best_savings = -float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if target_obj == 0:\n            current_cost = distance_matrix_1[prev_node, next_node]\n            new_cost = (distance_matrix_1[prev_node, segment[0]] +\n                        distance_matrix_1[segment[-1], next_node] -\n                        distance_matrix_1[segment[0], segment[-1]])\n            savings = current_cost - new_cost\n        elif target_obj == 1:\n            current_cost = distance_matrix_2[prev_node, next_node]\n            new_cost = (distance_matrix_2[prev_node, segment[0]] +\n                        distance_matrix_2[segment[-1], next_node] -\n                        distance_matrix_2[segment[0], segment[-1]])\n            savings = current_cost - new_cost\n        else:\n            current_cost = distance_matrix_3[prev_node, next_node]\n            new_cost = (distance_matrix_3[prev_node, segment[0]] +\n                        distance_matrix_3[segment[-1], next_node] -\n                        distance_matrix_3[segment[0], segment[-1]])\n            savings = current_cost - new_cost\n\n        if savings > best_savings:\n            best_savings = savings\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, range(start, start + seg_length))\n        ])\n\n    # Probabilistic node exchange\n    if np.random.rand() < 0.3:\n        node1, node2 = np.random.choice(range(n), 2, replace=False)\n        obj1 = (distance_matrix_1[node1, new_solution[node1-1]] + distance_matrix_1[node1, new_solution[(node1+1)%n]] +\n                distance_matrix_2[node1, new_solution[node1-1]] + distance_matrix_2[node1, new_solution[(node1+1)%n]] +\n                distance_matrix_3[node1, new_solution[node1-1]] + distance_matrix_3[node1, new_solution[(node1+1)%n]])\n        obj2 = (distance_matrix_1[node2, new_solution[node2-1]] + distance_matrix_1[node2, new_solution[(node2+1)%n]] +\n                distance_matrix_2[node2, new_solution[node2-1]] + distance_matrix_2[node2, new_solution[(node2+1)%n]] +\n                distance_matrix_3[node2, new_solution[node2-1]] + distance_matrix_3[node2, new_solution[(node2+1)%n]])\n\n        if obj1 > obj2:\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7011844523573627,
            0.8615048408508301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Calculate objective-specific savings for the segment\n    savings = np.zeros(3)\n    for i in range(seg_length - 1):\n        node1, node2 = segment[i], segment[i+1]\n        savings[0] += (distance_matrix_1[node1, node2] - distance_matrix_1[node1, node2])\n        savings[1] += (distance_matrix_2[node1, node2] - distance_matrix_2[node1, node2])\n        savings[2] += (distance_matrix_3[node1, node2] - distance_matrix_3[node1, node2])\n\n    # Select objective with highest savings\n    target_obj = np.argmax(savings)\n\n    # Relocate segment to a position that improves the target objective\n    best_pos = -1\n    best_savings = -float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if target_obj == 0:\n            current_cost = distance_matrix_1[prev_node, next_node]\n            new_cost = (distance_matrix_1[prev_node, segment[0]] +\n                        distance_matrix_1[segment[-1], next_node] -\n                        distance_matrix_1[segment[0], segment[-1]])\n            savings = current_cost - new_cost\n        elif target_obj == 1:\n            current_cost = distance_matrix_2[prev_node, next_node]\n            new_cost = (distance_matrix_2[prev_node, segment[0]] +\n                        distance_matrix_2[segment[-1], next_node] -\n                        distance_matrix_2[segment[0], segment[-1]])\n            savings = current_cost - new_cost\n        else:\n            current_cost = distance_matrix_3[prev_node, next_node]\n            new_cost = (distance_matrix_3[prev_node, segment[0]] +\n                        distance_matrix_3[segment[-1], next_node] -\n                        distance_matrix_3[segment[0], segment[-1]])\n            savings = current_cost - new_cost\n\n        if savings > best_savings:\n            best_savings = savings\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, range(start, start + seg_length))\n        ])\n\n    # Probabilistic node exchange\n    if np.random.rand() < 0.3:\n        node1, node2 = np.random.choice(range(n), 2, replace=False)\n        obj1 = (distance_matrix_1[node1, new_solution[node1-1]] + distance_matrix_1[node1, new_solution[(node1+1)%n]] +\n                distance_matrix_2[node1, new_solution[node1-1]] + distance_matrix_2[node1, new_solution[(node1+1)%n]] +\n                distance_matrix_3[node1, new_solution[node1-1]] + distance_matrix_3[node1, new_solution[(node1+1)%n]])\n        obj2 = (distance_matrix_1[node2, new_solution[node2-1]] + distance_matrix_1[node2, new_solution[(node2+1)%n]] +\n                distance_matrix_2[node2, new_solution[node2-1]] + distance_matrix_2[node2, new_solution[(node2+1)%n]] +\n                distance_matrix_3[node2, new_solution[node2-1]] + distance_matrix_3[node2, new_solution[(node2+1)%n]])\n\n        if obj1 > obj2:\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This new algorithm uses a hybrid approach of node swapping and segment inversion with dynamic segment length selection based on objective dominance, prioritizing the least improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = objectives.sum(axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Swap two nodes to optimize the least improved objective\n    i, j = np.random.choice(n, 2, replace=False)\n    if least_improved == 0:\n        cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n    elif least_improved == 1:\n        cost_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n    else:\n        cost_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    if cost_diff < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3976940514611533,
            2.949214243888855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = objectives.sum(axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//2))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Swap two nodes to optimize the least improved objective\n    i, j = np.random.choice(n, 2, replace=False)\n    if least_improved == 0:\n        cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n    elif least_improved == 1:\n        cost_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n    else:\n        cost_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    if cost_diff < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6518555022284254,
            0.8806143641471863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    inverted_segment = segment[::-1]\n    new_solution[start:start+seg_length] = inverted_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment relocation strategy that dynamically selects and relocates segments between solutions in the archive, using a weighted combination of objectives to guide the relocation, while maintaining feasibility and exploring the solution space through a combination of segment moves and node swaps to improve solution quality across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with higher probability for those with better combined objective values\n    objectives = [obj for _, obj in archive]\n    weights = [1 / (sum(obj) + 1e-6) for obj in objectives]  # Inverse of sum of objectives as weight\n    idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    seg_length = max(2, min(5, n // 4))\n\n    # Randomly select a segment and a new position\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_pos = np.random.randint(0, n - seg_length)\n\n    # Extract the segment and insert it at the new position\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[end:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the relocation improves any objective\n    original_obj = archive[idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    )\n\n    improved = any(new_obj[i] < original_obj[i] for i in range(3))\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7530917094339576,
            1.8365997672080994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with higher probability for those with better combined objective values\n    objectives = [obj for _, obj in archive]\n    weights = [1 / (sum(obj) + 1e-6) for obj in objectives]  # Inverse of sum of objectives as weight\n    idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    seg_length = max(2, min(5, n // 4))\n\n    # Randomly select a segment and a new position\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_pos = np.random.randint(0, n - seg_length)\n\n    # Extract the segment and insert it at the new position\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[end:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the relocation improves any objective\n    original_obj = archive[idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    )\n\n    improved = any(new_obj[i] < original_obj[i] for i in range(3))\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a multi-objective segment insertion with a weighted node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment insertion\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[(pos+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[(pos+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_3[new_solution[pos-1], new_solution[(pos+1)%n]]))\n\n        if cost < 0:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4888390443307154,
            2.4884255051612856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best diversity-aware objective score\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment insertion with weighted node insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform segment insertion\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Weighted node insertion\n    weights = np.random.rand(3)\n    node = np.random.randint(0, n)\n    pos = np.random.randint(0, n)\n\n    if pos != node:\n        cost = (weights[0] * (distance_matrix_1[new_solution[pos-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[(pos+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[pos-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[(pos+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[pos-1], new_solution[node]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]] -\n                distance_matrix_3[new_solution[pos-1], new_solution[(pos+1)%n]]))\n\n        if cost < 0:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a trade-off-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective segment reversal with a weighted node exchange heuristic to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    tradeoff_scores = np.mean(objectives, axis=1) - np.max(objectives, axis=1)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective segment reversal with weighted node exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Weighted node exchange\n    weights = np.random.rand(3)\n    node_a = np.random.randint(0, n)\n    node_b = np.random.randint(0, n)\n\n    if node_a != node_b:\n        cost = (weights[0] * (distance_matrix_1[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_1[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_1[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_1[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_1[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_1[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_1[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[1] * (distance_matrix_2[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_2[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_2[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_2[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_2[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_2[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_2[new_solution[node_b], new_solution[(node_b+1)%n]]) +\n                weights[2] * (distance_matrix_3[new_solution[node_a-1], new_solution[node_b]] + distance_matrix_3[new_solution[node_b], new_solution[(node_a+1)%n]] +\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_a]] + distance_matrix_3[new_solution[node_a], new_solution[(node_b+1)%n]] -\n                distance_matrix_3[new_solution[node_a-1], new_solution[node_a]] - distance_matrix_3[new_solution[node_a], new_solution[(node_a+1)%n]] -\n                distance_matrix_3[new_solution[node_b-1], new_solution[node_b]] - distance_matrix_3[new_solution[node_b], new_solution[(node_b+1)%n]]))\n\n        if cost < 0:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective selection strategy, then applies a hybrid local search that combines a novel multi-objective node clustering with a dynamic segment inversion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node clustering with dynamic segment inversion\n    n = len(new_solution)\n    cluster_size = max(2, n // 5)\n    cluster_start = np.random.randint(0, n - cluster_size + 1)\n    cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n    # Dynamic segment inversion based on objective weights\n    weights = np.random.dirichlet(np.ones(3))\n    inversion_cost = 0\n\n    for i in range(cluster_size - 1):\n        inversion_cost += (weights[0] * (distance_matrix_1[cluster[i], cluster[i+1]] - distance_matrix_1[cluster[i+1], cluster[i]]) +\n                           weights[1] * (distance_matrix_2[cluster[i], cluster[i+1]] - distance_matrix_2[cluster[i+1], cluster[i]]) +\n                           weights[2] * (distance_matrix_3[cluster[i], cluster[i+1]] - distance_matrix_3[cluster[i+1], cluster[i]]))\n\n    if inversion_cost < 0:\n        new_solution[cluster_start:cluster_start+cluster_size] = cluster[::-1]\n\n    # Node clustering optimization\n    cluster_center = np.random.choice(cluster)\n    for i in range(n):\n        if i >= cluster_start and i < cluster_start + cluster_size:\n            continue\n\n        node = new_solution[i]\n        cost = (weights[0] * (distance_matrix_1[node, cluster_center] + distance_matrix_1[cluster_center, node] -\n                             distance_matrix_1[new_solution[i-1], node] - distance_matrix_1[node, new_solution[(i+1)%n]]) +\n                weights[1] * (distance_matrix_2[node, cluster_center] + distance_matrix_2[cluster_center, node] -\n                             distance_matrix_2[new_solution[i-1], node] - distance_matrix_2[node, new_solution[(i+1)%n]]) +\n                weights[2] * (distance_matrix_3[node, cluster_center] + distance_matrix_3[cluster_center, node] -\n                             distance_matrix_3[new_solution[i-1], node] - distance_matrix_3[node, new_solution[(i+1)%n]]))\n\n        if cost < 0:\n            # Insert node into cluster\n            new_solution = np.concatenate([new_solution[:cluster_start+1], [node], new_solution[cluster_start+1:i], new_solution[i+1:]])\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4404392705459522,
            1.8112065553665162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective node clustering with dynamic segment inversion\n    n = len(new_solution)\n    cluster_size = max(2, n // 5)\n    cluster_start = np.random.randint(0, n - cluster_size + 1)\n    cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n    # Dynamic segment inversion based on objective weights\n    weights = np.random.dirichlet(np.ones(3))\n    inversion_cost = 0\n\n    for i in range(cluster_size - 1):\n        inversion_cost += (weights[0] * (distance_matrix_1[cluster[i], cluster[i+1]] - distance_matrix_1[cluster[i+1], cluster[i]]) +\n                           weights[1] * (distance_matrix_2[cluster[i], cluster[i+1]] - distance_matrix_2[cluster[i+1], cluster[i]]) +\n                           weights[2] * (distance_matrix_3[cluster[i], cluster[i+1]] - distance_matrix_3[cluster[i+1], cluster[i]]))\n\n    if inversion_cost < 0:\n        new_solution[cluster_start:cluster_start+cluster_size] = cluster[::-1]\n\n    # Node clustering optimization\n    cluster_center = np.random.choice(cluster)\n    for i in range(n):\n        if i >= cluster_start and i < cluster_start + cluster_size:\n            continue\n\n        node = new_solution[i]\n        cost = (weights[0] * (distance_matrix_1[node, cluster_center] + distance_matrix_1[cluster_center, node] -\n                             distance_matrix_1[new_solution[i-1], node] - distance_matrix_1[node, new_solution[(i+1)%n]]) +\n                weights[1] * (distance_matrix_2[node, cluster_center] + distance_matrix_2[cluster_center, node] -\n                             distance_matrix_2[new_solution[i-1], node] - distance_matrix_2[node, new_solution[(i+1)%n]]) +\n                weights[2] * (distance_matrix_3[node, cluster_center] + distance_matrix_3[cluster_center, node] -\n                             distance_matrix_3[new_solution[i-1], node] - distance_matrix_3[node, new_solution[(i+1)%n]]))\n\n        if cost < 0:\n            # Insert node into cluster\n            new_solution = np.concatenate([new_solution[:cluster_start+1], [node], new_solution[cluster_start+1:i], new_solution[i+1:]])\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically selects and rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    rotation = np.random.randint(1, seg_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+seg_length] = rotated_segment\n\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm uses a hybrid approach of segment reversal and node reinsertion with adaptive segment length selection based on objective performance, prioritizing the most improved objective while maintaining feasibility through a dominance-based selection and a novel segment inversion strategy that considers all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=1) - objectives.sum(axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the most improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    most_improved = np.argmin(worst_obj)\n\n    # Select a random segment and reverse it\n    n = len(new_solution)\n    seg_length = np.random.randint(3, min(5, n//3))\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start+seg_length] = reversed_segment\n\n    # Reinsert the first node of the reversed segment to optimize the most improved objective\n    removed_node = reversed_segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if most_improved == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif most_improved == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm employs a novel hybrid approach combining multi-objective adaptive segment inversion with targeted node swapping, where segments are dynamically selected based on objective performance while prioritizing the least dominated objective, and node swaps are performed using a dominance-aware evaluation that considers all three objectives simultaneously to ensure balanced improvement across all objectives while maintaining tour feasibility through careful segment length adjustment and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    if np.random.rand() < 0.5:\n        inverted_segment = segment[::-1]\n    else:\n        rotation = np.random.randint(1, seg_length)\n        inverted_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    new_solution[start:start+seg_length] = inverted_segment\n\n    candidates = []\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n        candidates.append(i)\n\n    if not candidates:\n        return base_solution\n\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in candidates:\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = 0\n        if least_dominant == 0:\n            cost += distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost += distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost += distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node] - distance_matrix_3[prev_node, next_node]\n\n        for obj in range(3):\n            if obj == least_dominant:\n                continue\n            if obj == 0:\n                cost += distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node] - distance_matrix_1[prev_node, next_node]\n            elif obj == 1:\n                cost += distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost += distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < best_cost:\n            best_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_segment = new_solution[start:start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            new_segment,\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.646823403588046,
            1.3784647226333617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    n = len(new_solution)\n    max_seg_length = min(6, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    if np.random.rand() < 0.5:\n        inverted_segment = segment[::-1]\n    else:\n        rotation = np.random.randint(1, seg_length)\n        inverted_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    new_solution[start:start+seg_length] = inverted_segment\n\n    candidates = []\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n        candidates.append(i)\n\n    if not candidates:\n        return base_solution\n\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in candidates:\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        cost = 0\n        if least_dominant == 0:\n            cost += distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost += distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost += distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node] - distance_matrix_3[prev_node, next_node]\n\n        for obj in range(3):\n            if obj == least_dominant:\n                continue\n            if obj == 0:\n                cost += distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[start+seg_length-1], next_node] - distance_matrix_1[prev_node, next_node]\n            elif obj == 1:\n                cost += distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[start+seg_length-1], next_node] - distance_matrix_2[prev_node, next_node]\n            else:\n                cost += distance_matrix_3[prev_node, new_solution[start]] + distance_matrix_3[new_solution[start+seg_length-1], next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < best_cost:\n            best_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_segment = new_solution[start:start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            new_segment,\n            new_solution[best_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm uses a dominance-aware segment swapping strategy that dynamically selects segment lengths based on objective trade-offs, prioritizes the least improved objective for local optimization, and employs a hybrid of 2-opt and node reinsertion with adaptive segment selection to balance exploration and exploitation across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//4))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Apply 2-opt on the swapped segments to optimize the least improved objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(start1, start1+seg_length):\n        for j in range(start2, start2+seg_length):\n            if i == j:\n                continue\n\n            # Calculate cost difference for the least improved objective\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_improved == 0:\n                delta = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                        (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            elif least_improved == 1:\n                delta = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                        (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            else:\n                delta = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                         distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                        (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                         distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and inversion\n    n = len(new_solution)\n    max_seg_length = min(10, n // 2)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Invert segment with probability based on objective performance\n    if np.random.random() < 0.7 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        new_solution[start:start+seg_length] = segment[::-1]\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This algorithm employs a multi-objective adaptive segment rotation strategy that dynamically rotates segments based on objective performance, followed by a targeted node reinsertion that prioritizes improvement in the least dominated objective, while maintaining feasibility through careful segment length adjustment and dominance-based selection, and incorporates a novel segment rotation mechanism to explore diverse solution structures more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and rotation\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate segment with probability based on objective performance\n    if np.random.random() < 0.6 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        rotation = np.random.randint(1, seg_length)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+seg_length] = rotated_segment\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.727381017103227,
            0.9350101113319397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective dominance (lowest sum of ranks)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = ranks.sum(axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least dominant objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_dominant = np.argmax(worst_obj)\n\n    # Adaptive segment selection and rotation\n    n = len(new_solution)\n    max_seg_length = min(8, n // 3)\n    seg_length = np.random.randint(2, max_seg_length + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Rotate segment with probability based on objective performance\n    if np.random.random() < 0.6 * (worst_obj[least_dominant] / np.max(worst_obj)):\n        rotation = np.random.randint(1, seg_length)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+seg_length] = rotated_segment\n\n    # Targeted node reinsertion\n    removed_node = segment[0]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i < start + seg_length:\n            continue\n\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n        if least_dominant == 0:\n            cost = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n        elif least_dominant == 1:\n            cost = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, removed_node] + distance_matrix_3[removed_node, next_node] - distance_matrix_3[prev_node, next_node]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            [removed_node],\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a novel multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments between different solutions in the archive, using a weighted combination of objectives to guide the exchange while maintaining feasibility and exploring the solution space more effectively than standard local search operators.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two distinct solutions from the archive\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1 = archive[idx1][0].copy()\n    sol2 = archive[idx2][0].copy()\n\n    # Determine segment lengths based on solution quality\n    n = len(sol1)\n    seg_length = max(2, min(5, n // 3))\n\n    # Randomly select segments from both solutions\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n\n    # Extract segments\n    seg1 = sol1[start1:start1+seg_length]\n    seg2 = sol2[start2:start2+seg_length]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        sol1[:start1],\n        seg2,\n        sol1[start1+seg_length:start2],\n        seg1,\n        sol1[start2+seg_length:]\n    ])\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If segments overlap, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution = sol1.copy()\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Further optimize by checking if the exchange improves any objective\n    objectives1 = archive[idx1][1]\n    objectives2 = archive[idx2][1]\n\n    # Calculate objective improvements\n    improved = False\n    for i in range(3):\n        if objectives2[i] < objectives1[i]:\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm uses a dominance-aware segment swapping strategy that dynamically selects segment lengths based on objective trade-offs, prioritizes the least improved objective for local optimization, and employs a hybrid of 2-opt and node reinsertion with adaptive segment selection to balance exploration and exploitation across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmin(objective_ranges)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the least improved objective for this solution\n    worst_obj = objectives[selected_idx]\n    least_improved = np.argmax(worst_obj)\n\n    # Select two random segments and swap them\n    n = len(new_solution)\n    seg_length = np.random.randint(2, min(6, n//4))\n    start1 = np.random.randint(0, n - seg_length)\n    start2 = np.random.randint(0, n - seg_length)\n    while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n        start2 = np.random.randint(0, n - seg_length)\n\n    segment1 = new_solution[start1:start1+seg_length].copy()\n    segment2 = new_solution[start2:start2+seg_length].copy()\n    new_solution[start1:start1+seg_length] = segment2\n    new_solution[start2:start2+seg_length] = segment1\n\n    # Apply 2-opt on the swapped segments to optimize the least improved objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(start1, start1+seg_length):\n        for j in range(start2, start2+seg_length):\n            if i == j:\n                continue\n\n            # Calculate cost difference for the least improved objective\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j] if j < n-1 else new_solution[0]\n\n            if least_improved == 0:\n                delta = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) - \\\n                        (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            elif least_improved == 1:\n                delta = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]) - \\\n                        (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            else:\n                delta = (distance_matrix_3[prev_i, new_solution[j]] + distance_matrix_3[new_solution[j], next_i] +\n                         distance_matrix_3[prev_j, new_solution[i]] + distance_matrix_3[new_solution[i], next_j]) - \\\n                        (distance_matrix_3[prev_i, new_solution[i]] + distance_matrix_3[new_solution[i], next_i] +\n                         distance_matrix_3[prev_j, new_solution[j]] + distance_matrix_3[new_solution[j], next_j])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm employs a multi-objective adaptive path inversion strategy that dynamically selects and inverts segments of the tour while considering the trade-offs between objectives, using a weighted combination of objective improvements to guide the inversion process and balance exploration of the solution space with exploitation of promising regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    objective_weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(objectives, objective_weights)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine inversion segment based on objective trade-offs\n    n = len(base_solution)\n    seg_length = np.random.randint(2, min(8, n//2))\n    start = np.random.randint(0, n - seg_length)\n\n    # Calculate potential improvement for each objective\n    improvements = []\n    for obj_idx in range(3):\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        prev_node = base_solution[start-1] if start > 0 else base_solution[-1]\n        next_node = base_solution[start+seg_length] if start+seg_length < n else base_solution[0]\n\n        current_cost = dm[prev_node, base_solution[start]] + dm[base_solution[start+seg_length-1], next_node]\n        inverted_cost = dm[prev_node, base_solution[start+seg_length-1]] + dm[base_solution[start], next_node]\n\n        improvements.append(current_cost - inverted_cost)\n\n    # Weighted decision to invert based on potential improvements\n    improvement_weights = np.maximum(0, np.array(improvements))\n    if np.sum(improvement_weights) > 0:\n        improvement_weights = improvement_weights / np.sum(improvement_weights)\n    else:\n        improvement_weights = np.ones(3) / 3\n\n    if np.random.rand() < np.dot(improvement_weights, objective_weights):\n        # Perform the inversion\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If inversion causes duplicates, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.6445450167566895,
            3.619930148124695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    objective_weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(objectives, objective_weights)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine inversion segment based on objective trade-offs\n    n = len(base_solution)\n    seg_length = np.random.randint(2, min(8, n//2))\n    start = np.random.randint(0, n - seg_length)\n\n    # Calculate potential improvement for each objective\n    improvements = []\n    for obj_idx in range(3):\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        prev_node = base_solution[start-1] if start > 0 else base_solution[-1]\n        next_node = base_solution[start+seg_length] if start+seg_length < n else base_solution[0]\n\n        current_cost = dm[prev_node, base_solution[start]] + dm[base_solution[start+seg_length-1], next_node]\n        inverted_cost = dm[prev_node, base_solution[start+seg_length-1]] + dm[base_solution[start], next_node]\n\n        improvements.append(current_cost - inverted_cost)\n\n    # Weighted decision to invert based on potential improvements\n    improvement_weights = np.maximum(0, np.array(improvements))\n    if np.sum(improvement_weights) > 0:\n        improvement_weights = improvement_weights / np.sum(improvement_weights)\n    else:\n        improvement_weights = np.ones(3) / 3\n\n    if np.random.rand() < np.dot(improvement_weights, objective_weights):\n        # Perform the inversion\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If inversion causes duplicates, perform a simple swap instead\n        swap_pos = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n"
    }
]