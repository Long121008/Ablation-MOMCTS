[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i + 1 != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform edge insertion\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility by repairing if necessary\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6842166962733786,
            2.797532057762146
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the swap improves at least one objective, keep it\n    # Otherwise, try a different swap or revert to original\n    original_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    if sum(new_obj) < sum(original_obj):\n        return new_solution\n    else:\n        # Try a different 2-opt swap if the first one didn't improve\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.6158149239578572,
            3.0981446623802187
        ]
    }
]