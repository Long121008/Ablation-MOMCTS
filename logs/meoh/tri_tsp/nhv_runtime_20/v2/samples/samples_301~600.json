[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node-swapping heuristic that dynamically selects and swaps nodes based on their combined contributions across all objectives, using objective-aware swap evaluations with dynamic weights to promote balanced improvements while maintaining tour feasibility through intelligent node selection and conflict resolution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select two nodes for potential swap\n    i, j = random.sample(range(1, n-1), 2)\n\n    # Evaluate the impact of swapping nodes i and j\n    def evaluate_swap(a, b):\n        # Current connections: a-prev and a-next, b-prev and b-next\n        prev_a = new_solution[a-1]\n        next_a = new_solution[a+1] if a+1 < n else new_solution[0]\n        prev_b = new_solution[b-1]\n        next_b = new_solution[b+1] if b+1 < n else new_solution[0]\n\n        # Original costs\n        orig_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                      distance_matrix_1[new_solution[a], next_a] +\n                      distance_matrix_1[prev_b, new_solution[b]] +\n                      distance_matrix_1[new_solution[b], next_b])\n        orig_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                      distance_matrix_2[new_solution[a], next_a] +\n                      distance_matrix_2[prev_b, new_solution[b]] +\n                      distance_matrix_2[new_solution[b], next_b])\n        orig_cost3 = (distance_matrix_3[prev_a, new_solution[a]] +\n                      distance_matrix_3[new_solution[a], next_a] +\n                      distance_matrix_3[prev_b, new_solution[b]] +\n                      distance_matrix_3[new_solution[b], next_b])\n\n        # Swapped costs\n        swap_cost1 = (distance_matrix_1[prev_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[b], next_a] +\n                     distance_matrix_1[prev_b, new_solution[a]] +\n                     distance_matrix_1[new_solution[a], next_b])\n        swap_cost2 = (distance_matrix_2[prev_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[b], next_a] +\n                     distance_matrix_2[prev_b, new_solution[a]] +\n                     distance_matrix_2[new_solution[a], next_b])\n        swap_cost3 = (distance_matrix_3[prev_a, new_solution[b]] +\n                     distance_matrix_3[new_solution[b], next_a] +\n                     distance_matrix_3[prev_b, new_solution[a]] +\n                     distance_matrix_3[new_solution[a], next_b])\n\n        # Weighted improvement\n        improvement = (weights[0]*(orig_cost1 - swap_cost1) +\n                     weights[1]*(orig_cost2 - swap_cost2) +\n                     weights[2]*(orig_cost3 - swap_cost3))\n        return improvement\n\n    # Perform the swap if it improves the solution\n    improvement = evaluate_swap(i, j)\n    if improvement > 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional local improvement: check for 2-opt moves\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Reverse the segment between a and b\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7398891528053878,
            0.280070436000824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select two nodes for potential swap\n    i, j = random.sample(range(1, n-1), 2)\n\n    # Evaluate the impact of swapping nodes i and j\n    def evaluate_swap(a, b):\n        # Current connections: a-prev and a-next, b-prev and b-next\n        prev_a = new_solution[a-1]\n        next_a = new_solution[a+1] if a+1 < n else new_solution[0]\n        prev_b = new_solution[b-1]\n        next_b = new_solution[b+1] if b+1 < n else new_solution[0]\n\n        # Original costs\n        orig_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                      distance_matrix_1[new_solution[a], next_a] +\n                      distance_matrix_1[prev_b, new_solution[b]] +\n                      distance_matrix_1[new_solution[b], next_b])\n        orig_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                      distance_matrix_2[new_solution[a], next_a] +\n                      distance_matrix_2[prev_b, new_solution[b]] +\n                      distance_matrix_2[new_solution[b], next_b])\n        orig_cost3 = (distance_matrix_3[prev_a, new_solution[a]] +\n                      distance_matrix_3[new_solution[a], next_a] +\n                      distance_matrix_3[prev_b, new_solution[b]] +\n                      distance_matrix_3[new_solution[b], next_b])\n\n        # Swapped costs\n        swap_cost1 = (distance_matrix_1[prev_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[b], next_a] +\n                     distance_matrix_1[prev_b, new_solution[a]] +\n                     distance_matrix_1[new_solution[a], next_b])\n        swap_cost2 = (distance_matrix_2[prev_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[b], next_a] +\n                     distance_matrix_2[prev_b, new_solution[a]] +\n                     distance_matrix_2[new_solution[a], next_b])\n        swap_cost3 = (distance_matrix_3[prev_a, new_solution[b]] +\n                     distance_matrix_3[new_solution[b], next_a] +\n                     distance_matrix_3[prev_b, new_solution[a]] +\n                     distance_matrix_3[new_solution[a], next_b])\n\n        # Weighted improvement\n        improvement = (weights[0]*(orig_cost1 - swap_cost1) +\n                     weights[1]*(orig_cost2 - swap_cost2) +\n                     weights[2]*(orig_cost3 - swap_cost3))\n        return improvement\n\n    # Perform the swap if it improves the solution\n    improvement = evaluate_swap(i, j)\n    if improvement > 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional local improvement: check for 2-opt moves\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Reverse the segment between a and b\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a dynamic objective-weighted segmental perturbation strategy that adaptively selects and modifies tour segments based on node dominance in each objective space, performs segment-wise inversions and cross-segment merges with probability proportional to the node's relative contribution to each objective, and maintains feasibility through a circular permutation mechanism that ensures tour continuity while optimizing for all three objectives with adaptive weights and segmental dominance criteria.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.8 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node dominance swapping strategy that dynamically identifies and swaps nodes based on their relative dominance across objectives, using a weighted probability mechanism that favors swaps between nodes with complementary strengths in different objective spaces, while maintaining feasibility through a circular permutation mechanism to ensure valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dominance scores for each node\n    dominance_scores = np.zeros(n)\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate current edge costs\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Calculate potential improvement if swapped with neighbor\n        neighbor = new_solution[(i+1)%n]\n        new_cost1 = distance_matrix_1[prev_node, neighbor] + distance_matrix_1[neighbor, next_node]\n        new_cost2 = distance_matrix_2[prev_node, neighbor] + distance_matrix_2[neighbor, next_node]\n        new_cost3 = distance_matrix_3[prev_node, neighbor] + distance_matrix_3[neighbor, next_node]\n\n        # Calculate dominance score (how much better the swap would be)\n        dominance_scores[i] = (cost1 - new_cost1) + (cost2 - new_cost2) + (cost3 - new_cost3)\n\n    # Select nodes for potential swap based on dominance\n    if np.max(dominance_scores) > 0:\n        best_node = np.argmax(dominance_scores)\n        swap_candidate = (best_node + 1) % n\n\n        # Perform the swap\n        new_solution[best_node], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[best_node]\n\n    # Ensure the tour remains circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7162452311377574,
            0.5128161907196045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dominance scores for each node\n    dominance_scores = np.zeros(n)\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate current edge costs\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Calculate potential improvement if swapped with neighbor\n        neighbor = new_solution[(i+1)%n]\n        new_cost1 = distance_matrix_1[prev_node, neighbor] + distance_matrix_1[neighbor, next_node]\n        new_cost2 = distance_matrix_2[prev_node, neighbor] + distance_matrix_2[neighbor, next_node]\n        new_cost3 = distance_matrix_3[prev_node, neighbor] + distance_matrix_3[neighbor, next_node]\n\n        # Calculate dominance score (how much better the swap would be)\n        dominance_scores[i] = (cost1 - new_cost1) + (cost2 - new_cost2) + (cost3 - new_cost3)\n\n    # Select nodes for potential swap based on dominance\n    if np.max(dominance_scores) > 0:\n        best_node = np.argmax(dominance_scores)\n        swap_candidate = (best_node + 1) % n\n\n        # Perform the swap\n        new_solution[best_node], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[best_node]\n\n    # Ensure the tour remains circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware edge reversal and segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware edge reversal\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    # Accept reversal if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment inversion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution[k:] = new_solution[k:][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.4158884117032075,
            2.839262104034424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware edge reversal\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    # Accept reversal if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment inversion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution[k:] = new_solution[k:][::-1]\n\n    return new_solution\n\n"
    }
]