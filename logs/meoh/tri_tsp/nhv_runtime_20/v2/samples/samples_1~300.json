[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7188114819116691,
            1.8188122510910034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7188114819116691,
            1.8188122510910034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7188114819116691,
            1.8188122510910034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the objective space, then generates a neighbor by performing a multi-objective-aware edge insertion and deletion operation, ensuring feasibility while potentially improving all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (can be adjusted)\n    base_solution, _ = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Find the longest edge in any of the objective spaces\n    def edge_lengths(solution, matrix):\n        return [matrix[solution[i-1], solution[i]] for i in range(n)]\n\n    edges1 = edge_lengths(new_solution, distance_matrix_1)\n    edges2 = edge_lengths(new_solution, distance_matrix_2)\n    edges3 = edge_lengths(new_solution, distance_matrix_3)\n\n    # Find the index of the longest edge in any space\n    max_edge_idx = max(range(n), key=lambda i: max(edges1[i], edges2[i], edges3[i]))\n\n    # Remove the longest edge and insert it in a new position\n    node_a = new_solution[max_edge_idx - 1]\n    node_b = new_solution[max_edge_idx]\n\n    # Insert node_b after a random node (but not node_a) to maintain feasibility\n    insertion_pos = random.choice([i for i in range(n) if new_solution[i] != node_a and new_solution[i] != node_b])\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos + 1],\n        np.array([node_b]),\n        new_solution[insertion_pos + 1:max_edge_idx],\n        new_solution[max_edge_idx + 1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.726831508208732,
            2.772015929222107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (can be adjusted)\n    base_solution, _ = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Find the longest edge in any of the objective spaces\n    def edge_lengths(solution, matrix):\n        return [matrix[solution[i-1], solution[i]] for i in range(n)]\n\n    edges1 = edge_lengths(new_solution, distance_matrix_1)\n    edges2 = edge_lengths(new_solution, distance_matrix_2)\n    edges3 = edge_lengths(new_solution, distance_matrix_3)\n\n    # Find the index of the longest edge in any space\n    max_edge_idx = max(range(n), key=lambda i: max(edges1[i], edges2[i], edges3[i]))\n\n    # Remove the longest edge and insert it in a new position\n    node_a = new_solution[max_edge_idx - 1]\n    node_b = new_solution[max_edge_idx]\n\n    # Insert node_b after a random node (but not node_a) to maintain feasibility\n    insertion_pos = random.choice([i for i in range(n) if new_solution[i] != node_a and new_solution[i] != node_b])\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos + 1],\n        np.array([node_b]),\n        new_solution[insertion_pos + 1:max_edge_idx],\n        new_solution[max_edge_idx + 1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = min(archive, key=lambda x: max(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform a segment reversal and node insertion to improve the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find the best insertion point for a randomly selected node to improve the worst objective\n    node_to_insert = random.choice(new_solution)\n    best_insert_pos = i\n    best_insert_cost = float('inf')\n\n    for pos in range(n):\n        if pos == i:\n            continue  # Skip the current position to avoid unnecessary checks\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        temp_solution = np.delete(temp_solution, i if pos > i else i + 1)\n        cost = sum(distance_matrix[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        if cost < best_insert_cost:\n            best_insert_cost = cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n    new_solution = np.delete(new_solution, i if best_insert_pos > i else i + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7531815614756967,
            3.5943554282188415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = min(archive, key=lambda x: max(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform a segment reversal and node insertion to improve the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find the best insertion point for a randomly selected node to improve the worst objective\n    node_to_insert = random.choice(new_solution)\n    best_insert_pos = i\n    best_insert_cost = float('inf')\n\n    for pos in range(n):\n        if pos == i:\n            continue  # Skip the current position to avoid unnecessary checks\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        temp_solution = np.delete(temp_solution, i if pos > i else i + 1)\n        cost = sum(distance_matrix[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        if cost < best_insert_cost:\n            best_insert_cost = cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n    new_solution = np.delete(new_solution, i if best_insert_pos > i else i + 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = min(archive, key=lambda x: max(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform a segment reversal and node insertion to improve the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find the best insertion point for a randomly selected node to improve the worst objective\n    node_to_insert = random.choice(new_solution)\n    best_insert_pos = i\n    best_insert_cost = float('inf')\n\n    for pos in range(n):\n        if pos == i:\n            continue  # Skip the current position to avoid unnecessary checks\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        temp_solution = np.delete(temp_solution, i if pos > i else i + 1)\n        cost = sum(distance_matrix[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        if cost < best_insert_cost:\n            best_insert_cost = cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n    new_solution = np.delete(new_solution, i if best_insert_pos > i else i + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7531815614756967,
            3.5943554282188415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = min(archive, key=lambda x: max(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform a segment reversal and node insertion to improve the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find the best insertion point for a randomly selected node to improve the worst objective\n    node_to_insert = random.choice(new_solution)\n    best_insert_pos = i\n    best_insert_cost = float('inf')\n\n    for pos in range(n):\n        if pos == i:\n            continue  # Skip the current position to avoid unnecessary checks\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        temp_solution = np.delete(temp_solution, i if pos > i else i + 1)\n        cost = sum(distance_matrix[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        if cost < best_insert_cost:\n            best_insert_cost = cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n    new_solution = np.delete(new_solution, i if best_insert_pos > i else i + 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm selects a solution from the archive based on the average of its objectives, then applies a novel 3-segment rotation operator that cyclically shifts three randomly selected segments of the tour to create a neighbor solution, ensuring feasibility and potentially improving multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three distinct positions for segment rotation\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Split the tour into three segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Rotate the segments cyclically\n    new_solution = np.concatenate([segment2, segment3, segment4, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6570624236444197,
            4.243347227573395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three distinct positions for segment rotation\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Split the tour into three segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Rotate the segments cyclically\n    new_solution = np.concatenate([segment2, segment3, segment4, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a 3-opt local search to improve the solution\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i-j, j-k, and i-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Randomly perturb the solution by swapping a pair of nodes if it improves any objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7442115378482151,
            3.685063374042511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a 3-opt local search to improve the solution\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i-j, j-k, and i-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Randomly perturb the solution by swapping a pair of nodes if it improves any objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The new algorithm combines a multi-objective-aware segment reversal with a guided node insertion strategy to balance exploration of different objective spaces while maintaining feasibility, by intelligently selecting segments to reverse and inserting nodes based on their potential to improve multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 to balance exploration\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment reversal\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Evaluate segment quality across all objectives\n    segment_cost = 0\n    for i in range(start, end):\n        segment_cost += (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]])\n\n    # Reverse segment if it improves at least one objective\n    reversed_segment = new_solution[start:end][::-1]\n    new_segment_cost = 0\n    for i in range(len(reversed_segment)-1):\n        new_segment_cost += (distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] +\n                            distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] +\n                            distance_matrix_3[reversed_segment[i], reversed_segment[i+1]])\n\n    if new_segment_cost < segment_cost:\n        new_solution[start:end] = reversed_segment\n\n    # Guided node insertion to balance objectives\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n\n        # Calculate potential improvement across all objectives\n        old_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                    distance_matrix_3[new_solution[pos-1], new_solution[pos]] +\n                    distance_matrix_1[new_solution[node-1], new_solution[node]] +\n                    distance_matrix_2[new_solution[node-1], new_solution[node]] +\n                    distance_matrix_3[new_solution[node-1], new_solution[node]])\n\n        new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                    distance_matrix_1[node, new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[pos]] +\n                    distance_matrix_3[new_solution[pos-1], node] +\n                    distance_matrix_3[node, new_solution[pos]])\n\n        if new_cost < old_cost:\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.6808686106793677,
            4.170858132839203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 to balance exploration\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment reversal\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Evaluate segment quality across all objectives\n    segment_cost = 0\n    for i in range(start, end):\n        segment_cost += (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]])\n\n    # Reverse segment if it improves at least one objective\n    reversed_segment = new_solution[start:end][::-1]\n    new_segment_cost = 0\n    for i in range(len(reversed_segment)-1):\n        new_segment_cost += (distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] +\n                            distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] +\n                            distance_matrix_3[reversed_segment[i], reversed_segment[i+1]])\n\n    if new_segment_cost < segment_cost:\n        new_solution[start:end] = reversed_segment\n\n    # Guided node insertion to balance objectives\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n\n        # Calculate potential improvement across all objectives\n        old_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                    distance_matrix_3[new_solution[pos-1], new_solution[pos]] +\n                    distance_matrix_1[new_solution[node-1], new_solution[node]] +\n                    distance_matrix_2[new_solution[node-1], new_solution[node]] +\n                    distance_matrix_3[new_solution[node-1], new_solution[node]])\n\n        new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                    distance_matrix_1[node, new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[pos]] +\n                    distance_matrix_3[new_solution[pos-1], node] +\n                    distance_matrix_3[node, new_solution[pos]])\n\n        if new_cost < old_cost:\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = max(obj) - min(obj)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with random segment reversal and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.47594604996023904,
            3.3994994044303892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = max(obj) - min(obj)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with random segment reversal and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly select a segment to reverse if it improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Revert reversal if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7657823101995268,
            4.280471789836883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly select a segment to reverse if it improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Revert reversal if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly select a segment to reverse if it improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Revert reversal if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7657823101995268,
            4.280471789836883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly select a segment to reverse if it improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Revert reversal if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / 3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply a novel local search operator: reverse a randomly selected segment and then insert a randomly selected node at a new position\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6929967606433114,
            3.1458989500999452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / 3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply a novel local search operator: reverse a randomly selected segment and then insert a randomly selected node at a new position\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def hypervolume(obj):\n        return obj[0] * obj[1] * obj[2]\n\n    base_solution, _ = max(archive, key=lambda x: hypervolume(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a novel local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate edge costs in all three objectives\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Current edges\n    edges = [\n        edge_cost(new_solution[i-1], new_solution[i]),\n        edge_cost(new_solution[j-1], new_solution[j]),\n        edge_cost(new_solution[k-1], new_solution[k])\n    ]\n\n    # Possible new edges after 3-opt\n    new_edges = [\n        edge_cost(new_solution[i-1], new_solution[k]),\n        edge_cost(new_solution[j-1], new_solution[i]),\n        edge_cost(new_solution[k-1], new_solution[j])\n    ]\n\n    # Calculate total cost difference\n    total_diff = [\n        sum(new - old for new, old in zip(new_edges[l], edges[l])) for l in range(3)\n    ]\n\n    # Apply 3-opt if it improves at least one objective\n    if any(diff < 0 for diff in total_diff):\n        # Reorder the segment between i and k\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Additional random edge swap if it improves any objective\n    a, b = random.sample(range(n), 2)\n    original_edges = [\n        edge_cost(new_solution[a-1], new_solution[a]),\n        edge_cost(new_solution[b-1], new_solution[b])\n    ]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    new_edges = [\n        edge_cost(new_solution[a-1], new_solution[a]),\n        edge_cost(new_solution[b-1], new_solution[b])\n    ]\n\n    total_diff = [\n        sum(new - old for new, old in zip(new_edges[l], original_edges[l])) for l in range(2)\n    ]\n\n    if any(diff >= 0 for diff in total_diff):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6579925889848443,
            4.189819860458374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def hypervolume(obj):\n        return obj[0] * obj[1] * obj[2]\n\n    base_solution, _ = max(archive, key=lambda x: hypervolume(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a novel local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate edge costs in all three objectives\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Current edges\n    edges = [\n        edge_cost(new_solution[i-1], new_solution[i]),\n        edge_cost(new_solution[j-1], new_solution[j]),\n        edge_cost(new_solution[k-1], new_solution[k])\n    ]\n\n    # Possible new edges after 3-opt\n    new_edges = [\n        edge_cost(new_solution[i-1], new_solution[k]),\n        edge_cost(new_solution[j-1], new_solution[i]),\n        edge_cost(new_solution[k-1], new_solution[j])\n    ]\n\n    # Calculate total cost difference\n    total_diff = [\n        sum(new - old for new, old in zip(new_edges[l], edges[l])) for l in range(3)\n    ]\n\n    # Apply 3-opt if it improves at least one objective\n    if any(diff < 0 for diff in total_diff):\n        # Reorder the segment between i and k\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Additional random edge swap if it improves any objective\n    a, b = random.sample(range(n), 2)\n    original_edges = [\n        edge_cost(new_solution[a-1], new_solution[a]),\n        edge_cost(new_solution[b-1], new_solution[b])\n    ]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    new_edges = [\n        edge_cost(new_solution[a-1], new_solution[a]),\n        edge_cost(new_solution[b-1], new_solution[b])\n    ]\n\n    total_diff = [\n        sum(new - old for new, old in zip(new_edges[l], original_edges[l])) for l in range(2)\n    ]\n\n    if any(diff >= 0 for diff in total_diff):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 3-opt + weighted edge swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i-j, j-k, and i-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Randomly swap two nodes if it improves the weighted sum of objectives\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Calculate weights based on the relative importance of each objective\n    weights = [1.0 / (cost + 1e-6) for cost in original_costs]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Calculate weighted sums\n    original_weighted_sum = sum(w * c for w, c in zip(normalized_weights, original_costs))\n    new_weighted_sum = sum(w * c for w, c in zip(normalized_weights, new_costs))\n\n    # Revert swap if it doesn't improve the weighted sum\n    if new_weighted_sum >= original_weighted_sum:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7110086107193354,
            4.115798652172089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 3-opt + weighted edge swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i-j, j-k, and i-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Randomly swap two nodes if it improves the weighted sum of objectives\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Calculate weights based on the relative importance of each objective\n    weights = [1.0 / (cost + 1e-6) for cost in original_costs]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Calculate weighted sums\n    original_weighted_sum = sum(w * c for w, c in zip(normalized_weights, original_costs))\n    new_weighted_sum = sum(w * c for w, c in zip(normalized_weights, new_costs))\n\n    # Revert swap if it doesn't improve the weighted sum\n    if new_weighted_sum >= original_weighted_sum:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    # Apply a 3-opt local search to generate a neighbor\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i and j, and between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6201549115677796,
            3.6395696997642517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    # Apply a 3-opt local search to generate a neighbor\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i and j, and between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining 2-opt and edge insertion to generate a neighbor solution while ensuring feasibility and exploring diverse configurations across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a hybrid local search combining 2-opt and edge insertion\n    # First, apply 2-opt between two random segments\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform edge insertion for one random node\n    a = random.randint(0, n-1)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    b = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, b, node)\n\n    # Randomly swap two nodes to explore new configurations\n    c, d = random.sample(range(n), 2)\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.640427818232994,
            4.414667928218842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a hybrid local search combining 2-opt and edge insertion\n    # First, apply 2-opt between two random segments\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform edge insertion for one random node\n    a = random.randint(0, n-1)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    b = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, b, node)\n\n    # Randomly swap two nodes to explore new configurations\n    c, d = random.sample(range(n), 2)\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights for different objectives\n    selected_solution, _ = max(archive, key=lambda x: -sum(w * val for w, val in zip(weights, x[1])))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a 4-opt local search for multi-objective optimization\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Apply 4-opt: reverse segments between i-j, j-k, and k-l\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Randomly swap two nodes to explore new configurations\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7211478121799855,
            4.00631285905838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights for different objectives\n    selected_solution, _ = max(archive, key=lambda x: -sum(w * val for w, val in zip(weights, x[1])))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a 4-opt local search for multi-objective optimization\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Apply 4-opt: reverse segments between i-j, j-k, and k-l\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Randomly swap two nodes to explore new configurations\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt and node insertion to generate a neighbor solution, ensuring feasibility and exploring diverse configurations across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    selected_solution, _ = max(archive, key=lambda x: -sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt + node insertion\n    # First perform 2-opt\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform node insertion\n    if n > 3:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6563623232740413,
            4.383821105957031
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    selected_solution, _ = max(archive, key=lambda x: -sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt + node insertion\n    # First perform 2-opt\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform node insertion\n    if n > 3:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the objective space, then generates a neighbor by performing a multi-objective-aware edge insertion and deletion operation, ensuring feasibility while potentially improving all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (can be adjusted)\n    base_solution, _ = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Find the longest edge in any of the objective spaces\n    def edge_lengths(solution, matrix):\n        return [matrix[solution[i-1], solution[i]] for i in range(n)]\n\n    edges1 = edge_lengths(new_solution, distance_matrix_1)\n    edges2 = edge_lengths(new_solution, distance_matrix_2)\n    edges3 = edge_lengths(new_solution, distance_matrix_3)\n\n    # Find the index of the longest edge in any space\n    max_edge_idx = max(range(n), key=lambda i: max(edges1[i], edges2[i], edges3[i]))\n\n    # Remove the longest edge and insert it in a new position\n    node_a = new_solution[max_edge_idx - 1]\n    node_b = new_solution[max_edge_idx]\n\n    # Insert node_b after a random node (but not node_a) to maintain feasibility\n    insertion_pos = random.choice([i for i in range(n) if new_solution[i] != node_a and new_solution[i] != node_b])\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos + 1],\n        np.array([node_b]),\n        new_solution[insertion_pos + 1:max_edge_idx],\n        new_solution[max_edge_idx + 1:]\n    ])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the objective space, then generates a neighbor by performing a multi-objective-aware edge insertion and deletion operation, ensuring feasibility while potentially improving all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (can be adjusted)\n    base_solution, _ = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Find the longest edge in any of the objective spaces\n    def edge_lengths(solution, matrix):\n        return [matrix[solution[i-1], solution[i]] for i in range(n)]\n\n    edges1 = edge_lengths(new_solution, distance_matrix_1)\n    edges2 = edge_lengths(new_solution, distance_matrix_2)\n    edges3 = edge_lengths(new_solution, distance_matrix_3)\n\n    # Find the index of the longest edge in any space\n    max_edge_idx = max(range(n), key=lambda i: max(edges1[i], edges2[i], edges3[i]))\n\n    # Remove the longest edge and insert it in a new position\n    node_a = new_solution[max_edge_idx - 1]\n    node_b = new_solution[max_edge_idx]\n\n    # Insert node_b after a random node (but not node_a) to maintain feasibility\n    insertion_pos = random.choice([i for i in range(n) if new_solution[i] != node_a and new_solution[i] != node_b])\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos + 1],\n        np.array([node_b]),\n        new_solution[insertion_pos + 1:max_edge_idx],\n        new_solution[max_edge_idx + 1:]\n    ])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7997607720801532,
            3.6680373191833495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the objective space, then generates a neighbor by performing a multi-objective-aware edge insertion and deletion operation, ensuring feasibility while potentially improving all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (can be adjusted)\n    base_solution, _ = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Find the longest edge in any of the objective spaces\n    def edge_lengths(solution, matrix):\n        return [matrix[solution[i-1], solution[i]] for i in range(n)]\n\n    edges1 = edge_lengths(new_solution, distance_matrix_1)\n    edges2 = edge_lengths(new_solution, distance_matrix_2)\n    edges3 = edge_lengths(new_solution, distance_matrix_3)\n\n    # Find the index of the longest edge in any space\n    max_edge_idx = max(range(n), key=lambda i: max(edges1[i], edges2[i], edges3[i]))\n\n    # Remove the longest edge and insert it in a new position\n    node_a = new_solution[max_edge_idx - 1]\n    node_b = new_solution[max_edge_idx]\n\n    # Insert node_b after a random node (but not node_a) to maintain feasibility\n    insertion_pos = random.choice([i for i in range(n) if new_solution[i] != node_a and new_solution[i] != node_b])\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos + 1],\n        np.array([node_b]),\n        new_solution[insertion_pos + 1:max_edge_idx],\n        new_solution[max_edge_idx + 1:]\n    ])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the objective space, then generates a neighbor by performing a multi-objective-aware edge insertion and deletion operation, ensuring feasibility while potentially improving all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (can be adjusted)\n    base_solution, _ = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Find the longest edge in any of the objective spaces\n    def edge_lengths(solution, matrix):\n        return [matrix[solution[i-1], solution[i]] for i in range(n)]\n\n    edges1 = edge_lengths(new_solution, distance_matrix_1)\n    edges2 = edge_lengths(new_solution, distance_matrix_2)\n    edges3 = edge_lengths(new_solution, distance_matrix_3)\n\n    # Find the index of the longest edge in any space\n    max_edge_idx = max(range(n), key=lambda i: max(edges1[i], edges2[i], edges3[i]))\n\n    # Remove the longest edge and insert it in a new position\n    node_a = new_solution[max_edge_idx - 1]\n    node_b = new_solution[max_edge_idx]\n\n    # Insert node_b after a random node (but not node_a) to maintain feasibility\n    insertion_pos = random.choice([i for i in range(n) if new_solution[i] != node_a and new_solution[i] != node_b])\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos + 1],\n        np.array([node_b]),\n        new_solution[insertion_pos + 1:max_edge_idx],\n        new_solution[max_edge_idx + 1:]\n    ])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7997607720801532,
            3.6680373191833495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel 4-segment reversal and node exchange operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * (1 + random.uniform(0, 0.5)))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel 4-segment reversal operator\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Conditional node exchange based on objective improvement\n    i, j = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert if no improvement in any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7582421227365816,
            4.204605710506439
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]) * (1 + random.uniform(0, 0.5)))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel 4-segment reversal operator\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Conditional node exchange based on objective improvement\n    i, j = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert if no improvement in any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a 3-opt local search to improve the solution\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i-j, j-k, and i-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Randomly perturb the solution by swapping a pair of nodes if it improves any objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, objectives = min(archive, key=lambda x: max(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform a segment reversal and node insertion to improve the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find the best insertion point for a randomly selected node to improve the worst objective\n    node_to_insert = random.choice(new_solution)\n    best_insert_pos = i\n    best_insert_cost = float('inf')\n\n    for pos in range(n):\n        if pos == i:\n            continue  # Skip the current position to avoid unnecessary checks\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        temp_solution = np.delete(temp_solution, i if pos > i else i + 1)\n        cost = sum(distance_matrix[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        if cost < best_insert_cost:\n            best_insert_cost = cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n    new_solution = np.delete(new_solution, i if best_insert_pos > i else i + 1)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The new algorithm combines multi-objective selection with a hybrid local search that alternates between improving the worst-performing objective and applying a randomized segment reversal to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and perform a 2-opt move to improve the worst objective\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate the cost for the worst objective\n    original_cost = sum(distance_matrix[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # If the move doesn't improve the worst objective, revert it\n    new_cost = sum(distance_matrix[new_solution[k-1], new_solution[k]] for k in range(n))\n    if new_cost >= original_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7041906894439677,
            4.223275876045227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and perform a 2-opt move to improve the worst objective\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate the cost for the worst objective\n    original_cost = sum(distance_matrix[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # If the move doesn't improve the worst objective, revert it\n    new_cost = sum(distance_matrix[new_solution[k-1], new_solution[k]] for k in range(n))\n    if new_cost >= original_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The new algorithm combines a multi-objective-aware segment reversal with a probabilistic node reinsertion strategy, prioritizing solutions that show improvement potential across all objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-objective segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.7:  # Higher probability for segment reversal\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic node reinsertion based on objective improvement\n    a = random.randint(0, n-1)\n    node = new_solution[a]\n    new_positions = [p for p in range(n) if p != a]\n    random.shuffle(new_positions)\n\n    for b in new_positions[:3]:  # Try up to 3 random positions\n        temp_solution = np.delete(new_solution, a)\n        temp_solution = np.insert(temp_solution, b, node)\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        ]\n\n        # Calculate original costs\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.49891796609355515,
            4.1843965411186215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-objective segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.7:  # Higher probability for segment reversal\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic node reinsertion based on objective improvement\n    a = random.randint(0, n-1)\n    node = new_solution[a]\n    new_positions = [p for p in range(n) if p != a]\n    random.shuffle(new_positions)\n\n    for b in new_positions[:3]:  # Try up to 3 random positions\n        temp_solution = np.delete(new_solution, a)\n        temp_solution = np.insert(temp_solution, b, node)\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        ]\n\n        # Calculate original costs\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{A novel tri-objective local search algorithm that combines adaptive 3-opt moves with biased random restarts to explore diverse regions of the solution space while maintaining feasibility and improving Pareto front coverage.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 3-opt move\n    if n >= 3:\n        # Randomly select three distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse segments between i-j and j-k\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n\n        # Recombine segments in different order\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Biased random restart if no improvement\n    if random.random() < 0.3:  # 30% chance to restart\n        # Select a random solution from archive with probability proportional to its dominance\n        weights = [1/(1 + sum(x[1])) for x in archive]\n        selected = random.choices(archive, weights=weights, k=1)[0][0]\n        new_solution = selected.copy()\n\n        # Apply small perturbation\n        if n >= 2:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7874602615385543,
            3.9579660534858703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 3-opt move\n    if n >= 3:\n        # Randomly select three distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse segments between i-j and j-k\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n\n        # Recombine segments in different order\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Biased random restart if no improvement\n    if random.random() < 0.3:  # 30% chance to restart\n        # Select a random solution from archive with probability proportional to its dominance\n        weights = [1/(1 + sum(x[1])) for x in archive]\n        selected = random.choices(archive, weights=weights, k=1)[0][0]\n        new_solution = selected.copy()\n\n        # Apply small perturbation\n        if n >= 2:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_score(obj):\n        return (obj[0] + obj[1] + obj[2]) / (1 + sum(obj))\n\n    selected_solution, _ = max(archive, key=lambda x: objective_score(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search: 2-opt with random segment reversal and node swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Randomly apply a 3-opt if the solution is large enough\n    if n >= 5 and random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5168664694132029,
            3.4675010442733765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_score(obj):\n        return (obj[0] + obj[1] + obj[2]) / (1 + sum(obj))\n\n    selected_solution, _ = max(archive, key=lambda x: objective_score(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search: 2-opt with random segment reversal and node swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Randomly apply a 3-opt if the solution is large enough\n    if n >= 5 and random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining 2-opt and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected = max(archive, key=lambda x: sum(x[1]) + random.random() * 0.1)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Apply hybrid local search: 2-opt for two objectives and node insertion for the third\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6483742277785864,
            3.649700438976288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected = max(archive, key=lambda x: sum(x[1]) + random.random() * 0.1)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Apply hybrid local search: 2-opt for two objectives and node insertion for the third\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a hybrid local search combining 3-opt and edge insertion, followed by a random perturbation to explore new configurations while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a hybrid local search combining 3-opt and edge swaps\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly swap two edges to explore new configurations\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Random perturbation: randomly shift a segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end]\n    np.random.shuffle(segment)\n    new_solution[start:end] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7595891270828317,
            3.230099391937256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a hybrid local search combining 3-opt and edge swaps\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly swap two edges to explore new configurations\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Random perturbation: randomly shift a segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end]\n    np.random.shuffle(segment)\n    new_solution[start:end] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7897195935913786,
            3.2829968333244324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8113602972863486,
            3.2665385484695433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8113602972863486,
            3.2665385484695433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects a solution from the archive, applies a hybrid local search combining 2-opt and node reinsertion, and ensures feasibility by validating the tour structure while exploring diverse configurations across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt with random segments\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node reinsertion with a probability-based selection\n    if random.random() < 0.5:  # 50% chance to perform reinsertion\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != len(selected_solution) or not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6679734566425143,
            3.584271419048309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt with random segments\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node reinsertion with a probability-based selection\n    if random.random() < 0.5:  # 50% chance to perform reinsertion\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != len(selected_solution) or not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        return selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel tri-objective local search algorithm that combines adaptive 3-opt moves with biased random restarts to explore diverse regions of the solution space while maintaining feasibility and improving Pareto front coverage.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 3-opt move\n    if n >= 3:\n        # Randomly select three distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse segments between i-j and j-k\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n\n        # Recombine segments in different order\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Biased random restart if no improvement\n    if random.random() < 0.3:  # 30% chance to restart\n        # Select a random solution from archive with probability proportional to its dominance\n        weights = [1/(1 + sum(x[1])) for x in archive]\n        selected = random.choices(archive, weights=weights, k=1)[0][0]\n        new_solution = selected.copy()\n\n        # Apply small perturbation\n        if n >= 2:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm combines multi-objective-aware segment swapping with adaptive objective-specific perturbations to explore the solution space while maintaining feasibility, using a biased selection of solutions based on objective diversity and a novel perturbation strategy that considers the relative importance of each objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    # Swap segments\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Apply objective-specific perturbation\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            # Select nodes with high distance in this objective\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            node_pairs = [(new_solution[(j-1)%n], new_solution[j]) for j in range(n)]\n            pair_distances = [distances[a][b] for a, b in node_pairs]\n            if len(pair_distances) > 0:\n                max_dist_idx = np.argmax(pair_distances)\n                # Swap nodes in the high-distance pair\n                new_solution[max_dist_idx], new_solution[(max_dist_idx+1)%n] = new_solution[(max_dist_idx+1)%n], new_solution[max_dist_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6559690422852045,
            1.563647198677063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    # Swap segments\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Apply objective-specific perturbation\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            # Select nodes with high distance in this objective\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            node_pairs = [(new_solution[(j-1)%n], new_solution[j]) for j in range(n)]\n            pair_distances = [distances[a][b] for a, b in node_pairs]\n            if len(pair_distances) > 0:\n                max_dist_idx = np.argmax(pair_distances)\n                # Swap nodes in the high-distance pair\n                new_solution[max_dist_idx], new_solution[(max_dist_idx+1)%n] = new_solution[(max_dist_idx+1)%n], new_solution[max_dist_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel tri-objective local search algorithm that combines adaptive 3-opt moves with biased random restarts to explore diverse regions of the solution space while maintaining feasibility and improving Pareto front coverage.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 3-opt move\n    if n >= 3:\n        # Randomly select three distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse segments between i-j and j-k\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n\n        # Recombine segments in different order\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Biased random restart if no improvement\n    if random.random() < 0.3:  # 30% chance to restart\n        # Select a random solution from archive with probability proportional to its dominance\n        weights = [1/(1 + sum(x[1])) for x in archive]\n        selected = random.choices(archive, weights=weights, k=1)[0][0]\n        new_solution = selected.copy()\n\n        # Apply small perturbation\n        if n >= 2:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm combines multi-objective-aware segment swapping with adaptive objective-specific perturbations to explore the solution space while maintaining feasibility, using a biased selection of solutions based on objective diversity and a novel perturbation strategy that considers the relative importance of each objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    # Swap segments\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Apply objective-specific perturbation\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            # Select nodes with high distance in this objective\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            node_pairs = [(new_solution[(j-1)%n], new_solution[j]) for j in range(n)]\n            pair_distances = [distances[a][b] for a, b in node_pairs]\n            if len(pair_distances) > 0:\n                max_dist_idx = np.argmax(pair_distances)\n                # Swap nodes in the high-distance pair\n                new_solution[max_dist_idx], new_solution[(max_dist_idx+1)%n] = new_solution[(max_dist_idx+1)%n], new_solution[max_dist_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6559690422852045,
            1.563647198677063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    # Swap segments\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Apply objective-specific perturbation\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            # Select nodes with high distance in this objective\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            node_pairs = [(new_solution[(j-1)%n], new_solution[j]) for j in range(n)]\n            pair_distances = [distances[a][b] for a, b in node_pairs]\n            if len(pair_distances) > 0:\n                max_dist_idx = np.argmax(pair_distances)\n                # Swap nodes in the high-distance pair\n                new_solution[max_dist_idx], new_solution[(max_dist_idx+1)%n] = new_solution[(max_dist_idx+1)%n], new_solution[max_dist_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to find potential candidates\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select among top 3 to balance exploration and exploitation\n        selected_idx = min(2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective-aware segment inversion\n    if n >= 4:\n        # Select a segment to invert based on the objective that could benefit most\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n\n        # Invert the segment\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Relocate a segment to improve the worst objective\n        worst_obj = np.argmin(archive[selected_idx][1]) if len(archive) > 1 else 0\n        reloc_length = random.randint(2, min(3, n // 3))\n        reloc_start = random.randint(0, n - reloc_length)\n        reloc_end = reloc_start + reloc_length - 1\n\n        segment_to_move = new_solution[reloc_start:reloc_end+1]\n        new_solution = np.concatenate([new_solution[:reloc_start], new_solution[reloc_end+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7451672492887698,
            3.594884216785431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to find potential candidates\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select among top 3 to balance exploration and exploitation\n        selected_idx = min(2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective-aware segment inversion\n    if n >= 4:\n        # Select a segment to invert based on the objective that could benefit most\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n\n        # Invert the segment\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Relocate a segment to improve the worst objective\n        worst_obj = np.argmin(archive[selected_idx][1]) if len(archive) > 1 else 0\n        reloc_length = random.randint(2, min(3, n // 3))\n        reloc_start = random.randint(0, n - reloc_length)\n        reloc_end = reloc_start + reloc_length - 1\n\n        segment_to_move = new_solution[reloc_start:reloc_end+1]\n        new_solution = np.concatenate([new_solution[:reloc_start], new_solution[reloc_end+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7836454933963461,
            3.2404825925827025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, objectives = min(archive, key=lambda x: max(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform a segment reversal and node insertion to improve the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find the best insertion point for a randomly selected node to improve the worst objective\n    node_to_insert = random.choice(new_solution)\n    best_insert_pos = i\n    best_insert_cost = float('inf')\n\n    for pos in range(n):\n        if pos == i:\n            continue  # Skip the current position to avoid unnecessary checks\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        temp_solution = np.delete(temp_solution, i if pos > i else i + 1)\n        cost = sum(distance_matrix[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        if cost < best_insert_cost:\n            best_insert_cost = cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n    new_solution = np.delete(new_solution, i if best_insert_pos > i else i + 1)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with the smallest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a multi-objective-aware 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objectives(solution):\n        cost1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    new_objectives = calculate_objectives(new_solution)\n\n    # If the new solution is better in at least one objective, keep it\n    if any(new_obj < old_obj for new_obj, old_obj in zip(new_objectives, archive[selected_idx][1])):\n        return new_solution\n    else:\n        # Otherwise, perform a more aggressive local search by swapping two nodes\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        return new_solution\n\n",
        "score": [
            -0.5952349097647226,
            4.367964804172516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with the smallest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a multi-objective-aware 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objectives(solution):\n        cost1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    new_objectives = calculate_objectives(new_solution)\n\n    # If the new solution is better in at least one objective, keep it\n    if any(new_obj < old_obj for new_obj, old_obj in zip(new_objectives, archive[selected_idx][1])):\n        return new_solution\n    else:\n        # Otherwise, perform a more aggressive local search by swapping two nodes\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and good objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a multi-objective aware segment inversion and relocation\n    # Step 1: Select a segment to invert based on the objective with the highest improvement potential\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Calculate the current cost of the segment in all three objectives\n    current_cost = 0\n    for i in range(start, end):\n        current_cost += distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[i], new_solution[i+1]]\n\n    # Invert the segment and calculate the new cost\n    inverted_segment = new_solution[start:end+1][::-1]\n    new_cost = 0\n    for i in range(len(inverted_segment) - 1):\n        new_cost += distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] + distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] + distance_matrix_3[inverted_segment[i], inverted_segment[i+1]]\n\n    # Only invert if it improves at least one objective\n    if new_cost < current_cost:\n        new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Randomly relocate a segment to explore new configurations\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([new_solution[:reloc_start], new_solution[reloc_end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7075356748408923,
            3.6784263134002684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and good objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a multi-objective aware segment inversion and relocation\n    # Step 1: Select a segment to invert based on the objective with the highest improvement potential\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Calculate the current cost of the segment in all three objectives\n    current_cost = 0\n    for i in range(start, end):\n        current_cost += distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[i], new_solution[i+1]]\n\n    # Invert the segment and calculate the new cost\n    inverted_segment = new_solution[start:end+1][::-1]\n    new_cost = 0\n    for i in range(len(inverted_segment) - 1):\n        new_cost += distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] + distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] + distance_matrix_3[inverted_segment[i], inverted_segment[i+1]]\n\n    # Only invert if it improves at least one objective\n    if new_cost < current_cost:\n        new_solution[start:end+1] = inverted_segment\n\n    # Step 2: Randomly relocate a segment to explore new configurations\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([new_solution[:reloc_start], new_solution[reloc_end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt exchange and 3-opt inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform 3-opt inversion\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.7723339507324465,
            3.345018196105957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform 3-opt inversion\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution based on a balanced score of improvement potential\n    def score(sol_obj):\n        sol, obj = sol_obj\n        # Calculate the normalized improvement potential (inverse of objective values)\n        norm_obj = [1.0 / (o + 1e-6) for o in obj]\n        # Weighted sum of normalized objectives (equal weights for simplicity)\n        return sum(norm_obj)\n\n    selected_solution, _ = max(archive, key=score)\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 4-opt with objective-aware edge selection\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Calculate edge improvements in all three objectives\n    def edge_improvement(a, b, c, d):\n        # Current edges: (a,b) and (c,d)\n        # New edges: (a,c) and (b,d)\n        improvement = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            improvement += (dm[a, c] + dm[b, d]) - (dm[a, b] + dm[c, d])\n        return improvement\n\n    # Try all possible 4-opt configurations and pick the best improvement\n    best_improvement = float('inf')\n    best_config = None\n\n    # Try all 4 possible 4-opt configurations\n    for a, b, c, d in [(i, j, k, l), (i, k, j, l), (i, j, l, k), (i, l, j, k)]:\n        imp = edge_improvement(new_solution[a], new_solution[b], new_solution[c], new_solution[d])\n        if imp < best_improvement:\n            best_improvement = imp\n            best_config = (a, b, c, d)\n\n    if best_config is not None:\n        a, b, c, d = best_config\n        # Apply the best 4-opt move\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Randomly swap two nodes to explore new configurations\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6714733079328337,
            4.212345564365387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution based on a balanced score of improvement potential\n    def score(sol_obj):\n        sol, obj = sol_obj\n        # Calculate the normalized improvement potential (inverse of objective values)\n        norm_obj = [1.0 / (o + 1e-6) for o in obj]\n        # Weighted sum of normalized objectives (equal weights for simplicity)\n        return sum(norm_obj)\n\n    selected_solution, _ = max(archive, key=score)\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 4-opt with objective-aware edge selection\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Calculate edge improvements in all three objectives\n    def edge_improvement(a, b, c, d):\n        # Current edges: (a,b) and (c,d)\n        # New edges: (a,c) and (b,d)\n        improvement = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            improvement += (dm[a, c] + dm[b, d]) - (dm[a, b] + dm[c, d])\n        return improvement\n\n    # Try all possible 4-opt configurations and pick the best improvement\n    best_improvement = float('inf')\n    best_config = None\n\n    # Try all 4 possible 4-opt configurations\n    for a, b, c, d in [(i, j, k, l), (i, k, j, l), (i, j, l, k), (i, l, j, k)]:\n        imp = edge_improvement(new_solution[a], new_solution[b], new_solution[c], new_solution[d])\n        if imp < best_improvement:\n            best_improvement = imp\n            best_config = (a, b, c, d)\n\n    if best_config is not None:\n        a, b, c, d = best_config\n        # Apply the best 4-opt move\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Randomly swap two nodes to explore new configurations\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6081383806265657,
            0.9583791732788086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6081383806265657,
            0.9583791732788086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a hybrid local search combining 3-opt and edge insertion, followed by a random perturbation to explore new configurations while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a hybrid local search combining 3-opt and edge swaps\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly swap two edges to explore new configurations\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Random perturbation: randomly shift a segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end]\n    np.random.shuffle(segment)\n    new_solution[start:end] = segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This algorithm selects a solution from the archive based on the minimum sum of objectives, then applies a novel multi-objective local search that combines segment reversal with objective-aware edge swaps and a dynamic perturbation strategy to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Objective-aware segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Calculate segment costs in all three objectives\n    segment_costs = [0.0, 0.0, 0.0]\n    for k in range(len(segment)-1):\n        a, b = segment[k], segment[k+1]\n        segment_costs[0] += distance_matrix_1[a, b]\n        segment_costs[1] += distance_matrix_2[a, b]\n        segment_costs[2] += distance_matrix_3[a, b]\n\n    # Reverse segment if it improves any objective\n    if any(segment_costs[i] > 0 for i in range(3)):\n        new_solution[i:j+1] = segment[::-1]\n\n    # Dynamic perturbation based on objective diversity\n    objective_weights = [0.33, 0.33, 0.34]  # Equal weights initially\n    # Adjust weights based on current solution's objective values\n    current_objectives = [sum(x[1][i] for x in archive) for i in range(3)]\n    total = sum(current_objectives)\n    if total > 0:\n        objective_weights = [obj/total for obj in current_objectives]\n\n    # Weighted random selection of perturbation type\n    perturbation_type = random.choices(\n        ['edge_swap', 'node_insertion', 'segment_shift'],\n        weights=[objective_weights[0], objective_weights[1], objective_weights[2]],\n        k=1\n    )[0]\n\n    if perturbation_type == 'edge_swap':\n        # Objective-aware edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate cost difference for all objectives\n            cost_diff = [\n                (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[a+1]]) -\n                (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[b]])\n            ]\n            cost_diff.append(\n                (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[a+1]]) -\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[b]])\n            )\n            cost_diff.append(\n                (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_3[new_solution[b], new_solution[a+1]]) -\n                (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_3[new_solution[b-1], new_solution[b]])\n            )\n\n            # Only swap if it improves at least one objective\n            if any(cost_diff[i] < 0 for i in range(3)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    elif perturbation_type == 'node_insertion':\n        # Objective-aware node insertion\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            # Calculate cost difference for all objectives\n            cost_diff = [\n                (distance_matrix_1[new_solution[b-1], node] +\n                 distance_matrix_1[node, new_solution[(b+1)%n]]) -\n                (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_1[new_solution[(a+1)%n], node])\n            ]\n            cost_diff.append(\n                (distance_matrix_2[new_solution[b-1], node] +\n                 distance_matrix_2[node, new_solution[(b+1)%n]]) -\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_2[new_solution[(a+1)%n], node])\n            )\n            cost_diff.append(\n                (distance_matrix_3[new_solution[b-1], node] +\n                 distance_matrix_3[node, new_solution[(b+1)%n]]) -\n                (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_3[new_solution[(a+1)%n], node])\n            )\n\n            # Only insert if it improves at least one objective\n            if any(cost_diff[i] < 0 for i in range(3)):\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    else:  # segment_shift\n        # Objective-aware segment shift\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        shift = random.randint(1, n//2)\n        segment = new_solution[start:end]\n\n        # Calculate cost difference for all objectives\n        original_cost = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(1, n))\n        ]\n\n        new_pos = (start + shift) % (n - (end - start))\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            np.delete(new_solution, range(start, end))\n        ])\n\n        new_cost = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(1, n))\n        ]\n\n        # Revert if shift doesn't improve any objective\n        if all(new_cost[i] >= original_cost[i] for i in range(3)):\n            new_solution = np.concatenate([\n                new_solution[:start],\n                segment,\n                np.delete(new_solution, range(start, end))\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7228154035743131,
            2.9546115398406982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Objective-aware segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Calculate segment costs in all three objectives\n    segment_costs = [0.0, 0.0, 0.0]\n    for k in range(len(segment)-1):\n        a, b = segment[k], segment[k+1]\n        segment_costs[0] += distance_matrix_1[a, b]\n        segment_costs[1] += distance_matrix_2[a, b]\n        segment_costs[2] += distance_matrix_3[a, b]\n\n    # Reverse segment if it improves any objective\n    if any(segment_costs[i] > 0 for i in range(3)):\n        new_solution[i:j+1] = segment[::-1]\n\n    # Dynamic perturbation based on objective diversity\n    objective_weights = [0.33, 0.33, 0.34]  # Equal weights initially\n    # Adjust weights based on current solution's objective values\n    current_objectives = [sum(x[1][i] for x in archive) for i in range(3)]\n    total = sum(current_objectives)\n    if total > 0:\n        objective_weights = [obj/total for obj in current_objectives]\n\n    # Weighted random selection of perturbation type\n    perturbation_type = random.choices(\n        ['edge_swap', 'node_insertion', 'segment_shift'],\n        weights=[objective_weights[0], objective_weights[1], objective_weights[2]],\n        k=1\n    )[0]\n\n    if perturbation_type == 'edge_swap':\n        # Objective-aware edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate cost difference for all objectives\n            cost_diff = [\n                (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[a+1]]) -\n                (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[b]])\n            ]\n            cost_diff.append(\n                (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[a+1]]) -\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[b]])\n            )\n            cost_diff.append(\n                (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_3[new_solution[b], new_solution[a+1]]) -\n                (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_3[new_solution[b-1], new_solution[b]])\n            )\n\n            # Only swap if it improves at least one objective\n            if any(cost_diff[i] < 0 for i in range(3)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    elif perturbation_type == 'node_insertion':\n        # Objective-aware node insertion\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            # Calculate cost difference for all objectives\n            cost_diff = [\n                (distance_matrix_1[new_solution[b-1], node] +\n                 distance_matrix_1[node, new_solution[(b+1)%n]]) -\n                (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_1[new_solution[(a+1)%n], node])\n            ]\n            cost_diff.append(\n                (distance_matrix_2[new_solution[b-1], node] +\n                 distance_matrix_2[node, new_solution[(b+1)%n]]) -\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_2[new_solution[(a+1)%n], node])\n            )\n            cost_diff.append(\n                (distance_matrix_3[new_solution[b-1], node] +\n                 distance_matrix_3[node, new_solution[(b+1)%n]]) -\n                (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                 distance_matrix_3[new_solution[(a+1)%n], node])\n            )\n\n            # Only insert if it improves at least one objective\n            if any(cost_diff[i] < 0 for i in range(3)):\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    else:  # segment_shift\n        # Objective-aware segment shift\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        shift = random.randint(1, n//2)\n        segment = new_solution[start:end]\n\n        # Calculate cost difference for all objectives\n        original_cost = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(1, n))\n        ]\n\n        new_pos = (start + shift) % (n - (end - start))\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            np.delete(new_solution, range(start, end))\n        ])\n\n        new_cost = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(1, n))\n        ]\n\n        # Revert if shift doesn't improve any objective\n        if all(new_cost[i] >= original_cost[i] for i in range(3)):\n            new_solution = np.concatenate([\n                new_solution[:start],\n                segment,\n                np.delete(new_solution, range(start, end))\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a promising solution from the archive, applies a hybrid of 2-opt and Or-opt local search operators to generate a neighbor solution, while ensuring the solution remains feasible and potentially improving the tour across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 2-opt to improve the tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply Or-opt to relocate a node for better multi-objective balance\n    a = random.randint(0, n-1)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    b = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6900483591717717,
            3.798730719089508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 2-opt to improve the tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply Or-opt to relocate a node for better multi-objective balance\n    a = random.randint(0, n-1)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    b = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective-aware segment swapping with adaptive objective-specific perturbations to explore the solution space while maintaining feasibility, using a biased selection of solutions based on objective diversity and a novel perturbation strategy that considers the relative importance of each objective.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    # Swap segments\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Apply objective-specific perturbation\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            # Select nodes with high distance in this objective\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            node_pairs = [(new_solution[(j-1)%n], new_solution[j]) for j in range(n)]\n            pair_distances = [distances[a][b] for a, b in node_pairs]\n            if len(pair_distances) > 0:\n                max_dist_idx = np.argmax(pair_distances)\n                # Swap nodes in the high-distance pair\n                new_solution[max_dist_idx], new_solution[(max_dist_idx+1)%n] = new_solution[(max_dist_idx+1)%n], new_solution[max_dist_idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm combines multi-objective-aware segment reversal with adaptive objective-specific node swaps to explore the solution space while maintaining feasibility, using a biased selection of solutions based on objective diversity and a novel perturbation strategy that considers the relative importance of each objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos = random.randint(0, n - segment_size)\n    new_solution[pos:pos+segment_size] = new_solution[pos:pos+segment_size][::-1]\n\n    # Apply objective-specific node swaps\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            # Find the pair of nodes with the highest distance in this objective\n            max_dist = -1\n            swap_pos = -1\n            for j in range(n):\n                a, b = new_solution[j], new_solution[(j+1)%n]\n                dist = distances[a][b]\n                if dist > max_dist:\n                    max_dist = dist\n                    swap_pos = j\n            if swap_pos != -1:\n                # Swap nodes to potentially reduce this distance\n                new_solution[swap_pos], new_solution[(swap_pos+1)%n] = new_solution[(swap_pos+1)%n], new_solution[swap_pos]\n\n    return new_solution\n\n",
        "score": [
            -0.7378299246371298,
            4.33458993434906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos = random.randint(0, n - segment_size)\n    new_solution[pos:pos+segment_size] = new_solution[pos:pos+segment_size][::-1]\n\n    # Apply objective-specific node swaps\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            # Find the pair of nodes with the highest distance in this objective\n            max_dist = -1\n            swap_pos = -1\n            for j in range(n):\n                a, b = new_solution[j], new_solution[(j+1)%n]\n                dist = distances[a][b]\n                if dist > max_dist:\n                    max_dist = dist\n                    swap_pos = j\n            if swap_pos != -1:\n                # Swap nodes to potentially reduce this distance\n                new_solution[swap_pos], new_solution[(swap_pos+1)%n] = new_solution[(swap_pos+1)%n], new_solution[swap_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution based on a combination of objective dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a multi-objective-aware segment inversion\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the segment to potentially improve all three objectives\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Perform a multi-objective-aware segment relocation\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7446895502887932,
            3.842492699623108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution based on a combination of objective dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a multi-objective-aware segment inversion\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the segment to potentially improve all three objectives\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Perform a multi-objective-aware segment relocation\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines multi-objective-aware segment swapping with adaptive objective-specific perturbations to explore the solution space while maintaining feasibility, using a biased selection of solutions based on objective diversity and a novel perturbation strategy that considers the relative importance of each objective.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    # Swap segments\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Apply objective-specific perturbation\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            # Select nodes with high distance in this objective\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            node_pairs = [(new_solution[(j-1)%n], new_solution[j]) for j in range(n)]\n            pair_distances = [distances[a][b] for a, b in node_pairs]\n            if len(pair_distances) > 0:\n                max_dist_idx = np.argmax(pair_distances)\n                # Swap nodes in the high-distance pair\n                new_solution[max_dist_idx], new_solution[(max_dist_idx+1)%n] = new_solution[(max_dist_idx+1)%n], new_solution[max_dist_idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This algorithm uses a combination of adaptive objective-focused segment swapping and dynamic perturbation intensity to generate diverse neighbors while maintaining feasibility, leveraging a selection mechanism that prioritizes solutions with balanced objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform adaptive segment swap\n    segment_size = random.randint(1, min(5, n//3))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Dynamic perturbation intensity\n    perturbation_intensity = random.uniform(0.3, 0.7)\n    for _ in range(int(perturbation_intensity * n)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6940297670505741,
            1.1457605242729187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform adaptive segment swap\n    segment_size = random.randint(1, min(5, n//3))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Dynamic perturbation intensity\n    perturbation_intensity = random.uniform(0.3, 0.7)\n    for _ in range(int(perturbation_intensity * n)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and spatial locality, then generates a neighbor by performing a multi-objective-aware segment inversion and node insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform node insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6543560946209677,
            2.233622872829437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform node insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum((x[1][i] / (1 + x[1][i])) for i in range(3)))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a 4-opt local search for multi-objective optimization\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Apply 4-opt: reverse segments between i-j, j-k, and k-l\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Randomly swap two nodes to explore new configurations\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7352225728353491,
            4.355957114696503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum((x[1][i] / (1 + x[1][i])) for i in range(3)))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform a 4-opt local search for multi-objective optimization\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Apply 4-opt: reverse segments between i-j, j-k, and k-l\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Randomly swap two nodes to explore new configurations\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two distinct positions for 2-opt with higher probability of shorter segments\n    segment_length = random.randint(2, min(5, n-1))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length - 1\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7862358630915438,
            4.455402660369873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two distinct positions for 2-opt with higher probability of shorter segments\n    segment_length = random.randint(2, min(5, n-1))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length - 1\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This new algorithm employs a multi-objective-aware two-opt-inspired operator that selectively applies segment inversions based on their potential to simultaneously improve all three objectives, combined with a dynamic segment selection mechanism that adapts to the current solution's objective profile, ensuring balanced exploration of the search space while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective balance\n    segment_size = n // 4\n    if segment_size < 2:\n        segment_size = 2\n\n    # Evaluate potential segments for inversion\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate original and inverted segment costs\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        # Apply inversion if it improves all objectives\n        if (inv_cost1 < orig_cost1 and inv_cost2 < orig_cost2 and inv_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.736506833921203,
            1.2021115303039551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective balance\n    segment_size = n // 4\n    if segment_size < 2:\n        segment_size = 2\n\n    # Evaluate potential segments for inversion\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate original and inverted segment costs\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        # Apply inversion if it improves all objectives\n        if (inv_cost1 < orig_cost1 and inv_cost2 < orig_cost2 and inv_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This new algorithm employs a novel objective-aware node swapping mechanism that intelligently selects and swaps nodes based on their relative contributions to each objective, while maintaining tour feasibility through a dynamic feasibility restoration process that ensures no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1])/3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate node contribution to each objective\n    node_contributions = []\n    for i in range(n-1):\n        node1 = new_solution[i]\n        node2 = new_solution[i+1]\n        contrib1 = distance_matrix_1[node1, node2]\n        contrib2 = distance_matrix_2[node1, node2]\n        contrib3 = distance_matrix_3[node1, node2]\n        node_contributions.append((contrib1, contrib2, contrib3))\n\n    # Find nodes with high contribution to any objective\n    max_contrib_nodes = []\n    for i in range(len(node_contributions)):\n        if any(contrib > 1.5 * sum(node_contributions[j][k] for j in range(len(node_contributions))) / len(node_contributions)\n               for k, contrib in enumerate(node_contributions[i])):\n            max_contrib_nodes.append(i)\n\n    if len(max_contrib_nodes) >= 2:\n        # Swap two nodes with high contribution\n        i, j = random.sample(max_contrib_nodes, 2)\n        new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.5614830373648809,
            1.3442900776863098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1])/3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate node contribution to each objective\n    node_contributions = []\n    for i in range(n-1):\n        node1 = new_solution[i]\n        node2 = new_solution[i+1]\n        contrib1 = distance_matrix_1[node1, node2]\n        contrib2 = distance_matrix_2[node1, node2]\n        contrib3 = distance_matrix_3[node1, node2]\n        node_contributions.append((contrib1, contrib2, contrib3))\n\n    # Find nodes with high contribution to any objective\n    max_contrib_nodes = []\n    for i in range(len(node_contributions)):\n        if any(contrib > 1.5 * sum(node_contributions[j][k] for j in range(len(node_contributions))) / len(node_contributions)\n               for k, contrib in enumerate(node_contributions[i])):\n            max_contrib_nodes.append(i)\n\n    if len(max_contrib_nodes) >= 2:\n        # Swap two nodes with high contribution\n        i, j = random.sample(max_contrib_nodes, 2)\n        new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm uses a combination of adaptive objective-focused segment swapping and dynamic perturbation intensity to generate diverse neighbors while maintaining feasibility, leveraging a selection mechanism that prioritizes solutions with balanced objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform adaptive segment swap\n    segment_size = random.randint(1, min(5, n//3))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Dynamic perturbation intensity\n    perturbation_intensity = random.uniform(0.3, 0.7)\n    for _ in range(int(perturbation_intensity * n)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm employs a multi-objective-aware path inversion and dynamic segment reversal strategy to generate neighbors by selectively inverting segments of the tour while prioritizing solutions with balanced objective improvements and adaptively adjusting inversion intensity based on solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    inversion_size = random.randint(2, min(7, n//2))\n    start_pos = random.randint(0, n - inversion_size)\n    end_pos = start_pos + inversion_size\n\n    segment = new_solution[start_pos:end_pos]\n    new_solution[start_pos:end_pos] = segment[::-1]\n\n    inversion_intensity = random.uniform(0.2, 0.6)\n    for _ in range(int(inversion_intensity * n)):\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6085438068077811,
            4.02042167186737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    inversion_size = random.randint(2, min(7, n//2))\n    start_pos = random.randint(0, n - inversion_size)\n    end_pos = start_pos + inversion_size\n\n    segment = new_solution[start_pos:end_pos]\n    new_solution[start_pos:end_pos] = segment[::-1]\n\n    inversion_intensity = random.uniform(0.2, 0.6)\n    for _ in range(int(inversion_intensity * n)):\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{A novel multi-objective local search algorithm that selects solutions with the smallest maximum objective value, applies a 2-opt move, then performs a series of adaptive edge reversals based on Pareto dominance in all three objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive edge reversals\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a == 1:\n            continue\n\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert if not Pareto-dominated\n        dominates = False\n        for new_cost, original_cost in zip(new_costs, original_costs):\n            if new_cost < original_cost:\n                dominates = True\n                break\n\n        if not dominates:\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7728429207662959,
            3.9027581334114076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive edge reversals\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a == 1:\n            continue\n\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert if not Pareto-dominated\n        dominates = False\n        for new_cost, original_cost in zip(new_costs, original_costs):\n            if new_cost < original_cost:\n                dominates = True\n                break\n\n        if not dominates:\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.748700524915218,
            0.6126219034194946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.748700524915218,
            0.6126219034194946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment relocation with multi-objective evaluation\n    if n >= 4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j]\n\n        # Evaluate insertion points\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(1, n-1):\n            if pos >= i and pos <= j:\n                continue\n\n            # Temporarily insert segment at pos\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            temp_solution = np.concatenate([temp_solution[:i], temp_solution[j:]])\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n                sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n                sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            ]\n\n            # Calculate improvement (negative if worse)\n            improvement = sum(new_costs) - sum(archive[0][1])\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Probabilistic edge exchange\n    if n >= 3:\n        a, b = random.sample(range(1, n-1), 2)\n        original_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[a], new_solution[a+1]),\n            (new_solution[b-1], new_solution[b]),\n            (new_solution[b], new_solution[b+1])\n        ]\n\n        # Calculate original costs\n        original_costs = [\n            sum(distance_matrix_1[u, v] for u, v in original_edges),\n            sum(distance_matrix_2[u, v] for u, v in original_edges),\n            sum(distance_matrix_3[u, v] for u, v in original_edges)\n        ]\n\n        # Swap edges\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[a], new_solution[a+1]),\n            (new_solution[b-1], new_solution[b]),\n            (new_solution[b], new_solution[b+1])\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[u, v] for u, v in new_edges),\n            sum(distance_matrix_2[u, v] for u, v in new_edges),\n            sum(distance_matrix_3[u, v] for u, v in new_edges)\n        ]\n\n        # Revert if no improvement in any objective\n        if all(new_cost >= orig_cost for new_cost, orig_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7706135972652566,
            3.0373866081237795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment relocation with multi-objective evaluation\n    if n >= 4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j]\n\n        # Evaluate insertion points\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(1, n-1):\n            if pos >= i and pos <= j:\n                continue\n\n            # Temporarily insert segment at pos\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            temp_solution = np.concatenate([temp_solution[:i], temp_solution[j:]])\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n                sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n                sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            ]\n\n            # Calculate improvement (negative if worse)\n            improvement = sum(new_costs) - sum(archive[0][1])\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Probabilistic edge exchange\n    if n >= 3:\n        a, b = random.sample(range(1, n-1), 2)\n        original_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[a], new_solution[a+1]),\n            (new_solution[b-1], new_solution[b]),\n            (new_solution[b], new_solution[b+1])\n        ]\n\n        # Calculate original costs\n        original_costs = [\n            sum(distance_matrix_1[u, v] for u, v in original_edges),\n            sum(distance_matrix_2[u, v] for u, v in original_edges),\n            sum(distance_matrix_3[u, v] for u, v in original_edges)\n        ]\n\n        # Swap edges\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[a], new_solution[a+1]),\n            (new_solution[b-1], new_solution[b]),\n            (new_solution[b], new_solution[b+1])\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[u, v] for u, v in new_edges),\n            sum(distance_matrix_2[u, v] for u, v in new_edges),\n            sum(distance_matrix_3[u, v] for u, v in new_edges)\n        ]\n\n        # Revert if no improvement in any objective\n        if all(new_cost >= orig_cost for new_cost, orig_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects solutions with high potential for improvement by combining 2-opt with a multi-objective aware swap operator, while prioritizing solutions that show significant diversity in their objective values to expand the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_diversity(obj):\n        return (max(obj) - min(obj)) / (sum(obj) + 1e-8)\n\n    base_solution, _ = max(archive, key=lambda x: objective_diversity(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt with multi-objective awareness\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Accept if at least one objective improves\n    if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.4425375150359928,
            3.1986030459403993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_diversity(obj):\n        return (max(obj) - min(obj)) / (sum(obj) + 1e-8)\n\n    base_solution, _ = max(archive, key=lambda x: objective_diversity(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt with multi-objective awareness\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Accept if at least one objective improves\n    if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm uses a combination of adaptive objective-focused segment swapping and dynamic perturbation intensity to generate diverse neighbors while maintaining feasibility, leveraging a selection mechanism that prioritizes solutions with balanced objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform adaptive segment swap\n    segment_size = random.randint(1, min(5, n//3))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Dynamic perturbation intensity\n    perturbation_intensity = random.uniform(0.3, 0.7)\n    for _ in range(int(perturbation_intensity * n)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This algorithm uses a multi-objective diversity-aware selection mechanism that prioritizes solutions with both high objective improvement potential and low crowding in the objective space, combined with an adaptive 3-segment exchange local search operator that dynamically adjusts segment sizes based on the current solution's objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n\n    # Calculate diversity score based on crowding in objective space\n    diversity_scores = 1 / (np.sum((objectives[:, None] - objectives) ** 2, axis=2) + 1e-8)\n    diversity_scores = np.sum(diversity_scores, axis=1) / (len(archive) - 1)\n\n    # Combine improvement and diversity scores\n    improvement_scores = np.sum(normalized, axis=1)\n    selection_scores = improvement_scores * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 6:\n        return new_solution\n\n    # Adaptive 3-segment exchange\n    segment_size = max(2, min(5, int(n * 0.2 * (1 - improvement_scores[selected_idx]))))\n    pos1 = random.randint(0, n - 3 * segment_size)\n\n    segments = [new_solution[pos1+i*segment_size:pos1+(i+1)*segment_size] for i in range(3)]\n    random.shuffle(segments)\n\n    for i in range(3):\n        new_solution[pos1+i*segment_size:pos1+(i+1)*segment_size] = segments[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6281932712096499,
            2.7064176201820374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n\n    # Calculate diversity score based on crowding in objective space\n    diversity_scores = 1 / (np.sum((objectives[:, None] - objectives) ** 2, axis=2) + 1e-8)\n    diversity_scores = np.sum(diversity_scores, axis=1) / (len(archive) - 1)\n\n    # Combine improvement and diversity scores\n    improvement_scores = np.sum(normalized, axis=1)\n    selection_scores = improvement_scores * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 6:\n        return new_solution\n\n    # Adaptive 3-segment exchange\n    segment_size = max(2, min(5, int(n * 0.2 * (1 - improvement_scores[selected_idx]))))\n    pos1 = random.randint(0, n - 3 * segment_size)\n\n    segments = [new_solution[pos1+i*segment_size:pos1+(i+1)*segment_size] for i in range(3)]\n    random.shuffle(segments)\n\n    for i in range(3):\n        new_solution[pos1+i*segment_size:pos1+(i+1)*segment_size] = segments[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8685804771441283,
            2.7185657024383545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8350307492651485,
            2.202926051616669
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects solutions with high diversity in the archive, applies a hybrid of 4-opt and objective-adaptive segment reversal, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse the middle two segments\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-adaptive segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.5247051887352513,
            2.8727994680404665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse the middle two segments\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-adaptive segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective-aware two-opt-inspired operator that selectively applies segment inversions based on their potential to simultaneously improve all three objectives, combined with a dynamic segment selection mechanism that adapts to the current solution's objective profile, ensuring balanced exploration of the search space while maintaining tour feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective balance\n    segment_size = n // 4\n    if segment_size < 2:\n        segment_size = 2\n\n    # Evaluate potential segments for inversion\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate original and inverted segment costs\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        # Apply inversion if it improves all objectives\n        if (inv_cost1 < orig_cost1 and inv_cost2 < orig_cost2 and inv_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This new algorithm employs a multi-objective-aware segment rotation operator that selectively applies segment rotations based on their potential to simultaneously improve all three objectives, combined with an adaptive segment selection mechanism that prioritizes nodes with the highest objective diversity, ensuring balanced exploration while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = n // 3\n    if segment_size < 2:\n        segment_size = 2\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        rotated_segment = np.roll(segment, 1)\n        rot_cost1 = sum(distance_matrix_1[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost2 = sum(distance_matrix_2[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost3 = sum(distance_matrix_3[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n\n        if (rot_cost1 < orig_cost1 and rot_cost2 < orig_cost2 and rot_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = rotated_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7031202634197247,
            1.0285005450248719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = n // 3\n    if segment_size < 2:\n        segment_size = 2\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        rotated_segment = np.roll(segment, 1)\n        rot_cost1 = sum(distance_matrix_1[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost2 = sum(distance_matrix_2[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost3 = sum(distance_matrix_3[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n\n        if (rot_cost1 < orig_cost1 and rot_cost2 < orig_cost2 and rot_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = rotated_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and spatial locality, then generates neighbors by performing a multi-objective-aware segment inversion and adaptive node insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform adaptive node insertion based on spatial proximity\n    for _ in range(2):\n        # Select a random node and find its nearest neighbors in all three spaces\n        node = random.choice(new_solution)\n        node_idx = np.where(new_solution == node)[0][0]\n\n        # Find the nearest neighbors in each space\n        neighbors = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            nearest = np.argsort(dm[node])[1]  # Skip self\n            neighbors.append(new_solution[nearest])\n\n        # Choose a neighbor to insert\n        insert_pos = random.choice(neighbors)\n        insert_idx = np.where(new_solution == insert_pos)[0][0]\n\n        # Perform insertion\n        if node_idx != insert_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            if node_idx < insert_idx:\n                insert_idx -= 1\n            new_solution = np.insert(new_solution, insert_idx, node)\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Revert if no improvement in any objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            # Undo the insertion\n            new_solution = np.delete(new_solution, insert_idx)\n            if insert_idx < node_idx:\n                node_idx -= 1\n            new_solution = np.insert(new_solution, node_idx, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6988874525116386,
            3.110559546947479
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform adaptive node insertion based on spatial proximity\n    for _ in range(2):\n        # Select a random node and find its nearest neighbors in all three spaces\n        node = random.choice(new_solution)\n        node_idx = np.where(new_solution == node)[0][0]\n\n        # Find the nearest neighbors in each space\n        neighbors = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            nearest = np.argsort(dm[node])[1]  # Skip self\n            neighbors.append(new_solution[nearest])\n\n        # Choose a neighbor to insert\n        insert_pos = random.choice(neighbors)\n        insert_idx = np.where(new_solution == insert_pos)[0][0]\n\n        # Perform insertion\n        if node_idx != insert_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            if node_idx < insert_idx:\n                insert_idx -= 1\n            new_solution = np.insert(new_solution, insert_idx, node)\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Revert if no improvement in any objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            # Undo the insertion\n            new_solution = np.delete(new_solution, insert_idx)\n            if insert_idx < node_idx:\n                node_idx -= 1\n            new_solution = np.insert(new_solution, node_idx, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution structure, then generates a neighbor by performing a multi-objective-aware node permutation and segment reversal with adaptive segment size, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance score (simplified for this example)\n        dominance_scores = []\n        for sol, obj in archive:\n            score = sum(obj)\n            dominance_scores.append(score)\n        # Select solution with lower dominance score (better overall)\n        selected_idx = np.argmin(dominance_scores)\n    else:\n        selected_idx = 0\n\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Perform node permutation\n    perm_indices = random.sample(range(n), n)\n    new_solution = new_solution[perm_indices]\n\n    # Perform segment reversal with adaptive segment size\n    if n >= segment_size + 1:\n        start = random.randint(0, n - segment_size)\n        end = min(start + segment_size - 1, n - 1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6947297581614121,
            1.9624709606170654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance score (simplified for this example)\n        dominance_scores = []\n        for sol, obj in archive:\n            score = sum(obj)\n            dominance_scores.append(score)\n        # Select solution with lower dominance score (better overall)\n        selected_idx = np.argmin(dominance_scores)\n    else:\n        selected_idx = 0\n\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Perform node permutation\n    perm_indices = random.sample(range(n), n)\n    new_solution = new_solution[perm_indices]\n\n    # Perform segment reversal with adaptive segment size\n    if n >= segment_size + 1:\n        start = random.randint(0, n - segment_size)\n        end = min(start + segment_size - 1, n - 1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of crowding distance and objective dominance, then generates a neighbor by performing a multi-objective-aware 2-opt exchange and edge insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low dominance count\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge insertion\n    if n > 4:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7466426245748787,
            2.093297469615936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low dominance count\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge insertion\n    if n > 4:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A novel algorithm that intelligently selects a solution from the archive based on a hybrid objective score, then applies a multi-objective 3-opt local search with random segment reversals and node insertions to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -(x[1][0] * 0.4 + x[1][1] * 0.3 + x[1][2] * 0.3))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective 3-opt with random segment reversals\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.7:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    if random.random() < 0.5:\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply random node insertions to explore new configurations\n    if random.random() < 0.6:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7418766425549869,
            2.3771363735198974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -(x[1][0] * 0.4 + x[1][1] * 0.3 + x[1][2] * 0.3))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective 3-opt with random segment reversals\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.7:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    if random.random() < 0.5:\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply random node insertions to explore new configurations\n    if random.random() < 0.6:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm uses a combination of adaptive objective-focused segment swapping and dynamic perturbation intensity to generate diverse neighbors while maintaining feasibility, leveraging a selection mechanism that prioritizes solutions with balanced objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform adaptive segment swap\n    segment_size = random.randint(1, min(5, n//3))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Dynamic perturbation intensity\n    perturbation_intensity = random.uniform(0.3, 0.7)\n    for _ in range(int(perturbation_intensity * n)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This algorithm combines multi-objective-aware segment inversion with adaptive perturbation intensity, using a selection mechanism that prioritizes solutions with the most balanced objective improvements while dynamically adjusting the perturbation strength based on the solution's current quality across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    segment_size = random.randint(1, min(4, n//2))\n    pos = random.randint(0, n - segment_size)\n    segment = new_solution[pos:pos+segment_size]\n    new_solution[pos:pos+segment_size] = segment[::-1]\n\n    perturbation_intensity = np.mean(normalized[selected_idx]) * 0.5\n    for _ in range(int(perturbation_intensity * n)):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6597820026621715,
            2.7642329812049864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    segment_size = random.randint(1, min(4, n//2))\n    pos = random.randint(0, n - segment_size)\n    segment = new_solution[pos:pos+segment_size]\n    new_solution[pos:pos+segment_size] = segment[::-1]\n\n    perturbation_intensity = np.mean(normalized[selected_idx]) * 0.5\n    for _ in range(int(perturbation_intensity * n)):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a combination of segment inversion, relocation, and edge swaps, ensuring feasibility while balancing exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 4, n - 1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Perform segment relocation\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 3, n - 1))\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([new_solution[:reloc_start], new_solution[reloc_end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    # Perform edge swap if beneficial\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            # Calculate change in objectives\n            old_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            ]\n            if old_costs[1] < old_costs[0]:  # If swap improves at least one objective\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5819735384375344,
            2.4679977536201476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 4, n - 1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Perform segment relocation\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 3, n - 1))\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([new_solution[:reloc_start], new_solution[reloc_end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    # Perform edge swap if beneficial\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            # Calculate change in objectives\n            old_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            ]\n            if old_costs[1] < old_costs[0]:  # If swap improves at least one objective\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment rotation with dynamic objective-weighted segment insertion, where it intelligently rotates segments in the tour, evaluates their contributions to each objective with dynamic weights, and inserts segments at optimal positions based on weighted improvements across all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    worst_seg = segments.pop(worst_seg_idx)\n\n    rotated_seg = np.roll(worst_seg, 1)\n    rot_cost1 = sum(distance_matrix_1[rotated_seg[j-1], rotated_seg[j]] for j in range(len(rotated_seg)))\n    rot_cost2 = sum(distance_matrix_2[rotated_seg[j-1], rotated_seg[j]] for j in range(len(rotated_seg)))\n    rot_cost3 = sum(distance_matrix_3[rotated_seg[j-1], rotated_seg[j]] for j in range(len(rotated_seg)))\n    rot_weighted_cost = weights[0]*rot_cost1 + weights[1]*rot_cost2 + weights[2]*rot_cost3\n\n    if rot_weighted_cost < segment_costs[worst_seg_idx][3]:\n        worst_seg = rotated_seg\n\n    best_insert_pos = 0\n    best_insert_cost = float('inf')\n\n    for i in range(len(segments) + 1):\n        temp_segments = segments.copy()\n        temp_segments.insert(i, worst_seg)\n        temp_solution = np.concatenate(temp_segments)\n        temp_cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        temp_cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        temp_cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        temp_weighted_cost = weights[0]*temp_cost1 + weights[1]*temp_cost2 + weights[2]*temp_cost3\n\n        if temp_weighted_cost < best_insert_cost:\n            best_insert_cost = temp_weighted_cost\n            best_insert_pos = i\n\n    segments.insert(best_insert_pos, worst_seg)\n    new_solution = np.concatenate(segments)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6410736600687162,
            1.0193787932395935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    worst_seg = segments.pop(worst_seg_idx)\n\n    rotated_seg = np.roll(worst_seg, 1)\n    rot_cost1 = sum(distance_matrix_1[rotated_seg[j-1], rotated_seg[j]] for j in range(len(rotated_seg)))\n    rot_cost2 = sum(distance_matrix_2[rotated_seg[j-1], rotated_seg[j]] for j in range(len(rotated_seg)))\n    rot_cost3 = sum(distance_matrix_3[rotated_seg[j-1], rotated_seg[j]] for j in range(len(rotated_seg)))\n    rot_weighted_cost = weights[0]*rot_cost1 + weights[1]*rot_cost2 + weights[2]*rot_cost3\n\n    if rot_weighted_cost < segment_costs[worst_seg_idx][3]:\n        worst_seg = rotated_seg\n\n    best_insert_pos = 0\n    best_insert_cost = float('inf')\n\n    for i in range(len(segments) + 1):\n        temp_segments = segments.copy()\n        temp_segments.insert(i, worst_seg)\n        temp_solution = np.concatenate(temp_segments)\n        temp_cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        temp_cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        temp_cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        temp_weighted_cost = weights[0]*temp_cost1 + weights[1]*temp_cost2 + weights[2]*temp_cost3\n\n        if temp_weighted_cost < best_insert_cost:\n            best_insert_cost = temp_weighted_cost\n            best_insert_pos = i\n\n    segments.insert(best_insert_pos, worst_seg)\n    new_solution = np.concatenate(segments)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6808392826580825,
            0.7360428690910339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment rotation with dynamic objective-weighted segment insertion, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and inserts segments at optimal positions based on weighted improvements across all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 5 parts\n    segment_size = n // 5\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:4*segment_size],\n        new_solution[4*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    worst_seg = segments.pop(worst_seg_idx)\n\n    # Find the best insertion position for the worst segment\n    best_pos = -1\n    min_weighted_cost = float('inf')\n\n    for i in range(len(segments) + 1):\n        # Insert the worst segment at position i\n        temp_segments = segments.copy()\n        temp_segments.insert(i, worst_seg)\n\n        # Reconstruct the solution\n        temp_solution = np.concatenate(temp_segments)\n\n        # Calculate the weighted cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost < min_weighted_cost:\n            min_weighted_cost = weighted_cost\n            best_pos = i\n\n    # Insert the worst segment at the best position\n    segments.insert(best_pos, worst_seg)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7352844301385002,
            2.551551568508148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 5 parts\n    segment_size = n // 5\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:4*segment_size],\n        new_solution[4*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    worst_seg = segments.pop(worst_seg_idx)\n\n    # Find the best insertion position for the worst segment\n    best_pos = -1\n    min_weighted_cost = float('inf')\n\n    for i in range(len(segments) + 1):\n        # Insert the worst segment at position i\n        temp_segments = segments.copy()\n        temp_segments.insert(i, worst_seg)\n\n        # Reconstruct the solution\n        temp_solution = np.concatenate(temp_segments)\n\n        # Calculate the weighted cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost < min_weighted_cost:\n            min_weighted_cost = weighted_cost\n            best_pos = i\n\n    # Insert the worst segment at the best position\n    segments.insert(best_pos, worst_seg)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective improvements and solution diversity, then generates a neighbor by performing a multi-objective-aware edge exchange and 3-opt move, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform edge exchange\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    if random.random() < 0.7:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7261042748710358,
            3.960934591293335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform edge exchange\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    if random.random() < 0.7:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of objective-driven node swapping and segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven node swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    # Perform segment insertion\n    for _ in range(2):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:a], temp_solution[b+1:c+1], segment, temp_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.7799629702621025,
            4.130919635295868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven node swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    # Perform segment insertion\n    for _ in range(2):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:a], temp_solution[b+1:c+1], segment, temp_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects solutions from the archive based on a weighted Pareto front dominance score, applies a hybrid of 4-opt and adaptive edge swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def weighted_dominance(obj):\n        weights = [0.4, 0.3, 0.3]\n        return sum(w * o for w, o in zip(weights, obj))\n\n    base_solution, _ = min(archive, key=lambda x: weighted_dominance(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse the middle two segments\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform adaptive edge swaps based on objective improvement\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:  # Ensure non-adjacent nodes\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n            ]\n\n            # Revert swap if it doesn't improve at least one objective\n            if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7350588746644491,
            2.594019865989685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def weighted_dominance(obj):\n        weights = [0.4, 0.3, 0.3]\n        return sum(w * o for w, o in zip(weights, obj))\n\n    base_solution, _ = min(archive, key=lambda x: weighted_dominance(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse the middle two segments\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform adaptive edge swaps based on objective improvement\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:  # Ensure non-adjacent nodes\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n            ]\n\n            # Revert swap if it doesn't improve at least one objective\n            if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective-aware segment rotation operator that selectively applies segment rotations based on their potential to simultaneously improve all three objectives, combined with an adaptive segment selection mechanism that prioritizes nodes with the highest objective diversity, ensuring balanced exploration while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = n // 3\n    if segment_size < 2:\n        segment_size = 2\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        rotated_segment = np.roll(segment, 1)\n        rot_cost1 = sum(distance_matrix_1[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost2 = sum(distance_matrix_2[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost3 = sum(distance_matrix_3[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n\n        if (rot_cost1 < orig_cost1 and rot_cost2 < orig_cost2 and rot_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = rotated_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This new algorithm employs a multi-objective-aware node reordering strategy that selectively reorders nodes based on their relative improvements across all three objectives, combined with an adaptive segment selection mechanism that prioritizes nodes with the highest objective diversity, ensuring balanced exploration while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate the relative improvement potential for each node\n    improvement_potential = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        orig_cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        orig_cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        orig_cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n        # Try swapping with next node\n        temp_node = new_solution[(i+1) % n]\n        new_cost1 = distance_matrix_1[prev_node, temp_node] + distance_matrix_1[temp_node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, temp_node] + distance_matrix_2[temp_node, next_node]\n        new_cost3 = distance_matrix_3[prev_node, temp_node] + distance_matrix_3[temp_node, next_node]\n\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2) + (orig_cost3 - new_cost3)\n        improvement_potential.append(improvement)\n\n    # Perform node reordering based on improvement potential\n    for i in range(n):\n        if improvement_potential[i] > 0:\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6710166319023378,
            0.6300078153610229
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate the relative improvement potential for each node\n    improvement_potential = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        orig_cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        orig_cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        orig_cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n        # Try swapping with next node\n        temp_node = new_solution[(i+1) % n]\n        new_cost1 = distance_matrix_1[prev_node, temp_node] + distance_matrix_1[temp_node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, temp_node] + distance_matrix_2[temp_node, next_node]\n        new_cost3 = distance_matrix_3[prev_node, temp_node] + distance_matrix_3[temp_node, next_node]\n\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2) + (orig_cost3 - new_cost3)\n        improvement_potential.append(improvement)\n\n    # Perform node reordering based on improvement potential\n    for i in range(n):\n        if improvement_potential[i] > 0:\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 3-opt and objective-driven segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Insert segment at new position and evaluate\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.765406485545149,
            2.153521180152893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Insert segment at new position and evaluate\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective-aware two-opt-inspired operator that selectively applies segment inversions based on their potential to simultaneously improve all three objectives, combined with a dynamic segment selection mechanism that adapts to the current solution's objective profile, ensuring balanced exploration of the search space while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, objectives = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective balance\n    segment_size = n // 4\n    if segment_size < 2:\n        segment_size = 2\n\n    # Evaluate potential segments for inversion\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate original and inverted segment costs\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        # Apply inversion if it improves all objectives\n        if (inv_cost1 < orig_cost1 and inv_cost2 < orig_cost2 and inv_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This algorithm employs a multi-objective-aware path relinking operator that combines elements from elite solutions in the archive, using a dominance-based selection criterion to favor segments that improve multiple objectives simultaneously, while dynamically adjusting the relinking path based on the current solution's objective profile to ensure balanced exploration of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    selected_solution, _ = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / (sum(x[1]) + 1e-10))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two elite solutions for path relinking\n    elite1, elite2 = random.sample(archive, min(2, len(archive)))\n    elite1_tour, _ = elite1\n    elite2_tour, _ = elite2\n\n    # Find the longest common subsequence (LCS) between the two elite solutions\n    lcs = []\n    for i in range(n):\n        if elite1_tour[i] == elite2_tour[i]:\n            lcs.append(elite1_tour[i])\n\n    # If LCS is too small, use a different approach\n    if len(lcs) < 2:\n        # Select a random segment from one elite and insert it into the selected solution\n        segment_length = random.randint(2, n//4)\n        start = random.randint(0, n - segment_length)\n        segment = elite1_tour[start:start+segment_length]\n\n        # Find the best position to insert the segment\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(n - segment_length + 1):\n            temp_solution = new_solution.copy()\n            temp_solution[i:i+segment_length] = segment\n            cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            total_cost = cost1 + cost2 + cost3\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution[best_pos:best_pos+segment_length] = segment\n    else:\n        # Use LCS to guide the relinking\n        lcs_indices = [i for i, node in enumerate(elite1_tour) if node in lcs]\n        lcs_indices.sort()\n\n        # Create a new solution by combining segments from elite solutions\n        for i in range(len(lcs_indices) - 1):\n            start = lcs_indices[i]\n            end = lcs_indices[i+1]\n            if random.random() < 0.5:\n                new_solution[start:end] = elite1_tour[start:end]\n            else:\n                new_solution[start:end] = elite2_tour[start:end]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7230797901981864,
            2.0936572194099425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    selected_solution, _ = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / (sum(x[1]) + 1e-10))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two elite solutions for path relinking\n    elite1, elite2 = random.sample(archive, min(2, len(archive)))\n    elite1_tour, _ = elite1\n    elite2_tour, _ = elite2\n\n    # Find the longest common subsequence (LCS) between the two elite solutions\n    lcs = []\n    for i in range(n):\n        if elite1_tour[i] == elite2_tour[i]:\n            lcs.append(elite1_tour[i])\n\n    # If LCS is too small, use a different approach\n    if len(lcs) < 2:\n        # Select a random segment from one elite and insert it into the selected solution\n        segment_length = random.randint(2, n//4)\n        start = random.randint(0, n - segment_length)\n        segment = elite1_tour[start:start+segment_length]\n\n        # Find the best position to insert the segment\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(n - segment_length + 1):\n            temp_solution = new_solution.copy()\n            temp_solution[i:i+segment_length] = segment\n            cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            total_cost = cost1 + cost2 + cost3\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution[best_pos:best_pos+segment_length] = segment\n    else:\n        # Use LCS to guide the relinking\n        lcs_indices = [i for i, node in enumerate(elite1_tour) if node in lcs]\n        lcs_indices.sort()\n\n        # Create a new solution by combining segments from elite solutions\n        for i in range(len(lcs_indices) - 1):\n            start = lcs_indices[i]\n            end = lcs_indices[i+1]\n            if random.random() < 0.5:\n                new_solution[start:end] = elite1_tour[start:end]\n            else:\n                new_solution[start:end] = elite2_tour[start:end]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm uses a combination of adaptive objective-focused segment swapping and dynamic perturbation intensity to generate diverse neighbors while maintaining feasibility, leveraging a selection mechanism that prioritizes solutions with balanced objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform adaptive segment swap\n    segment_size = random.randint(1, min(5, n//3))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Dynamic perturbation intensity\n    perturbation_intensity = random.uniform(0.3, 0.7)\n    for _ in range(int(perturbation_intensity * n)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective improvement potential and solution structure diversity, then generates a neighbor by performing a multi-objective-aware hybrid of node swapping, segment inversion, and adaptive perturbation, ensuring feasibility while balancing exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.std(normalized, axis=1)\n    improvement_scores = np.sum(1 - normalized, axis=1)\n    combined_scores = 0.6 * improvement_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator\n    # 1. Adaptive node swapping based on objective improvements\n    for _ in range(random.randint(1, 3)):\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement across all objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment inversion with objective-aware selection\n    segment_size = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size - 1\n    # Evaluate segment inversion impact\n    current_segment_cost = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_1[new_solution[end], new_solution[(end+1)%n]] +\n                            distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_2[new_solution[end], new_solution[(end+1)%n]] +\n                            distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_3[new_solution[end], new_solution[(end+1)%n]])\n    inverted_segment_cost = (distance_matrix_1[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_1[new_solution[start], new_solution[(end+1)%n]] +\n                            distance_matrix_2[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_2[new_solution[start], new_solution[(end+1)%n]] +\n                            distance_matrix_3[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_3[new_solution[start], new_solution[(end+1)%n]])\n    if inverted_segment_cost < current_segment_cost:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Adaptive perturbation based on objective balance\n    perturbation_intensity = random.uniform(0.2, 0.5)\n    for _ in range(int(perturbation_intensity * n)):\n        i, j = random.sample(range(n), 2)\n        # Only perform swap if it improves at least one objective\n        improved = False\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            if (dm[new_solution[i-1], new_solution[j]] + dm[new_solution[j], new_solution[(i+1)%n]] +\n                dm[new_solution[j-1], new_solution[i]] + dm[new_solution[i], new_solution[(j+1)%n]]) < \\\n               (dm[new_solution[i-1], new_solution[i]] + dm[new_solution[i], new_solution[(i+1)%n]] +\n                dm[new_solution[j-1], new_solution[j]] + dm[new_solution[j], new_solution[(j+1)%n]]):\n                improved = True\n                break\n        if improved:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7219180317480184,
            2.912704873085022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.std(normalized, axis=1)\n    improvement_scores = np.sum(1 - normalized, axis=1)\n    combined_scores = 0.6 * improvement_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator\n    # 1. Adaptive node swapping based on objective improvements\n    for _ in range(random.randint(1, 3)):\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement across all objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment inversion with objective-aware selection\n    segment_size = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size - 1\n    # Evaluate segment inversion impact\n    current_segment_cost = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_1[new_solution[end], new_solution[(end+1)%n]] +\n                            distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_2[new_solution[end], new_solution[(end+1)%n]] +\n                            distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_3[new_solution[end], new_solution[(end+1)%n]])\n    inverted_segment_cost = (distance_matrix_1[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_1[new_solution[start], new_solution[(end+1)%n]] +\n                            distance_matrix_2[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_2[new_solution[start], new_solution[(end+1)%n]] +\n                            distance_matrix_3[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_3[new_solution[start], new_solution[(end+1)%n]])\n    if inverted_segment_cost < current_segment_cost:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Adaptive perturbation based on objective balance\n    perturbation_intensity = random.uniform(0.2, 0.5)\n    for _ in range(int(perturbation_intensity * n)):\n        i, j = random.sample(range(n), 2)\n        # Only perform swap if it improves at least one objective\n        improved = False\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            if (dm[new_solution[i-1], new_solution[j]] + dm[new_solution[j], new_solution[(i+1)%n]] +\n                dm[new_solution[j-1], new_solution[i]] + dm[new_solution[i], new_solution[(j+1)%n]]) < \\\n               (dm[new_solution[i-1], new_solution[i]] + dm[new_solution[i], new_solution[(i+1)%n]] +\n                dm[new_solution[j-1], new_solution[j]] + dm[new_solution[j], new_solution[(j+1)%n]]):\n                improved = True\n                break\n        if improved:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 3-opt and objective-driven segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Insert segment at new position and evaluate\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of node swapping and objective-aware segment relocation, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering and segment reversal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply node swapping with objective-aware selection\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        original_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    # Perform segment relocation with objective awareness\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Apply segment reversal if beneficial\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7263757454203902,
            2.3475817680358886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply node swapping with objective-aware selection\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        original_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    # Perform segment relocation with objective awareness\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Apply segment reversal if beneficial\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by applying a hybrid of 2-opt and node insertion, ensuring feasibility while balancing exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the first objective\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: 2-opt with node insertion\n    if random.random() < 0.5:\n        # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7148198414275513,
            0.6169394612312317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the first objective\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: 2-opt with node insertion\n    if random.random() < 0.5:\n        # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware segment swap and 2-opt operation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        # Calculate diversity score\n        diversity_scores = np.std(normalized, axis=0)\n        weights = diversity_scores / diversity_scores.sum()\n        # Weighted random selection\n        probs = np.array([np.dot(weights, obj) for _, obj in archive])\n        probs = probs / probs.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap\n    if n >= 4:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - 4)\n        seg1_end = random.randint(seg1_start + 1, n - 3)\n        seg2_start = random.randint(seg1_end + 1, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n\n        # Swap segments\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Perform 2-opt\n    if n >= 4:\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 1, n - 2)\n        if j > i + 1:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7266536578759943,
            2.8537062883377073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        # Calculate diversity score\n        diversity_scores = np.std(normalized, axis=0)\n        weights = diversity_scores / diversity_scores.sum()\n        # Weighted random selection\n        probs = np.array([np.dot(weights, obj) for _, obj in archive])\n        probs = probs / probs.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap\n    if n >= 4:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - 4)\n        seg1_end = random.randint(seg1_start + 1, n - 3)\n        seg2_start = random.randint(seg1_end + 1, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n\n        # Swap segments\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Perform 2-opt\n    if n >= 4:\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 1, n - 2)\n        if j > i + 1:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighting objectives to balance their importance\n    base_solution = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel hybrid operator: 3-opt with random segment reversal for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and i-k\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Randomly select a segment to reverse if it improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Reverse segment a-b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert reversal if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6244452926451227,
            2.3325910210609435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weighting objectives to balance their importance\n    base_solution = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel hybrid operator: 3-opt with random segment reversal for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and i-k\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Randomly select a segment to reverse if it improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Reverse segment a-b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert reversal if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm implements a multi-objective-aware node sequence transformation that intelligently selects a solution from the archive based on its objective diversity and applies a hybrid local search combining edge swaps, segment rotations, and adaptive node reinsertion to balance exploration and exploitation across all three objectives while ensuring tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]) - min(archive[i][1]))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on solution's objective values\n    obj_values = archive[selected_idx][1]\n    total = sum(obj_values)\n    weights = [obj/total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Perform hybrid local search operations\n    # 1. Edge swap with multi-objective consideration\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Calculate potential improvement\n    def calculate_improvement(a, b, c, d):\n        old_cost = (weights[0] * (distance_matrix_1[a,b] + distance_matrix_1[c,d]) +\n                    weights[1] * (distance_matrix_2[a,b] + distance_matrix_2[c,d]) +\n                    weights[2] * (distance_matrix_3[a,b] + distance_matrix_3[c,d]))\n        new_cost = (weights[0] * (distance_matrix_1[a,d] + distance_matrix_1[c,b]) +\n                    weights[1] * (distance_matrix_2[a,d] + distance_matrix_2[c,b]) +\n                    weights[2] * (distance_matrix_3[a,d] + distance_matrix_3[c,b]))\n        return new_cost - old_cost\n\n    a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0]\n    improvement = calculate_improvement(a, b, c, d)\n\n    if improvement < 0:\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # 2. Segment rotation\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+2, n-1))\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n\n    # Evaluate rotation\n    old_cost = (weights[0] * (distance_matrix_1[new_solution[seg_start-1], segment[0]] +\n                               distance_matrix_1[segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[1] * (distance_matrix_2[new_solution[seg_start-1], segment[0]] +\n                             distance_matrix_2[segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[2] * (distance_matrix_3[new_solution[seg_start-1], segment[0]] +\n                             distance_matrix_3[segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]))\n\n    new_cost = (weights[0] * (distance_matrix_1[new_solution[seg_start-1], rotated_segment[0]] +\n                             distance_matrix_1[rotated_segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[1] * (distance_matrix_2[new_solution[seg_start-1], rotated_segment[0]] +\n                             distance_matrix_2[rotated_segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[2] * (distance_matrix_3[new_solution[seg_start-1], rotated_segment[0]] +\n                             distance_matrix_3[rotated_segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]))\n\n    if new_cost < old_cost:\n        new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # 3. Adaptive node reinsertion\n    if n >= 5:\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find best insertion point considering all objectives\n        best_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(1, n-1):\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            old_cost = (weights[0] * distance_matrix_1[prev_node, next_node] +\n                        weights[1] * distance_matrix_2[prev_node, next_node] +\n                        weights[2] * distance_matrix_3[prev_node, next_node])\n\n            new_cost = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) +\n                        weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) +\n                        weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]))\n\n            improvement = new_cost - old_cost\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6730027585499354,
            0.7179925084114075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]) - min(archive[i][1]))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on solution's objective values\n    obj_values = archive[selected_idx][1]\n    total = sum(obj_values)\n    weights = [obj/total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Perform hybrid local search operations\n    # 1. Edge swap with multi-objective consideration\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Calculate potential improvement\n    def calculate_improvement(a, b, c, d):\n        old_cost = (weights[0] * (distance_matrix_1[a,b] + distance_matrix_1[c,d]) +\n                    weights[1] * (distance_matrix_2[a,b] + distance_matrix_2[c,d]) +\n                    weights[2] * (distance_matrix_3[a,b] + distance_matrix_3[c,d]))\n        new_cost = (weights[0] * (distance_matrix_1[a,d] + distance_matrix_1[c,b]) +\n                    weights[1] * (distance_matrix_2[a,d] + distance_matrix_2[c,b]) +\n                    weights[2] * (distance_matrix_3[a,d] + distance_matrix_3[c,b]))\n        return new_cost - old_cost\n\n    a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0]\n    improvement = calculate_improvement(a, b, c, d)\n\n    if improvement < 0:\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # 2. Segment rotation\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+2, n-1))\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n\n    # Evaluate rotation\n    old_cost = (weights[0] * (distance_matrix_1[new_solution[seg_start-1], segment[0]] +\n                               distance_matrix_1[segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[1] * (distance_matrix_2[new_solution[seg_start-1], segment[0]] +\n                             distance_matrix_2[segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[2] * (distance_matrix_3[new_solution[seg_start-1], segment[0]] +\n                             distance_matrix_3[segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]))\n\n    new_cost = (weights[0] * (distance_matrix_1[new_solution[seg_start-1], rotated_segment[0]] +\n                             distance_matrix_1[rotated_segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[1] * (distance_matrix_2[new_solution[seg_start-1], rotated_segment[0]] +\n                             distance_matrix_2[rotated_segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]) +\n                weights[2] * (distance_matrix_3[new_solution[seg_start-1], rotated_segment[0]] +\n                             distance_matrix_3[rotated_segment[-1], new_solution[seg_end+1] if seg_end+1 < n else new_solution[0]]))\n\n    if new_cost < old_cost:\n        new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # 3. Adaptive node reinsertion\n    if n >= 5:\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find best insertion point considering all objectives\n        best_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(1, n-1):\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            old_cost = (weights[0] * distance_matrix_1[prev_node, next_node] +\n                        weights[1] * distance_matrix_2[prev_node, next_node] +\n                        weights[2] * distance_matrix_3[prev_node, next_node])\n\n            new_cost = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) +\n                        weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) +\n                        weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]))\n\n            improvement = new_cost - old_cost\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a base solution from the archive, applies a 2-opt move followed by a segment reversal, and performs a random swap only if it improves at least one of the three objectives, ensuring feasibility while promoting multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a random swap if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.46045227578246395,
            1.8704161882400512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a random swap if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 3-opt and objective-driven segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Insert segment at new position and evaluate\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a hybrid of adaptive segment rotation and objective-weighted node swaps, and evaluates improvements across all three objectives while dynamically reordering segments to ensure feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on relative improvement potential\n    obj_weights = [1, 1, 1]\n    for i in range(3):\n        obj_values = [x[1][i] for x in archive]\n        if max(obj_values) > min(obj_values):\n            obj_weights[i] = 1 / (max(obj_values) - min(obj_values))\n\n    # Perform adaptive segment rotation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-weighted node swaps\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Calculate weighted improvement\n        weighted_improvement = sum((original - new) * weight\n                                for (original, new), weight in zip(zip(original_costs, new_costs), obj_weights))\n\n        # Revert swap if no improvement\n        if weighted_improvement <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment reordering\n    if random.random() < 0.3:\n        x, y = sorted(random.sample(range(n), 2))\n        segment = new_solution[x:y+1]\n        new_solution = np.concatenate([new_solution[:x], segment[::-1], new_solution[y+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5597033197907466,
            2.625438964366913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on relative improvement potential\n    obj_weights = [1, 1, 1]\n    for i in range(3):\n        obj_values = [x[1][i] for x in archive]\n        if max(obj_values) > min(obj_values):\n            obj_weights[i] = 1 / (max(obj_values) - min(obj_values))\n\n    # Perform adaptive segment rotation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-weighted node swaps\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Calculate weighted improvement\n        weighted_improvement = sum((original - new) * weight\n                                for (original, new), weight in zip(zip(original_costs, new_costs), obj_weights))\n\n        # Revert swap if no improvement\n        if weighted_improvement <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment reordering\n    if random.random() < 0.3:\n        x, y = sorted(random.sample(range(n), 2))\n        segment = new_solution[x:y+1]\n        new_solution = np.concatenate([new_solution[:x], segment[::-1], new_solution[y+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment inversion with dynamic objective-aware segment replacement, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, inverts the worst segment, and replaces it with a segment from a randomly selected promising solution in the archive, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Randomly select a different solution from the archive\n    if len(archive) > 1:\n        donor_solution, _ = random.choice([s for s in archive if not np.array_equal(s[0], base_solution)])\n    else:\n        donor_solution = base_solution.copy()\n\n    # Partition both solutions into segments\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n    base_segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n    donor_segments = [donor_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution in base solution\n    segment_costs = []\n    for seg in base_segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment in base solution\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Invert the worst segment\n    base_segments[worst_seg_idx] = base_segments[worst_seg_idx][::-1]\n\n    # Replace the worst segment with a random segment from donor solution\n    if len(donor_segments) > 0:\n        base_segments[worst_seg_idx] = random.choice(donor_segments)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(base_segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6765364144776517,
            2.3794963479042055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Randomly select a different solution from the archive\n    if len(archive) > 1:\n        donor_solution, _ = random.choice([s for s in archive if not np.array_equal(s[0], base_solution)])\n    else:\n        donor_solution = base_solution.copy()\n\n    # Partition both solutions into segments\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n    base_segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n    donor_segments = [donor_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution in base solution\n    segment_costs = []\n    for seg in base_segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment in base solution\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Invert the worst segment\n    base_segments[worst_seg_idx] = base_segments[worst_seg_idx][::-1]\n\n    # Replace the worst segment with a random segment from donor solution\n    if len(donor_segments) > 0:\n        base_segments[worst_seg_idx] = random.choice(donor_segments)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(base_segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 3-opt and objective-driven segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Insert segment at new position and evaluate\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of node insertion and objective-driven segment rotation, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    for _ in range(3):\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n\n        node = new_solution[a]\n        temp_solution = np.delete(new_solution, a)\n        temp_solution = np.insert(temp_solution, b, node)\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6338770039940005,
            2.795202147960663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    for _ in range(3):\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n\n        node = new_solution[a]\n        temp_solution = np.delete(new_solution, a)\n        temp_solution = np.insert(temp_solution, b, node)\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 3-opt and objective-driven segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering and dominance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        temp_solution = new_solution.copy()\n\n        # Insert segment at different position\n        temp_solution = np.concatenate([temp_solution[:c], segment, temp_solution[c:]])\n        if len(temp_solution) > n:\n            temp_solution = temp_solution[:n]\n\n        # Ensure feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.729408767172002,
            2.115543043613434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        temp_solution = new_solution.copy()\n\n        # Insert segment at different position\n        temp_solution = np.concatenate([temp_solution[:c], segment, temp_solution[c:]])\n        if len(temp_solution) > n:\n            temp_solution = temp_solution[:n]\n\n        # Ensure feasibility\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware edge insertion, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs segment-based crossover while inserting high-quality edges from other solutions based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments (random size between 3 and 5)\n    segment_size = random.randint(3, 5)\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range((n + segment_size - 1) // segment_size)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the best segment to preserve\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_segment = segments[best_seg_idx]\n\n    # Create a new solution by combining segments from other solutions with edge insertion\n    new_segments = []\n    for sol, _ in random.sample(archive, min(3, len(archive))):\n        # Extract random segments from other solutions\n        for i in range(len(sol) // segment_size):\n            seg = sol[i*segment_size:(i+1)*segment_size]\n            new_segments.append(seg)\n\n    # Randomly select segments for the new solution\n    selected_segments = random.sample(new_segments, min(3, len(new_segments)))\n    selected_segments.append(best_segment)\n    random.shuffle(selected_segments)\n\n    # Reconstruct the solution with edge insertion\n    new_solution = np.concatenate(selected_segments)\n\n    # Insert high-quality edges from other solutions\n    for sol, _ in random.sample(archive, min(2, len(archive))):\n        # Find edges with low weighted cost\n        for i in range(1, len(sol)):\n            u, v = sol[i-1], sol[i]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            cost3 = distance_matrix_3[u, v]\n            weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n            if weighted_cost < 100 and random.random() < 0.3:\n                # Try to insert this edge into the new solution\n                if u in new_solution and v in new_solution:\n                    idx_u = np.where(new_solution == u)[0][0]\n                    idx_v = np.where(new_solution == v)[0][0]\n                    if abs(idx_u - idx_v) > 1:\n                        # Reverse the segment between u and v\n                        if idx_u > idx_v:\n                            idx_u, idx_v = idx_v, idx_u\n                        new_solution[idx_u:idx_v+1] = new_solution[idx_u:idx_v+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6618346115862683,
            1.334336805343628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments (random size between 3 and 5)\n    segment_size = random.randint(3, 5)\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range((n + segment_size - 1) // segment_size)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the best segment to preserve\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_segment = segments[best_seg_idx]\n\n    # Create a new solution by combining segments from other solutions with edge insertion\n    new_segments = []\n    for sol, _ in random.sample(archive, min(3, len(archive))):\n        # Extract random segments from other solutions\n        for i in range(len(sol) // segment_size):\n            seg = sol[i*segment_size:(i+1)*segment_size]\n            new_segments.append(seg)\n\n    # Randomly select segments for the new solution\n    selected_segments = random.sample(new_segments, min(3, len(new_segments)))\n    selected_segments.append(best_segment)\n    random.shuffle(selected_segments)\n\n    # Reconstruct the solution with edge insertion\n    new_solution = np.concatenate(selected_segments)\n\n    # Insert high-quality edges from other solutions\n    for sol, _ in random.sample(archive, min(2, len(archive))):\n        # Find edges with low weighted cost\n        for i in range(1, len(sol)):\n            u, v = sol[i-1], sol[i]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            cost3 = distance_matrix_3[u, v]\n            weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n            if weighted_cost < 100 and random.random() < 0.3:\n                # Try to insert this edge into the new solution\n                if u in new_solution and v in new_solution:\n                    idx_u = np.where(new_solution == u)[0][0]\n                    idx_v = np.where(new_solution == v)[0][0]\n                    if abs(idx_u - idx_v) > 1:\n                        # Reverse the segment between u and v\n                        if idx_u > idx_v:\n                            idx_u, idx_v = idx_v, idx_u\n                        new_solution[idx_u:idx_v+1] = new_solution[idx_u:idx_v+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel multi-objective local search algorithm that selects solutions based on a weighted dominance score, applies a hybrid of 4-opt and adaptive segment reversal, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted dominance score\n    weights = [0.4, 0.3, 0.3]  # Weighted importance for objectives\n    base_solution, base_costs = min(archive, key=lambda x: sum(w * c for w, c in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse the middle segment\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform adaptive segment reversals based on objective improvement\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Revert reversal if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7610821210722459,
            2.2490593671798704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted dominance score\n    weights = [0.4, 0.3, 0.3]  # Weighted importance for objectives\n    base_solution, base_costs = min(archive, key=lambda x: sum(w * c for w, c in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse the middle segment\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform adaptive segment reversals based on objective improvement\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Revert reversal if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective-aware two-opt-inspired operator that selectively applies segment inversions based on their potential to simultaneously improve all three objectives, combined with a dynamic segment selection mechanism that adapts to the current solution's objective profile, ensuring balanced exploration of the search space while maintaining tour feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, objectives = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective balance\n    segment_size = n // 4\n    if segment_size < 2:\n        segment_size = 2\n\n    # Evaluate potential segments for inversion\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate original and inverted segment costs\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        # Apply inversion if it improves all objectives\n        if (inv_cost1 < orig_cost1 and inv_cost2 < orig_cost2 and inv_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: (sum(x[1]) - (max(x[1]) + min(x[1]))) / (len(x[1]) + 1))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = max(2, n // 3)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        if (inv_cost1 <= orig_cost1 and inv_cost2 <= orig_cost2 and inv_cost3 <= orig_cost3 and\n            (inv_cost1 < orig_cost1 or inv_cost2 < orig_cost2 or inv_cost3 < orig_cost3)):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7331294949860692,
            0.6422614812850952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: (sum(x[1]) - (max(x[1]) + min(x[1]))) / (len(x[1]) + 1))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = max(2, n // 3)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        if (inv_cost1 <= orig_cost1 and inv_cost2 <= orig_cost2 and inv_cost3 <= orig_cost3 and\n            (inv_cost1 < orig_cost1 or inv_cost2 < orig_cost2 or inv_cost3 < orig_cost3)):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective-aware segment rotation operator that selectively applies segment rotations based on their potential to simultaneously improve all three objectives, combined with an adaptive segment selection mechanism that prioritizes nodes with the highest objective diversity, ensuring balanced exploration while maintaining tour feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = n // 3\n    if segment_size < 2:\n        segment_size = 2\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        rotated_segment = np.roll(segment, 1)\n        rot_cost1 = sum(distance_matrix_1[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost2 = sum(distance_matrix_2[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost3 = sum(distance_matrix_3[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n\n        if (rot_cost1 < orig_cost1 and rot_cost2 < orig_cost2 and rot_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = rotated_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This new algorithm employs an adaptive segment inversion operator that dynamically selects segments based on their potential to improve at least two out of three objectives, combined with a multi-objective-aware segment selection mechanism that prioritizes nodes with the highest objective diversity, ensuring balanced exploration while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = max(2, n // 4)\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        improvements = sum([1 for a, b in zip([inv_cost1, inv_cost2, inv_cost3], [orig_cost1, orig_cost2, orig_cost3]) if a < b])\n        if improvements >= 2:\n            new_solution[i:i+segment_size] = inverted_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6504186988143735,
            0.6150364518165589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = max(2, n // 4)\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        improvements = sum([1 for a, b in zip([inv_cost1, inv_cost2, inv_cost3], [orig_cost1, orig_cost2, orig_cost3]) if a < b])\n        if improvements >= 2:\n            new_solution[i:i+segment_size] = inverted_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 3-opt and objective-driven segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Insert segment at new position and evaluate\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines a novel hybrid of 4-opt and objective-driven edge swapping, with dynamic segment reinsertion and Pareto-dominance guided selection to balance improvements across all three objectives while maintaining tour feasibility through constrained node permutations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best overall improvement potential\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]) / max(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        # Simple swap for small tours\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply 4-opt move with constrained segment reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reconstruct solution with segments reversed and reinserted\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2[::-1],\n        new_solution[b+1:c],\n        segment1[::-1],\n        new_solution[d+1:]\n    ])\n\n    # Calculate original and new costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-driven edge swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves and not dominated\n        if (any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) and\n            not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8365967435911348,
            2.372413969039917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best overall improvement potential\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]) / max(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        # Simple swap for small tours\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply 4-opt move with constrained segment reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reconstruct solution with segments reversed and reinserted\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2[::-1],\n        new_solution[b+1:c],\n        segment1[::-1],\n        new_solution[d+1:]\n    ])\n\n    # Calculate original and new costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-driven edge swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves and not dominated\n        if (any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) and\n            not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment swapping and objective-aware node redistribution strategy, where it dynamically partitions the tour into segments based on objective contributions, performs segment swaps weighted by their individual objective improvements, and redistributes nodes between segments to balance the objectives while maintaining feasibility through a novel node reassignment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments based on objective contributions\n    segment_size = max(2, n // 3)\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(3)]\n\n    # Evaluate each segment's objective contributions\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Find the segment with the highest weighted cost\n    weighted_costs = [\n        weights[0]*c1 + weights[1]*c2 + weights[2]*c3\n        for c1, c2, c3 in segment_costs\n    ]\n    worst_seg_idx = weighted_costs.index(max(weighted_costs))\n\n    # Find the segment with the lowest weighted cost\n    best_seg_idx = weighted_costs.index(min(weighted_costs))\n\n    # Perform segment swap\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Redistribute nodes between segments to balance objectives\n    for i in range(3):\n        if len(segments[i]) > 2:\n            # Move a node from this segment to another\n            node_idx = random.randint(1, len(segments[i])-1)\n            node = segments[i][node_idx]\n            segments[i] = np.delete(segments[i], node_idx)\n\n            # Choose target segment based on objective weights\n            target_seg = random.choices(\n                [j for j in range(3) if j != i],\n                weights=[weights[j] for j in range(3) if j != i]\n            )[0]\n\n            # Insert node in target segment\n            insert_pos = random.randint(1, len(segments[target_seg])-1)\n            segments[target_seg] = np.insert(segments[target_seg], insert_pos, node)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6574015728528608,
            0.6140592336654663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments based on objective contributions\n    segment_size = max(2, n // 3)\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(3)]\n\n    # Evaluate each segment's objective contributions\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Find the segment with the highest weighted cost\n    weighted_costs = [\n        weights[0]*c1 + weights[1]*c2 + weights[2]*c3\n        for c1, c2, c3 in segment_costs\n    ]\n    worst_seg_idx = weighted_costs.index(max(weighted_costs))\n\n    # Find the segment with the lowest weighted cost\n    best_seg_idx = weighted_costs.index(min(weighted_costs))\n\n    # Perform segment swap\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Redistribute nodes between segments to balance objectives\n    for i in range(3):\n        if len(segments[i]) > 2:\n            # Move a node from this segment to another\n            node_idx = random.randint(1, len(segments[i])-1)\n            node = segments[i][node_idx]\n            segments[i] = np.delete(segments[i], node_idx)\n\n            # Choose target segment based on objective weights\n            target_seg = random.choices(\n                [j for j in range(3) if j != i],\n                weights=[weights[j] for j in range(3) if j != i]\n            )[0]\n\n            # Insert node in target segment\n            insert_pos = random.randint(1, len(segments[target_seg])-1)\n            segments[target_seg] = np.insert(segments[target_seg], insert_pos, node)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 3-opt and objective-driven segment insertion, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment insertion\n    for _ in range(3):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Insert segment at new position and evaluate\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{A novel multi-objective local search algorithm that combines adaptive segment relocation with objective-balanced edge swaps, dynamically prioritizing improvement in the most underperforming objective while maintaining tour feasibility through constrained node reordering}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj_index = np.argmax([sum(x[1]) for x in archive])\n    base_solution, base_obj = archive[worst_obj_index]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Identify the objective with the highest cost\n    obj_costs = [sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                 sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                 sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))]\n    worst_obj = np.argmax(obj_costs)\n\n    # Adaptive segment relocation focused on the worst objective\n    segment_length = max(2, min(5, n // 5))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Find insertion point that maximizes improvement in worst objective\n    best_improvement = 0\n    best_pos = start\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos <= start + segment_length:\n            continue\n\n        temp_solution = np.concatenate([\n            new_solution[:start], new_solution[start+segment_length:pos],\n            segment, new_solution[pos:]\n        ])\n\n        if worst_obj == 0:\n            new_cost = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        elif worst_obj == 1:\n            new_cost = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        else:\n            new_cost = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        improvement = obj_costs[worst_obj] - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best relocation\n    if best_improvement > 0:\n        new_solution = np.concatenate([\n            new_solution[:start], new_solution[start+segment_length:best_pos],\n            segment, new_solution[best_pos:]\n        ])\n\n    # Perform objective-balanced edge swaps\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Accept if it improves the worst objective or balances other objectives\n        if (new_costs[worst_obj] < original_costs[worst_obj]) or \\\n           (sum(new_costs) < sum(original_costs) and\n            all(new_cost <= original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            continue\n        else:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5747689183235026,
            2.047014319896698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj_index = np.argmax([sum(x[1]) for x in archive])\n    base_solution, base_obj = archive[worst_obj_index]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Identify the objective with the highest cost\n    obj_costs = [sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                 sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                 sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))]\n    worst_obj = np.argmax(obj_costs)\n\n    # Adaptive segment relocation focused on the worst objective\n    segment_length = max(2, min(5, n // 5))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Find insertion point that maximizes improvement in worst objective\n    best_improvement = 0\n    best_pos = start\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos <= start + segment_length:\n            continue\n\n        temp_solution = np.concatenate([\n            new_solution[:start], new_solution[start+segment_length:pos],\n            segment, new_solution[pos:]\n        ])\n\n        if worst_obj == 0:\n            new_cost = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        elif worst_obj == 1:\n            new_cost = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        else:\n            new_cost = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        improvement = obj_costs[worst_obj] - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best relocation\n    if best_improvement > 0:\n        new_solution = np.concatenate([\n            new_solution[:start], new_solution[start+segment_length:best_pos],\n            segment, new_solution[best_pos:]\n        ])\n\n    # Perform objective-balanced edge swaps\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Accept if it improves the worst objective or balances other objectives\n        if (new_costs[worst_obj] < original_costs[worst_obj]) or \\\n           (sum(new_costs) < sum(original_costs) and\n            all(new_cost <= original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            continue\n        else:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This new algorithm combines the strengths of both existing approaches by first selecting a solution with high objective diversity, then applying a multi-objective-aware segment rotation and adaptive node insertion, ensuring feasibility while balancing exploration of the solution space with exploitation of promising regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]) - min(archive[i][1]))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment rotation\n    segment_length = random.randint(2, min(4, n-1))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    rotation = random.randint(1, segment_length - 1)\n    new_solution[start:end+1] = np.roll(new_solution[start:end+1], rotation)\n\n    # Perform adaptive node insertion based on objective improvement\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Store original costs\n        original_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Perform insertion\n        node = new_solution[j]\n        temp_solution = np.delete(new_solution, j)\n        temp_solution = np.insert(temp_solution, i, node)\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5000160292499176,
            2.3801712512969972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]) - min(archive[i][1]))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment rotation\n    segment_length = random.randint(2, min(4, n-1))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length - 1\n    rotation = random.randint(1, segment_length - 1)\n    new_solution[start:end+1] = np.roll(new_solution[start:end+1], rotation)\n\n    # Perform adaptive node insertion based on objective improvement\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Store original costs\n        original_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Perform insertion\n        node = new_solution[j]\n        temp_solution = np.delete(new_solution, j)\n        temp_solution = np.insert(temp_solution, i, node)\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{An enhanced multi-objective local search algorithm that dynamically selects solutions based on Pareto dominance and applies a novel combination of 2-opt and adaptive edge swapping, prioritizing solutions that show potential for balanced improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move: select two distinct edges and swap their connections\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive edge swaps based on objective improvement\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) < 2:\n            continue  # Skip if edges are adjacent to maintain feasibility\n\n        # Swap edges between a and b\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.779122600819906,
            2.1249900341033934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move: select two distinct edges and swap their connections\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive edge swaps based on objective improvement\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) < 2:\n            continue  # Skip if edges are adjacent to maintain feasibility\n\n        # Swap edges between a and b\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective-aware segment rotation operator that selectively applies segment rotations based on their potential to simultaneously improve all three objectives, combined with an adaptive segment selection mechanism that prioritizes nodes with the highest objective diversity, ensuring balanced exploration while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_size = n // 3\n    if segment_size < 2:\n        segment_size = 2\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        rotated_segment = np.roll(segment, 1)\n        rot_cost1 = sum(distance_matrix_1[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost2 = sum(distance_matrix_2[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n        rot_cost3 = sum(distance_matrix_3[rotated_segment[j-1], rotated_segment[j]] for j in range(1, len(rotated_segment)))\n\n        if (rot_cost1 < orig_cost1 and rot_cost2 < orig_cost2 and rot_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = rotated_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This new algorithm employs a multi-objective-aware node insertion and removal operator that strategically inserts and removes nodes based on their potential to create Pareto-improving segments across all three objectives, combined with a dynamic segment selection mechanism that prioritizes nodes with the highest objective diversity while maintaining tour feasibility through a constrained search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i < 2:\n        return new_solution\n\n    segment = new_solution[i:j+1]\n    segment_costs = [\n        sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))),\n        sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))),\n        sum(distance_matrix_3[segment[k-1], segment[k]] for k in range(1, len(segment)))\n    ]\n\n    best_insert_pos = -1\n    best_cost_improvement = [0, 0, 0]\n\n    for pos in range(n):\n        if pos >= i and pos <= j+1:\n            continue\n\n        temp_solution = np.delete(new_solution, i)\n        temp_solution = np.insert(temp_solution, pos, segment)\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n        ]\n\n        cost_improvement = [segment_costs[k] - new_costs[k] for k in range(3)]\n\n        if all(impr > 0 for impr in cost_improvement):\n            if sum(cost_improvement) > sum(best_cost_improvement):\n                best_insert_pos = pos\n                best_cost_improvement = cost_improvement\n\n    if best_insert_pos != -1:\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7580940658955994,
            2.6573201179504395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i < 2:\n        return new_solution\n\n    segment = new_solution[i:j+1]\n    segment_costs = [\n        sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))),\n        sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))),\n        sum(distance_matrix_3[segment[k-1], segment[k]] for k in range(1, len(segment)))\n    ]\n\n    best_insert_pos = -1\n    best_cost_improvement = [0, 0, 0]\n\n    for pos in range(n):\n        if pos >= i and pos <= j+1:\n            continue\n\n        temp_solution = np.delete(new_solution, i)\n        temp_solution = np.insert(temp_solution, pos, segment)\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n        ]\n\n        cost_improvement = [segment_costs[k] - new_costs[k] for k in range(3)]\n\n        if all(impr > 0 for impr in cost_improvement):\n            if sum(cost_improvement) > sum(best_cost_improvement):\n                best_insert_pos = pos\n                best_cost_improvement = cost_improvement\n\n    if best_insert_pos != -1:\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional node reinsertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster nodes based on their positions in all three spaces\n    clusters = []\n    for i in range(0, n, 3):\n        clusters.append(new_solution[i:i+3])\n\n    # Shuffle clusters to explore different configurations\n    random.shuffle(clusters)\n    new_solution = np.concatenate(clusters)\n\n    # Perform adaptive segment reversal\n    for _ in range(2):\n        i = random.randint(0, len(clusters) - 1)\n        cluster = clusters[i]\n\n        # Reverse the cluster in one of the three spaces\n        space = random.randint(1, 3)\n        if space == 1:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_1[cluster[0], x])\n        elif space == 2:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_2[cluster[0], x])\n        else:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_3[cluster[0], x])\n\n        # Randomly decide to reverse or not\n        if random.random() < 0.7:\n            cluster_order = cluster_order[::-1]\n\n        clusters[i] = cluster_order\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(clusters)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6815072479007493,
            0.39972691535949706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster nodes based on their positions in all three spaces\n    clusters = []\n    for i in range(0, n, 3):\n        clusters.append(new_solution[i:i+3])\n\n    # Shuffle clusters to explore different configurations\n    random.shuffle(clusters)\n    new_solution = np.concatenate(clusters)\n\n    # Perform adaptive segment reversal\n    for _ in range(2):\n        i = random.randint(0, len(clusters) - 1)\n        cluster = clusters[i]\n\n        # Reverse the cluster in one of the three spaces\n        space = random.randint(1, 3)\n        if space == 1:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_1[cluster[0], x])\n        elif space == 2:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_2[cluster[0], x])\n        else:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_3[cluster[0], x])\n\n        # Randomly decide to reverse or not\n        if random.random() < 0.7:\n            cluster_order = cluster_order[::-1]\n\n        clusters[i] = cluster_order\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(clusters)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node insertion and removal strategy with dynamic objective-weighted path optimization, where it intelligently selects and reinserts nodes based on their weighted contributions to each objective, while dynamically optimizing paths between nodes to improve solutions across all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(candidates)-1, int(len(candidates)*0.2))\n    base_solution = candidates[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current objectives\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select a random node to remove and reinsert\n    remove_idx = random.randint(1, n-2)\n    node_to_remove = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Find the best insertion position based on weighted distance\n    best_pos = -1\n    best_weighted_cost = float('inf')\n\n    for i in range(1, len(new_solution)):\n        # Insert node between i-1 and i\n        temp_tour = np.insert(new_solution, i, node_to_remove)\n\n        # Calculate weighted cost\n        cost1 = sum(distance_matrix_1[temp_tour[j-1], temp_tour[j]] for j in range(len(temp_tour)))\n        cost2 = sum(distance_matrix_2[temp_tour[j-1], temp_tour[j]] for j in range(len(temp_tour)))\n        cost3 = sum(distance_matrix_3[temp_tour[j-1], temp_tour[j]] for j in range(len(temp_tour)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost < best_weighted_cost:\n            best_weighted_cost = weighted_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node_to_remove)\n\n    # Perform path optimization between adjacent nodes\n    for i in range(1, len(new_solution)-1):\n        a, b, c = new_solution[i-1], new_solution[i], new_solution[i+1]\n\n        # Calculate current path cost\n        current_cost1 = distance_matrix_1[a,b] + distance_matrix_1[b,c]\n        current_cost2 = distance_matrix_2[a,b] + distance_matrix_2[b,c]\n        current_cost3 = distance_matrix_3[a,b] + distance_matrix_3[b,c]\n        current_weighted_cost = weights[0]*current_cost1 + weights[1]*current_cost2 + weights[2]*current_cost3\n\n        # Try reversing the path through b\n        new_cost1 = distance_matrix_1[a,c] + distance_matrix_1[c,b]\n        new_cost2 = distance_matrix_2[a,c] + distance_matrix_2[c,b]\n        new_cost3 = distance_matrix_3[a,c] + distance_matrix_3[c,b]\n        new_weighted_cost = weights[0]*new_cost1 + weights[1]*new_cost2 + weights[2]*new_cost3\n\n        if new_weighted_cost < current_weighted_cost:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7140370491671464,
            3.6183234572410585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(candidates)-1, int(len(candidates)*0.2))\n    base_solution = candidates[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current objectives\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select a random node to remove and reinsert\n    remove_idx = random.randint(1, n-2)\n    node_to_remove = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Find the best insertion position based on weighted distance\n    best_pos = -1\n    best_weighted_cost = float('inf')\n\n    for i in range(1, len(new_solution)):\n        # Insert node between i-1 and i\n        temp_tour = np.insert(new_solution, i, node_to_remove)\n\n        # Calculate weighted cost\n        cost1 = sum(distance_matrix_1[temp_tour[j-1], temp_tour[j]] for j in range(len(temp_tour)))\n        cost2 = sum(distance_matrix_2[temp_tour[j-1], temp_tour[j]] for j in range(len(temp_tour)))\n        cost3 = sum(distance_matrix_3[temp_tour[j-1], temp_tour[j]] for j in range(len(temp_tour)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost < best_weighted_cost:\n            best_weighted_cost = weighted_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node_to_remove)\n\n    # Perform path optimization between adjacent nodes\n    for i in range(1, len(new_solution)-1):\n        a, b, c = new_solution[i-1], new_solution[i], new_solution[i+1]\n\n        # Calculate current path cost\n        current_cost1 = distance_matrix_1[a,b] + distance_matrix_1[b,c]\n        current_cost2 = distance_matrix_2[a,b] + distance_matrix_2[b,c]\n        current_cost3 = distance_matrix_3[a,b] + distance_matrix_3[b,c]\n        current_weighted_cost = weights[0]*current_cost1 + weights[1]*current_cost2 + weights[2]*current_cost3\n\n        # Try reversing the path through b\n        new_cost1 = distance_matrix_1[a,c] + distance_matrix_1[c,b]\n        new_cost2 = distance_matrix_2[a,c] + distance_matrix_2[c,b]\n        new_cost3 = distance_matrix_3[a,c] + distance_matrix_3[c,b]\n        new_weighted_cost = weights[0]*new_cost1 + weights[1]*new_cost2 + weights[2]*new_cost3\n\n        if new_weighted_cost < current_weighted_cost:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel tri-objective local search algorithm that dynamically selects solutions from the archive based on Pareto dominance and applies a hybrid of 3-opt and objective-specific segment insertion to generate neighbors, while ensuring feasibility through adaptive node reordering and multi-objective improvement criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-specific segment insertion\n    for _ in range(2):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least two objectives improve\n        if sum(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) >= 2:\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.6294089192738753,
            2.363331747055054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply 3-opt move with segment insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-specific segment insertion\n    for _ in range(2):\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least two objectives improve\n        if sum(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) >= 2:\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment rotation with dynamic objective-aware segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs segment rotations and reversals based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment size (random between 3 and 5)\n    segment_size = random.randint(3, 5)\n    num_segments = max(1, n // segment_size)\n\n    # Partition the tour into segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Rotate the worst segment right by one position\n    segments[worst_seg_idx] = np.roll(segments[worst_seg_idx], 1)\n\n    # Reverse the best segment if it has high variance in contributions\n    if random.random() < 0.7:\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6304577085834436,
            0.6084497451782227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment size (random between 3 and 5)\n    segment_size = random.randint(3, 5)\n    num_segments = max(1, n // segment_size)\n\n    # Partition the tour into segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Rotate the worst segment right by one position\n    segments[worst_seg_idx] = np.roll(segments[worst_seg_idx], 1)\n\n    # Reverse the best segment if it has high variance in contributions\n    if random.random() < 0.7:\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An adaptive multi-objective local search algorithm that combines a novel hybrid of 4-opt and objective-driven edge swapping, with dynamic segment reinsertion and Pareto-dominance guided selection to balance improvements across all three objectives while maintaining tour feasibility through constrained node permutations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.array([])\n\n    # Select solution with best overall improvement potential\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]) / max(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        # Simple swap for small tours\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply 4-opt move with constrained segment reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reconstruct solution with segments reversed and reinserted\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2[::-1],\n        new_solution[b+1:c],\n        segment1[::-1],\n        new_solution[d+1:]\n    ])\n\n    # Calculate original and new costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-driven edge swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves and not dominated\n        if (any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) and\n            not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines a novel hybrid of node clustering and dynamic segment inversion, with Pareto-dominance guided selection and constrained edge reallocation to balance improvements across all three objectives while maintaining tour feasibility through constrained node permutations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best overall improvement potential\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]) / max(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster nodes based on their positions in all three objective spaces\n    clusters = {}\n    for i in range(n):\n        node = new_solution[i]\n        # Create a cluster key based on proximity in all three spaces\n        key = (int(instance[node, 0] // 10), int(instance[node, 1] // 10),\n               int(instance[node, 2] // 10), int(instance[node, 3] // 10))\n        if key not in clusters:\n            clusters[key] = []\n        clusters[key].append(i)\n\n    # Select a cluster to invert\n    cluster_keys = list(clusters.keys())\n    if not cluster_keys:\n        return new_solution\n\n    selected_key = random.choice(cluster_keys)\n    cluster_indices = clusters[selected_key]\n\n    # Invert the selected cluster segment\n    if len(cluster_indices) >= 2:\n        start, end = min(cluster_indices), max(cluster_indices)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform dynamic edge reallocation\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        ]\n\n        # Accept if not Pareto-dominated\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n\n        if not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.814301813435204,
            3.0234848499298095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best overall improvement potential\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]) / max(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster nodes based on their positions in all three objective spaces\n    clusters = {}\n    for i in range(n):\n        node = new_solution[i]\n        # Create a cluster key based on proximity in all three spaces\n        key = (int(instance[node, 0] // 10), int(instance[node, 1] // 10),\n               int(instance[node, 2] // 10), int(instance[node, 3] // 10))\n        if key not in clusters:\n            clusters[key] = []\n        clusters[key].append(i)\n\n    # Select a cluster to invert\n    cluster_keys = list(clusters.keys())\n    if not cluster_keys:\n        return new_solution\n\n    selected_key = random.choice(cluster_keys)\n    cluster_indices = clusters[selected_key]\n\n    # Invert the selected cluster segment\n    if len(cluster_indices) >= 2:\n        start, end = min(cluster_indices), max(cluster_indices)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform dynamic edge reallocation\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        ]\n\n        # Accept if not Pareto-dominated\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n\n        if not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.7873933197402302,
            3.2875623226165773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional node reinsertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster nodes based on their positions in all three spaces\n    clusters = []\n    for i in range(0, n, 3):\n        clusters.append(new_solution[i:i+3])\n\n    # Shuffle clusters to explore different configurations\n    random.shuffle(clusters)\n    new_solution = np.concatenate(clusters)\n\n    # Perform adaptive segment reversal\n    for _ in range(2):\n        i = random.randint(0, len(clusters) - 1)\n        cluster = clusters[i]\n\n        # Reverse the cluster in one of the three spaces\n        space = random.randint(1, 3)\n        if space == 1:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_1[cluster[0], x])\n        elif space == 2:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_2[cluster[0], x])\n        else:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_3[cluster[0], x])\n\n        # Randomly decide to reverse or not\n        if random.random() < 0.7:\n            cluster_order = cluster_order[::-1]\n\n        clusters[i] = cluster_order\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(clusters)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7231738685518546,
            0.3247414231300354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional node reinsertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster nodes based on their positions in all three spaces\n    clusters = []\n    for i in range(0, n, 3):\n        clusters.append(new_solution[i:i+3])\n\n    # Shuffle clusters to explore different configurations\n    random.shuffle(clusters)\n    new_solution = np.concatenate(clusters)\n\n    # Perform adaptive segment reversal\n    for _ in range(2):\n        i = random.randint(0, len(clusters) - 1)\n        cluster = clusters[i]\n\n        # Reverse the cluster in one of the three spaces\n        space = random.randint(1, 3)\n        if space == 1:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_1[cluster[0], x])\n        elif space == 2:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_2[cluster[0], x])\n        else:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_3[cluster[0], x])\n\n        # Randomly decide to reverse or not\n        if random.random() < 0.7:\n            cluster_order = cluster_order[::-1]\n\n        clusters[i] = cluster_order\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(clusters)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional 2-opt swap with adaptive segment insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-dimensional 2-opt swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[i:j+1]\n\n    # Choose the best space for insertion\n    space_scores = [\n        sum(distance_matrix_1[new_solution[k-1], segment[l]] + distance_matrix_1[segment[l], new_solution[k]]\n            for k in [i, j+1] for l in range(len(segment))),\n        sum(distance_matrix_2[new_solution[k-1], segment[l]] + distance_matrix_2[segment[l], new_solution[k]]\n            for k in [i, j+1] for l in range(len(segment))),\n        sum(distance_matrix_3[new_solution[k-1], segment[l]] + distance_matrix_3[segment[l], new_solution[k]]\n            for k in [i, j+1] for l in range(len(segment)))\n    ]\n\n    best_space = np.argmin(space_scores)\n\n    if best_space == 0:\n        segment = sorted(segment, key=lambda x: distance_matrix_1[new_solution[i-1], x])\n    elif best_space == 1:\n        segment = sorted(segment, key=lambda x: distance_matrix_2[new_solution[i-1], x])\n    else:\n        segment = sorted(segment, key=lambda x: distance_matrix_3[new_solution[i-1], x])\n\n    # Randomly decide to reverse the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution[i:j+1] = segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.69397368703861,
            0.6653612971305847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-dimensional 2-opt swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[i:j+1]\n\n    # Choose the best space for insertion\n    space_scores = [\n        sum(distance_matrix_1[new_solution[k-1], segment[l]] + distance_matrix_1[segment[l], new_solution[k]]\n            for k in [i, j+1] for l in range(len(segment))),\n        sum(distance_matrix_2[new_solution[k-1], segment[l]] + distance_matrix_2[segment[l], new_solution[k]]\n            for k in [i, j+1] for l in range(len(segment))),\n        sum(distance_matrix_3[new_solution[k-1], segment[l]] + distance_matrix_3[segment[l], new_solution[k]]\n            for k in [i, j+1] for l in range(len(segment)))\n    ]\n\n    best_space = np.argmin(space_scores)\n\n    if best_space == 0:\n        segment = sorted(segment, key=lambda x: distance_matrix_1[new_solution[i-1], x])\n    elif best_space == 1:\n        segment = sorted(segment, key=lambda x: distance_matrix_2[new_solution[i-1], x])\n    else:\n        segment = sorted(segment, key=lambda x: distance_matrix_3[new_solution[i-1], x])\n\n    # Randomly decide to reverse the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution[i:j+1] = segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection and weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs segment reversal or crossover while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.6:\n        segments = [seg1, seg2, seg3]\n        if random.random() < 0.5:\n            segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        else:\n            segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.5911548318009625,
            0.3561607837677002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.6:\n        segments = [seg1, seg2, seg3]\n        if random.random() < 0.5:\n            segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        else:\n            segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with modified parameters\n    if random.random() < 0.5:\n        # Reverse segments with higher probability\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Rotate segments with higher probability\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = np.roll(segments[best_seg_idx], 1)\n        new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6391022639943674,
            0.39700794219970703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with modified parameters\n    if random.random() < 0.5:\n        # Reverse segments with higher probability\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Rotate segments with higher probability\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = np.roll(segments[best_seg_idx], 1)\n        new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment inversion and objective-aware node reinsertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Objective-aware node reinsertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n - 1)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check feasibility and objective improvement\n        if len(new_solution) != n:\n            new_solution = selected_solution.copy()\n            continue\n\n        original_costs = [\n            distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[(i+1)%n], selected_solution[i]],\n            distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[(i+1)%n], selected_solution[i]],\n            distance_matrix_3[selected_solution[i-1], selected_solution[i]] + distance_matrix_3[selected_solution[(i+1)%n], selected_solution[i]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n        ]\n\n        if any(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6524058483613809,
            2.472580909729004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Objective-aware node reinsertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n - 1)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check feasibility and objective improvement\n        if len(new_solution) != n:\n            new_solution = selected_solution.copy()\n            continue\n\n        original_costs = [\n            distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[(i+1)%n], selected_solution[i]],\n            distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[(i+1)%n], selected_solution[i]],\n            distance_matrix_3[selected_solution[i-1], selected_solution[i]] + distance_matrix_3[selected_solution[(i+1)%n], selected_solution[i]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n        ]\n\n        if any(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment inversion with dynamic objective-aware node reallocation, where it identifies critical segments based on their weighted contributions, inverts them to disrupt local optima, and strategically reallocates nodes between segments to balance improvements across all objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on weighted contributions\n    segment_size = max(2, n // 5)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Invert the worst segment to disrupt local optima\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n\n    # Reallocate nodes between segments to balance improvements\n    if len(segments) > 1:\n        # Randomly select a segment to reallocate from\n        from_seg_idx = random.choice([i for i in range(len(segments)) if i != worst_seg_idx])\n        from_seg = segments[from_seg_idx]\n\n        # Randomly select a node to move\n        if len(from_seg) > 1:\n            node_idx = random.randint(0, len(from_seg)-1)\n            node = from_seg[node_idx]\n\n            # Find the best insertion position in the worst segment\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(len(segments[worst_seg_idx])):\n                # Calculate the cost of inserting the node at position i\n                prev_node = segments[worst_seg_idx][i-1] if i > 0 else segments[worst_seg_idx][-1]\n                next_node = segments[worst_seg_idx][i] if i < len(segments[worst_seg_idx]) else segments[worst_seg_idx][0]\n                cost = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                        weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                        weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]))\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            # Insert the node into the worst segment\n            segments[worst_seg_idx] = np.insert(segments[worst_seg_idx], best_pos, node)\n\n            # Remove the node from its original segment\n            from_seg = np.delete(from_seg, node_idx)\n            segments[from_seg_idx] = from_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6469014485109157,
            0.7207318902015686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on weighted contributions\n    segment_size = max(2, n // 5)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Invert the worst segment to disrupt local optima\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n\n    # Reallocate nodes between segments to balance improvements\n    if len(segments) > 1:\n        # Randomly select a segment to reallocate from\n        from_seg_idx = random.choice([i for i in range(len(segments)) if i != worst_seg_idx])\n        from_seg = segments[from_seg_idx]\n\n        # Randomly select a node to move\n        if len(from_seg) > 1:\n            node_idx = random.randint(0, len(from_seg)-1)\n            node = from_seg[node_idx]\n\n            # Find the best insertion position in the worst segment\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(len(segments[worst_seg_idx])):\n                # Calculate the cost of inserting the node at position i\n                prev_node = segments[worst_seg_idx][i-1] if i > 0 else segments[worst_seg_idx][-1]\n                next_node = segments[worst_seg_idx][i] if i < len(segments[worst_seg_idx]) else segments[worst_seg_idx][0]\n                cost = (weights[0] * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]) +\n                        weights[1] * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]) +\n                        weights[2] * (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]))\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            # Insert the node into the worst segment\n            segments[worst_seg_idx] = np.insert(segments[worst_seg_idx], best_pos, node)\n\n            # Remove the node from its original segment\n            from_seg = np.delete(from_seg, node_idx)\n            segments[from_seg_idx] = from_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An adaptive multi-objective local search algorithm that combines a novel hybrid of 4-opt and objective-driven edge swapping, with dynamic segment reinsertion and Pareto-dominance guided selection to balance improvements across all three objectives while maintaining tour feasibility through constrained node permutations.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.array([])\n\n    # Select solution with best overall improvement potential\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]) / max(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        # Simple swap for small tours\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply 4-opt move with constrained segment reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reconstruct solution with segments reversed and reinserted\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2[::-1],\n        new_solution[b+1:c],\n        segment1[::-1],\n        new_solution[d+1:]\n    ])\n\n    # Calculate original and new costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-driven edge swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves and not dominated\n        if (any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) and\n            not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a hybrid of 3-opt and Pareto-guided edge flipping, with dynamic segment inversion and objective-balanced selection to enhance convergence across all three objectives while ensuring tour feasibility through constrained node permutations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best objective diversity\n    base_solution, base_obj = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # Simple 2-opt for small tours\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply 3-opt move with constrained segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    # Reconstruct solution with segment inverted\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment[::-1],\n        new_solution[b+1:]\n    ])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform Pareto-guided edge flipping\n    for _ in range(4):\n        i, j, k = random.sample(range(n), 3)\n        temp_solution = new_solution.copy()\n\n        # Flip a segment of random length\n        length = random.randint(1, min(3, n//2))\n        flip_start = random.randint(0, n - length)\n        flip_end = flip_start + length\n        temp_solution[flip_start:flip_end] = temp_solution[flip_start:flip_end][::-1]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if not dominated and at least one objective improves\n        if (any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) and\n            not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.5429918991964213,
            3.0881309270858766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best objective diversity\n    base_solution, base_obj = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # Simple 2-opt for small tours\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply 3-opt move with constrained segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    # Reconstruct solution with segment inverted\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment[::-1],\n        new_solution[b+1:]\n    ])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform Pareto-guided edge flipping\n    for _ in range(4):\n        i, j, k = random.sample(range(n), 3)\n        temp_solution = new_solution.copy()\n\n        # Flip a segment of random length\n        length = random.randint(1, min(3, n//2))\n        flip_start = random.randint(0, n - length)\n        flip_end = flip_start + length\n        temp_solution[flip_start:flip_end] = temp_solution[flip_start:flip_end][::-1]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if not dominated and at least one objective improves\n        if (any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) and\n            not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7467375088768216,
            0.4597561240196228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{A new algorithm that combines adaptive objective-weighted path reversal with dynamic node clustering to explore the solution space by reversing segments of the tour while clustering nodes based on their multi-objective distances, ensuring balanced improvements across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on the first solution's objectives\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Perform adaptive path reversal based on weighted objectives\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate original and reversed segment costs\n        original_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        original_cost3 = sum(distance_matrix_3[segment[k-1], segment[k]] for k in range(1, len(segment)))\n\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n        reversed_cost3 = sum(distance_matrix_3[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n\n        # Weighted improvement check\n        original_weighted = weights[0] * original_cost1 + weights[1] * original_cost2 + weights[2] * original_cost3\n        reversed_weighted = weights[0] * reversed_cost1 + weights[1] * reversed_cost2 + weights[2] * reversed_cost3\n\n        if reversed_weighted < original_weighted:\n            new_solution[i:j+1] = reversed_segment\n\n    # Perform dynamic node clustering and reordering\n    if n > 4:\n        # Cluster nodes based on their multi-objective distances\n        cluster_size = max(2, n // 3)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n        # Evaluate each cluster's weighted contribution\n        cluster_costs = []\n        for cluster in clusters:\n            cost1 = sum(distance_matrix_1[cluster[k-1], cluster[k]] for k in range(1, len(cluster)))\n            cost2 = sum(distance_matrix_2[cluster[k-1], cluster[k]] for k in range(1, len(cluster)))\n            cost3 = sum(distance_matrix_3[cluster[k-1], cluster[k]] for k in range(1, len(cluster)))\n            weighted_cost = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n            cluster_costs.append(weighted_cost)\n\n        # Sort clusters by their weighted cost\n        sorted_indices = sorted(range(len(cluster_costs)), key=lambda i: cluster_costs[i])\n        new_order = [clusters[i] for i in sorted_indices]\n\n        # Reconstruct the solution with improved cluster ordering\n        new_solution = np.concatenate(new_order)\n\n    return new_solution\n\n",
        "score": [
            -0.6336577467500384,
            2.842650759220123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on the first solution's objectives\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Perform adaptive path reversal based on weighted objectives\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate original and reversed segment costs\n        original_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        original_cost3 = sum(distance_matrix_3[segment[k-1], segment[k]] for k in range(1, len(segment)))\n\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n        reversed_cost3 = sum(distance_matrix_3[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n\n        # Weighted improvement check\n        original_weighted = weights[0] * original_cost1 + weights[1] * original_cost2 + weights[2] * original_cost3\n        reversed_weighted = weights[0] * reversed_cost1 + weights[1] * reversed_cost2 + weights[2] * reversed_cost3\n\n        if reversed_weighted < original_weighted:\n            new_solution[i:j+1] = reversed_segment\n\n    # Perform dynamic node clustering and reordering\n    if n > 4:\n        # Cluster nodes based on their multi-objective distances\n        cluster_size = max(2, n // 3)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n        # Evaluate each cluster's weighted contribution\n        cluster_costs = []\n        for cluster in clusters:\n            cost1 = sum(distance_matrix_1[cluster[k-1], cluster[k]] for k in range(1, len(cluster)))\n            cost2 = sum(distance_matrix_2[cluster[k-1], cluster[k]] for k in range(1, len(cluster)))\n            cost3 = sum(distance_matrix_3[cluster[k-1], cluster[k]] for k in range(1, len(cluster)))\n            weighted_cost = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n            cluster_costs.append(weighted_cost)\n\n        # Sort clusters by their weighted cost\n        sorted_indices = sorted(range(len(cluster_costs)), key=lambda i: cluster_costs[i])\n        new_order = [clusters[i] for i in sorted_indices]\n\n        # Reconstruct the solution with improved cluster ordering\n        new_solution = np.concatenate(new_order)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score and a structure-based diversity metric, then generates a neighbor by performing a multi-objective-aware 3-opt move followed by a segment reversal, ensuring feasibility while balancing exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    norm_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = 0.5 * norm_scores.mean(axis=1) + 0.5 * (1 / (1 + norm_scores.std(axis=1)))\n\n    # Select with probability proportional to inverse score (favor worse solutions for diversification)\n    probs = 1 / (1 + combined_scores)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Perform segment reversal\n    if n >= 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8066556469664945,
            2.9256803154945374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    norm_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = 0.5 * norm_scores.mean(axis=1) + 0.5 * (1 / (1 + norm_scores.std(axis=1)))\n\n    # Select with probability proportional to inverse score (favor worse solutions for diversification)\n    probs = 1 / (1 + combined_scores)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Perform segment reversal\n    if n >= 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node-swapping mechanism with dynamic objective-aware node selection, where it intelligently evaluates individual nodes based on their contributions across all objectives with dynamic weights, then performs targeted swaps between nodes while dynamically adjusting the selection criteria based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Evaluate individual nodes\n    node_contributions = []\n    for i in range(1, n-1):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n        next_node = new_solution[i+1]\n\n        cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n        cost3 = distance_matrix_3[prev_node, current_node] + distance_matrix_3[current_node, next_node]\n\n        contribution = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        node_contributions.append((contribution, i))\n\n    # Sort nodes by contribution (descending)\n    node_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top nodes for potential swapping\n    top_nodes = [idx for (contrib, idx) in node_contributions[:max(2, n//10)]]\n\n    # Perform targeted swaps\n    if len(top_nodes) >= 2 and random.random() < 0.8:\n        i, j = random.sample(top_nodes, 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6355424966927453,
            0.3457180500030518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Evaluate individual nodes\n    node_contributions = []\n    for i in range(1, n-1):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n        next_node = new_solution[i+1]\n\n        cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n        cost3 = distance_matrix_3[prev_node, current_node] + distance_matrix_3[current_node, next_node]\n\n        contribution = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        node_contributions.append((contribution, i))\n\n    # Sort nodes by contribution (descending)\n    node_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top nodes for potential swapping\n    top_nodes = [idx for (contrib, idx) in node_contributions[:max(2, n//10)]]\n\n    # Perform targeted swaps\n    if len(top_nodes) >= 2 and random.random() < 0.8:\n        i, j = random.sample(top_nodes, 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and structural balance, then generates a neighbor by performing a multi-objective-aware segment inversion and adaptive node insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / len(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment_length = j - i + 1\n    if segment_length > 1:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node insertion\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n            ]\n\n            # Revert if no improvement in any objective\n            if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n                new_solution = np.delete(new_solution, insert_pos)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5077396908870848,
            2.9234340310096742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / len(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment_length = j - i + 1\n    if segment_length > 1:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node insertion\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n            ]\n\n            # Revert if no improvement in any objective\n            if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n                new_solution = np.delete(new_solution, insert_pos)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then generates a neighbor by performing a multi-segment reversal and objective-aware edge insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge insertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n        ]\n\n        if all(new_cost <= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5118239465619507,
            2.178571271896362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge insertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n        ]\n\n        if all(new_cost <= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.7:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6386247444701592,
            0.3858399748802185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.7:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and spatial diversity, then generates a neighbor by performing a multi-objective 3-opt exchange with adaptive segment rotation, ensuring feasibility while balancing exploitation of good solutions with exploration of diverse regions in all three objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4*x[1][0] + 0.3*x[1][1] + 0.3*x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Perform 3-opt exchange\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        rot = random.randint(1, min(3, n//4))\n        segment = new_solution[:rot]\n        new_solution = np.concatenate([new_solution[rot:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6743526392787255,
            0.40446655750274657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4*x[1][0] + 0.3*x[1][1] + 0.3*x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Perform 3-opt exchange\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        rot = random.randint(1, min(3, n//4))\n        segment = new_solution[:rot]\n        new_solution = np.concatenate([new_solution[rot:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This new algorithm selects a solution from the archive based on the most balanced objective values, then generates a neighbor by performing a multi-objective-aware 2-opt swap and segment reversal, ensuring feasibility while potentially improving all three objectives through a combination of local and global perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-objective-aware 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.812058921565141,
            2.4360169649124144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-objective-aware 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This new algorithm combines multi-objective adaptive segment reversal with dynamic objective-weighted node swapping, where it first partitions the tour into segments based on their weighted contributions across all objectives, then reverses segments with high weighted costs while swapping nodes between segments to balance improvements across all objectives, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, obj_values = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments\n    k = random.randint(2, 5)\n    segment_size = n // k\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate segments based on weighted costs\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Reverse segments with high weighted costs\n    for i in range(len(segments)):\n        if segment_costs[i][3] > sum(c[3] for c in segment_costs) / len(segment_costs):\n            segments[i] = segments[i][::-1]\n\n    # Perform node swaps between segments to balance objectives\n    if len(segments) > 1:\n        for _ in range(2):\n            i, j = random.sample(range(len(segments)), 2)\n            if len(segments[i]) > 1 and len(segments[j]) > 1:\n                pos_i = random.randint(0, len(segments[i])-1)\n                pos_j = random.randint(0, len(segments[j])-1)\n                segments[i][pos_i], segments[j][pos_j] = segments[j][pos_j], segments[i][pos_i]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7231194069322134,
            0.37594932317733765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, obj_values = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments\n    k = random.randint(2, 5)\n    segment_size = n // k\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate segments based on weighted costs\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Reverse segments with high weighted costs\n    for i in range(len(segments)):\n        if segment_costs[i][3] > sum(c[3] for c in segment_costs) / len(segment_costs):\n            segments[i] = segments[i][::-1]\n\n    # Perform node swaps between segments to balance objectives\n    if len(segments) > 1:\n        for _ in range(2):\n            i, j = random.sample(range(len(segments)), 2)\n            if len(segments[i]) > 1 and len(segments[j]) > 1:\n                pos_i = random.randint(0, len(segments[i])-1)\n                pos_j = random.randint(0, len(segments[j])-1)\n                segments[i][pos_i], segments[j][pos_j] = segments[j][pos_j], segments[i][pos_i]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7692899540373996,
            1.1110082983970642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and spatial diversity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive path balancing, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive path balancing\n    if random.random() < 0.3:\n        # Find the most problematic objective\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1))\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1))\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1))\n\n        worst_obj = max([obj1, obj2, obj3])\n        if worst_obj == obj1:\n            # Optimize for first objective\n            for _ in range(2):\n                a, b = sorted(random.sample(range(n-1), 2))\n                if distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]] > \\\n                   distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[b+1]]:\n                    new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n        elif worst_obj == obj2:\n            # Optimize for second objective\n            for _ in range(2):\n                a, b = sorted(random.sample(range(n-1), 2))\n                if distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]] > \\\n                   distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[b+1]]:\n                    new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n        else:\n            # Optimize for third objective\n            for _ in range(2):\n                a, b = sorted(random.sample(range(n-1), 2))\n                if distance_matrix_3[new_solution[a], new_solution[a+1]] + distance_matrix_3[new_solution[b], new_solution[b+1]] > \\\n                   distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a+1], new_solution[b+1]]:\n                    new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6447470087132233,
            0.4734523057937622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive path balancing\n    if random.random() < 0.3:\n        # Find the most problematic objective\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1))\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1))\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1))\n\n        worst_obj = max([obj1, obj2, obj3])\n        if worst_obj == obj1:\n            # Optimize for first objective\n            for _ in range(2):\n                a, b = sorted(random.sample(range(n-1), 2))\n                if distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]] > \\\n                   distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[b+1]]:\n                    new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n        elif worst_obj == obj2:\n            # Optimize for second objective\n            for _ in range(2):\n                a, b = sorted(random.sample(range(n-1), 2))\n                if distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]] > \\\n                   distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[b+1]]:\n                    new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n        else:\n            # Optimize for third objective\n            for _ in range(2):\n                a, b = sorted(random.sample(range(n-1), 2))\n                if distance_matrix_3[new_solution[a], new_solution[a+1]] + distance_matrix_3[new_solution[b], new_solution[b+1]] > \\\n                   distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a+1], new_solution[b+1]]:\n                    new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects solutions with high crowding distance in the archive, applies a hybrid of 4-opt and objective-specific edge swapping, and evaluates Pareto dominance before accepting the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse segments\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:l+1]\n    new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2[::-1], segment3[::-1]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-specific edge swaps\n    for _ in range(3):\n        # Select objective with worst improvement potential\n        improvements = []\n        for m in range(3):\n            # Try swapping edges in this objective's space\n            temp_solution = new_solution.copy()\n            a, b = random.sample(range(n), 2)\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            new_cost = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) if m == 0 else \\\n                       sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) if m == 1 else \\\n                       sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n            improvements.append(original_costs[m] - new_cost)\n\n        if improvements:\n            best_obj = np.argmax(improvements)\n            if improvements[best_obj] > 0:\n                # Apply best swap\n                a, b = random.sample(range(n), 2)\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.698176506602677,
            4.070057761669159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Perform 4-opt move: select four distinct positions and reverse segments\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:l+1]\n    new_solution[i:l+1] = np.concatenate([segment1[::-1], segment2[::-1], segment3[::-1]])\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-specific edge swaps\n    for _ in range(3):\n        # Select objective with worst improvement potential\n        improvements = []\n        for m in range(3):\n            # Try swapping edges in this objective's space\n            temp_solution = new_solution.copy()\n            a, b = random.sample(range(n), 2)\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            new_cost = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) if m == 0 else \\\n                       sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) if m == 1 else \\\n                       sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n            improvements.append(original_costs[m] - new_cost)\n\n        if improvements:\n            best_obj = np.argmax(improvements)\n            if improvements[best_obj] > 0:\n                # Apply best swap\n                a, b = random.sample(range(n), 2)\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This new algorithm employs an adaptive objective-weighted segment inversion and recombination strategy that dynamically partitions the solution into objective-balanced segments, inverts segments with high objective contributions, and performs segment-wise insertions while maintaining feasibility through a probabilistic circular permutation mechanism that optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i = random.randint(0, len(segments)-1)\n\n        if random.random() < 0.7:\n            segments[i] = segments[i][::-1]\n\n        if len(segments) > 2 and random.random() < 0.4:\n            j = random.choice([k for k in range(len(segments)) if k != i])\n            insert_pos = random.randint(0, len(segments[j]))\n            segments[j].insert(insert_pos, segments[i].pop(random.randint(0, len(segments[i])-1)))\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-2)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.661935050601766,
            0.3225265383720398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i = random.randint(0, len(segments)-1)\n\n        if random.random() < 0.7:\n            segments[i] = segments[i][::-1]\n\n        if len(segments) > 2 and random.random() < 0.4:\n            j = random.choice([k for k in range(len(segments)) if k != i])\n            insert_pos = random.randint(0, len(segments[j]))\n            segments[j].insert(insert_pos, segments[i].pop(random.randint(0, len(segments[i])-1)))\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-2)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then generates a neighbor by performing a multi-segment insertion and objective-aware edge reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])) - 0.2 * len(set(x[0])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment insertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment = new_solution[a:b+1]\n\n    new_solution = np.concatenate([\n        new_solution[:c], segment, new_solution[c:d+1], new_solution[b+1:d+1], new_solution[d+1:]\n    ])\n\n    # Objective-aware edge reversal\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6334248475395926,
            2.4589152693748475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected_solution = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])) - 0.2 * len(set(x[0])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment insertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment = new_solution[a:b+1]\n\n    new_solution = np.concatenate([\n        new_solution[:c], segment, new_solution[c:d+1], new_solution[b+1:d+1], new_solution[d+1:]\n    ])\n\n    # Objective-aware edge reversal\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7162707022587347,
            0.5723200082778931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and structural properties, then generates a neighbor by performing a multi-objective-aware 2-opt and node swap, ensuring feasibility while balancing exploitation of known good regions with exploration of new areas in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted randomness based on objective values\n    weights = [1/(obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap with consideration for all objectives\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate potential improvement in all objectives\n            obj1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n            obj1 += distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n            obj1_prev = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n            obj1_prev += distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n\n            obj2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n            obj2 += distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n            obj2_prev = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n            obj2_prev += distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n            obj3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n            obj3 += distance_matrix_3[new_solution[b-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n            obj3_prev = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]\n            obj3_prev += distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n            # Accept swap if it improves at least one objective\n            if obj1 < obj1_prev or obj2 < obj2_prev or obj3 < obj3_prev:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7283826329205569,
            2.4128410458564757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted randomness based on objective values\n    weights = [1/(obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap with consideration for all objectives\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate potential improvement in all objectives\n            obj1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n            obj1 += distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n            obj1_prev = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n            obj1_prev += distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n\n            obj2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n            obj2 += distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n            obj2_prev = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n            obj2_prev += distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n            obj3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n            obj3 += distance_matrix_3[new_solution[b-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n            obj3_prev = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]]\n            obj3_prev += distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n            # Accept swap if it improves at least one objective\n            if obj1 < obj1_prev or obj2 < obj2_prev or obj3 < obj3_prev:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This new algorithm employs a multi-objective adaptive path relinking with dynamic objective-aware edge selection, where it intelligently selects and exchanges edges between the current solution and the best solution in the archive, dynamically evaluating edge contributions across all objectives with adaptive weights, while ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Find edges in base solution not present in best solution\n    base_edges = set(zip(base_solution[:-1], base_solution[1:]))\n    best_edges = set(zip(best_solution[:-1], best_solution[1:]))\n    diff_edges = base_edges - best_edges\n\n    if diff_edges:\n        # Select an edge to replace\n        edge_to_replace = random.choice(list(diff_edges))\n        idx = np.where((base_solution[:-1] == edge_to_replace[0]) & (base_solution[1:] == edge_to_replace[1]))[0][0]\n\n        # Find a candidate edge from best solution not in base solution\n        candidate_edges = best_edges - base_edges\n        if candidate_edges:\n            candidate_edge = random.choice(list(candidate_edges))\n            new_solution[idx] = candidate_edge[0]\n            new_solution[idx+1] = candidate_edge[1]\n\n            # Ensure the tour remains valid by fixing any cycles\n            if len(np.unique(new_solution)) != len(base_solution):\n                # Revert if invalid\n                new_solution = base_solution.copy()\n        else:\n            # If no candidate edges, perform a 2-opt move\n            i, j = sorted(random.sample(range(1, len(new_solution)-1), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6975616024140266,
            0.4888940334320068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Find edges in base solution not present in best solution\n    base_edges = set(zip(base_solution[:-1], base_solution[1:]))\n    best_edges = set(zip(best_solution[:-1], best_solution[1:]))\n    diff_edges = base_edges - best_edges\n\n    if diff_edges:\n        # Select an edge to replace\n        edge_to_replace = random.choice(list(diff_edges))\n        idx = np.where((base_solution[:-1] == edge_to_replace[0]) & (base_solution[1:] == edge_to_replace[1]))[0][0]\n\n        # Find a candidate edge from best solution not in base solution\n        candidate_edges = best_edges - base_edges\n        if candidate_edges:\n            candidate_edge = random.choice(list(candidate_edges))\n            new_solution[idx] = candidate_edge[0]\n            new_solution[idx+1] = candidate_edge[1]\n\n            # Ensure the tour remains valid by fixing any cycles\n            if len(np.unique(new_solution)) != len(base_solution):\n                # Revert if invalid\n                new_solution = base_solution.copy()\n        else:\n            # If no candidate edges, perform a 2-opt move\n            i, j = sorted(random.sample(range(1, len(new_solution)-1), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This new algorithm employs a multi-dimensional node relocation with adaptive objective-driven path smoothing, where it intelligently selects a solution from the archive based on objective diversity and performs node relocations across all three dimensions while dynamically adjusting path segments to balance improvements in all objectives, ensuring feasibility through constrained local perturbations that preserve tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node relocation\n    for _ in range(3):  # Perform multiple relocations\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Dynamic path smoothing\n        if random.random() < 0.4:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            # Evaluate segment in all dimensions\n            cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            cost3 = sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n            # Reverse segment if it improves at least one objective\n            if any(distance_matrix_1[segment[i-1], segment[i]] > distance_matrix_1[segment[i], segment[i-1]] for i in range(1, len(segment))) or \\\n               any(distance_matrix_2[segment[i-1], segment[i]] > distance_matrix_2[segment[i], segment[i-1]] for i in range(1, len(segment))) or \\\n               any(distance_matrix_3[segment[i-1], segment[i]] > distance_matrix_3[segment[i], segment[i-1]] for i in range(1, len(segment))):\n                new_solution[a:b+1] = segment[::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7388842894997801,
            0.6901894450187683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node relocation\n    for _ in range(3):  # Perform multiple relocations\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Dynamic path smoothing\n        if random.random() < 0.4:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            # Evaluate segment in all dimensions\n            cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            cost3 = sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n            # Reverse segment if it improves at least one objective\n            if any(distance_matrix_1[segment[i-1], segment[i]] > distance_matrix_1[segment[i], segment[i-1]] for i in range(1, len(segment))) or \\\n               any(distance_matrix_2[segment[i-1], segment[i]] > distance_matrix_2[segment[i], segment[i-1]] for i in range(1, len(segment))) or \\\n               any(distance_matrix_3[segment[i-1], segment[i]] > distance_matrix_3[segment[i], segment[i-1]] for i in range(1, len(segment))):\n                new_solution[a:b+1] = segment[::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional node relocation with adaptive tour inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global diversification.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate centrality scores for each node in the selected solution\n    centrality = np.zeros(n)\n    for i in range(n):\n        node = new_solution[i]\n        neighbors = [new_solution[(i-1)%n], new_solution[(i+1)%n]]\n        centrality[i] = sum(distance_matrix_1[node, neighbor] + distance_matrix_2[node, neighbor] + distance_matrix_3[node, neighbor] for neighbor in neighbors)\n\n    # Find the least central node to relocate\n    least_central_idx = np.argmin(centrality)\n    node_to_relocate = new_solution[least_central_idx]\n\n    # Find optimal insertion position based on multi-objective cost\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i == least_central_idx or (i+1)%n == least_central_idx:\n            continue\n\n        prev_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, node_to_relocate] + distance_matrix_1[node_to_relocate, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node_to_relocate] + distance_matrix_2[node_to_relocate, next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, node_to_relocate] + distance_matrix_3[node_to_relocate, next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        # Perform relocation\n        new_solution = np.concatenate([new_solution[:best_pos+1], [node_to_relocate], new_solution[best_pos+1:least_central_idx], new_solution[least_central_idx+1:]])\n\n    # Adaptive tour inversion with multi-objective consideration\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Evaluate inversion cost\n        prev_node = new_solution[a-1]\n        next_node = new_solution[b]\n\n        cost1 = distance_matrix_1[prev_node, segment[-1]] + distance_matrix_1[segment[0], next_node] - distance_matrix_1[prev_node, segment[0]] - distance_matrix_1[segment[-1], next_node]\n        cost2 = distance_matrix_2[prev_node, segment[-1]] + distance_matrix_2[segment[0], next_node] - distance_matrix_2[prev_node, segment[0]] - distance_matrix_2[segment[-1], next_node]\n        cost3 = distance_matrix_3[prev_node, segment[-1]] + distance_matrix_3[segment[0], next_node] - distance_matrix_3[prev_node, segment[0]] - distance_matrix_3[segment[-1], next_node]\n\n        if cost1 + cost2 + cost3 < 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7250887079740111,
            1.601774263381958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate centrality scores for each node in the selected solution\n    centrality = np.zeros(n)\n    for i in range(n):\n        node = new_solution[i]\n        neighbors = [new_solution[(i-1)%n], new_solution[(i+1)%n]]\n        centrality[i] = sum(distance_matrix_1[node, neighbor] + distance_matrix_2[node, neighbor] + distance_matrix_3[node, neighbor] for neighbor in neighbors)\n\n    # Find the least central node to relocate\n    least_central_idx = np.argmin(centrality)\n    node_to_relocate = new_solution[least_central_idx]\n\n    # Find optimal insertion position based on multi-objective cost\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i == least_central_idx or (i+1)%n == least_central_idx:\n            continue\n\n        prev_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, node_to_relocate] + distance_matrix_1[node_to_relocate, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node_to_relocate] + distance_matrix_2[node_to_relocate, next_node] - distance_matrix_2[prev_node, next_node]\n        cost3 = distance_matrix_3[prev_node, node_to_relocate] + distance_matrix_3[node_to_relocate, next_node] - distance_matrix_3[prev_node, next_node]\n\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        # Perform relocation\n        new_solution = np.concatenate([new_solution[:best_pos+1], [node_to_relocate], new_solution[best_pos+1:least_central_idx], new_solution[least_central_idx+1:]])\n\n    # Adaptive tour inversion with multi-objective consideration\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Evaluate inversion cost\n        prev_node = new_solution[a-1]\n        next_node = new_solution[b]\n\n        cost1 = distance_matrix_1[prev_node, segment[-1]] + distance_matrix_1[segment[0], next_node] - distance_matrix_1[prev_node, segment[0]] - distance_matrix_1[segment[-1], next_node]\n        cost2 = distance_matrix_2[prev_node, segment[-1]] + distance_matrix_2[segment[0], next_node] - distance_matrix_2[prev_node, segment[0]] - distance_matrix_2[segment[-1], next_node]\n        cost3 = distance_matrix_3[prev_node, segment[-1]] + distance_matrix_3[segment[0], next_node] - distance_matrix_3[prev_node, segment[0]] - distance_matrix_3[segment[-1], next_node]\n\n        if cost1 + cost2 + cost3 < 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This new algorithm employs a multi-objective adaptive path inversion with weighted segment reversal, where it intelligently selects segments of the tour to invert based on their weighted contributions across all objectives, dynamically adjusting the segment length and inversion probability to balance exploration and exploitation while ensuring feasibility and promoting diverse solution structures.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = sorted(archive, key=lambda x: (sum(x[1]) - max(x[1]) - min(x[1])))[len(archive)//2][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment length based on weighted objectives\n    segment_length = max(2, min(n//2, int(n * (weights[0] + weights[1] + weights[2]) / 3)))\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate weighted cost of the segment\n    cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n    cost3 = sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)))\n    weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    # Decide whether to invert the segment based on weighted cost\n    if random.random() < 0.7 or weighted_cost > (sum(weights) * distance_matrix_1.mean()):\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Optional: perform a small random swap to maintain diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6754269472352751,
            2.572382938861847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = sorted(archive, key=lambda x: (sum(x[1]) - max(x[1]) - min(x[1])))[len(archive)//2][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment length based on weighted objectives\n    segment_length = max(2, min(n//2, int(n * (weights[0] + weights[1] + weights[2]) / 3)))\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate weighted cost of the segment\n    cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n    cost3 = sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)))\n    weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    # Decide whether to invert the segment based on weighted cost\n    if random.random() < 0.7 or weighted_cost > (sum(weights) * distance_matrix_1.mean()):\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Optional: perform a small random swap to maintain diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This new algorithm employs a dynamic objective-weighted edge insertion with adaptive neighborhood exploration, where it evaluates edges based on their weighted contributions across objectives, intelligently inserts or removes edges while dynamically adjusting weights based on current solution quality, and explores neighborhoods by considering both local and global edge interactions to balance improvement across all objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def get_weighted_score(obj):\n        weights = [0.4, 0.3, 0.3]  # Initial weights for objectives\n        return sum(w * o for w, o in zip(weights, obj))\n\n    base_solution, _ = max(archive, key=lambda x: get_weighted_score(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current edge weights across objectives\n    edge_weights = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        w1 = distance_matrix_1[u, v]\n        w2 = distance_matrix_2[u, v]\n        w3 = distance_matrix_3[u, v]\n        edge_weights.append((w1, w2, w3))\n\n    # Identify edges with high weighted contribution\n    def edge_score(edge):\n        return sum(w * o for w, o in zip([0.4, 0.3, 0.3], edge))\n\n    sorted_edges = sorted(enumerate(edge_weights), key=lambda x: edge_score(x[1]), reverse=True)\n    top_edges = [i for i, _ in sorted_edges[:max(2, n//10)]]\n\n    # Perform edge insertion or removal\n    if random.random() < 0.6:\n        # Edge insertion\n        u, v = random.choice(top_edges), random.randint(0, n-1)\n        if u != v and v not in {u-1, u+1}:\n            new_solution = np.insert(new_solution, v, new_solution[u])\n    else:\n        # Edge removal and reconnection\n        if n > 4:\n            u = random.choice(top_edges)\n            new_solution = np.delete(new_solution, u)\n            # Reconnect the gap\n            if u > 0 and u < n-1:\n                new_solution[u-1], new_solution[u] = new_solution[u], new_solution[u-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6779545372017236,
            1.0110782980918884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def get_weighted_score(obj):\n        weights = [0.4, 0.3, 0.3]  # Initial weights for objectives\n        return sum(w * o for w, o in zip(weights, obj))\n\n    base_solution, _ = max(archive, key=lambda x: get_weighted_score(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current edge weights across objectives\n    edge_weights = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        w1 = distance_matrix_1[u, v]\n        w2 = distance_matrix_2[u, v]\n        w3 = distance_matrix_3[u, v]\n        edge_weights.append((w1, w2, w3))\n\n    # Identify edges with high weighted contribution\n    def edge_score(edge):\n        return sum(w * o for w, o in zip([0.4, 0.3, 0.3], edge))\n\n    sorted_edges = sorted(enumerate(edge_weights), key=lambda x: edge_score(x[1]), reverse=True)\n    top_edges = [i for i, _ in sorted_edges[:max(2, n//10)]]\n\n    # Perform edge insertion or removal\n    if random.random() < 0.6:\n        # Edge insertion\n        u, v = random.choice(top_edges), random.randint(0, n-1)\n        if u != v and v not in {u-1, u+1}:\n            new_solution = np.insert(new_solution, v, new_solution[u])\n    else:\n        # Edge removal and reconnection\n        if n > 4:\n            u = random.choice(top_edges)\n            new_solution = np.delete(new_solution, u)\n            # Reconnect the gap\n            if u > 0 and u < n-1:\n                new_solution[u-1], new_solution[u] = new_solution[u], new_solution[u-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This new algorithm employs a multi-objective tour decomposition and reassembly strategy that dynamically partitions the solution into objective-specific sub-tours, evaluates their trade-offs using Pareto dominance analysis, and performs sub-tour inversions and crossovers while ensuring feasibility through a novel node reallocation mechanism that maintains tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[min(3, len(archive)-1)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Decompose tour into objective-specific sub-tours\n    obj1_subtour = []\n    obj2_subtour = []\n    obj3_subtour = []\n\n    for i in range(1, n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        cost1 = distance_matrix_1[prev, curr]\n        cost2 = distance_matrix_2[prev, curr]\n        cost3 = distance_matrix_3[prev, curr]\n\n        if cost1 <= cost2 and cost1 <= cost3:\n            obj1_subtour.append(curr)\n        elif cost2 <= cost1 and cost2 <= cost3:\n            obj2_subtour.append(curr)\n        else:\n            obj3_subtour.append(curr)\n\n    # Reassemble sub-tours with Pareto dominance analysis\n    combined = []\n    while obj1_subtour or obj2_subtour or obj3_subtour:\n        if obj1_subtour:\n            combined.append(obj1_subtour.pop(0))\n        if obj2_subtour:\n            combined.append(obj2_subtour.pop(0))\n        if obj3_subtour:\n            combined.append(obj3_subtour.pop(0))\n\n    # Apply sub-tour inversion for local optimization\n    if random.random() < 0.4:\n        start = random.randint(0, len(combined)-1)\n        end = random.randint(start, len(combined)-1)\n        combined[start:end+1] = combined[start:end+1][::-1]\n\n    # Reconstruct the full tour\n    new_solution = [new_solution[0]] + combined + [new_solution[0]]\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.683295620425558,
            0.35955142974853516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[min(3, len(archive)-1)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Decompose tour into objective-specific sub-tours\n    obj1_subtour = []\n    obj2_subtour = []\n    obj3_subtour = []\n\n    for i in range(1, n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        cost1 = distance_matrix_1[prev, curr]\n        cost2 = distance_matrix_2[prev, curr]\n        cost3 = distance_matrix_3[prev, curr]\n\n        if cost1 <= cost2 and cost1 <= cost3:\n            obj1_subtour.append(curr)\n        elif cost2 <= cost1 and cost2 <= cost3:\n            obj2_subtour.append(curr)\n        else:\n            obj3_subtour.append(curr)\n\n    # Reassemble sub-tours with Pareto dominance analysis\n    combined = []\n    while obj1_subtour or obj2_subtour or obj3_subtour:\n        if obj1_subtour:\n            combined.append(obj1_subtour.pop(0))\n        if obj2_subtour:\n            combined.append(obj2_subtour.pop(0))\n        if obj3_subtour:\n            combined.append(obj3_subtour.pop(0))\n\n    # Apply sub-tour inversion for local optimization\n    if random.random() < 0.4:\n        start = random.randint(0, len(combined)-1)\n        end = random.randint(start, len(combined)-1)\n        combined[start:end+1] = combined[start:end+1][::-1]\n\n    # Reconstruct the full tour\n    new_solution = [new_solution[0]] + combined + [new_solution[0]]\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This new algorithm employs a multi-objective adaptive path decomposition and reconstruction approach, where it dynamically partitions the tour into critical and non-critical segments based on their contributions to all objectives, then reconstructs the path by strategically reordering segments while ensuring balanced improvement across all dimensions through a combination of segment merging and multi-dimensional node swapping.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment decomposition\n    segment_length = max(2, n // 4)\n    segments = [new_solution[i:i+segment_length] for i in range(0, n, segment_length)]\n\n    # Evaluate segments across all objectives\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return (cost1, cost2, cost3)\n\n    segment_scores = [sum(evaluate_segment(seg)) for seg in segments]\n\n    # Identify critical and non-critical segments\n    critical_idx = min(range(len(segments)), key=lambda i: segment_scores[i])\n    non_critical_idx = max(range(len(segments)), key=lambda i: segment_scores[i])\n\n    # Reconstruct path with segment merging and swapping\n    if random.random() < 0.6:\n        # Swap critical and non-critical segments\n        segments[critical_idx], segments[non_critical_idx] = segments[non_critical_idx], segments[critical_idx]\n    else:\n        # Merge segments with probability based on their scores\n        if random.random() < 0.4:\n            merged = np.concatenate([segments[critical_idx], segments[non_critical_idx]])\n            segments[critical_idx] = merged\n            del segments[non_critical_idx]\n\n    # Multi-dimensional node swapping\n    if random.random() < 0.5:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.713226990956348,
            0.5697260856628418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment decomposition\n    segment_length = max(2, n // 4)\n    segments = [new_solution[i:i+segment_length] for i in range(0, n, segment_length)]\n\n    # Evaluate segments across all objectives\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return (cost1, cost2, cost3)\n\n    segment_scores = [sum(evaluate_segment(seg)) for seg in segments]\n\n    # Identify critical and non-critical segments\n    critical_idx = min(range(len(segments)), key=lambda i: segment_scores[i])\n    non_critical_idx = max(range(len(segments)), key=lambda i: segment_scores[i])\n\n    # Reconstruct path with segment merging and swapping\n    if random.random() < 0.6:\n        # Swap critical and non-critical segments\n        segments[critical_idx], segments[non_critical_idx] = segments[non_critical_idx], segments[critical_idx]\n    else:\n        # Merge segments with probability based on their scores\n        if random.random() < 0.4:\n            merged = np.concatenate([segments[critical_idx], segments[non_critical_idx]])\n            segments[critical_idx] = merged\n            del segments[non_critical_idx]\n\n    # Multi-dimensional node swapping\n    if random.random() < 0.5:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This new algorithm combines multi-objective tour partitioning with adaptive segment reassembly, where segments are dynamically identified based on their contribution to each objective, then reassembled using a hybrid of circular permutations and objective-aware segment swaps to create diverse, high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate relative contributions to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Determine segment boundary based on objective diversity\n        max_cost = max(cost1, cost2, cost3)\n        min_cost = min(cost1, cost2, cost3)\n        diversity = max_cost - min_cost\n\n        if random.random() < 0.5 or diversity > (sum(objectives) / (3 * n)):\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Adaptive segment reassembly\n    if len(segments) > 1:\n        # Select segments with highest diversity for reassembly\n        diversity_scores = []\n        for seg in segments:\n            seg_costs = []\n            for i in range(1, len(seg)):\n                prev = seg[i-1]\n                curr = seg[i]\n                seg_costs.extend([\n                    distance_matrix_1[prev, curr],\n                    distance_matrix_2[prev, curr],\n                    distance_matrix_3[prev, curr]\n                ])\n            max_cost = max(seg_costs) if seg_costs else 0\n            min_cost = min(seg_costs) if seg_costs else 0\n            diversity_scores.append(max_cost - min_cost)\n\n        # Select top 2 most diverse segments\n        top_indices = sorted(range(len(diversity_scores)), key=lambda i: -diversity_scores[i])[:2]\n\n        if len(top_indices) == 2:\n            i, j = top_indices\n            if random.random() < 0.7:\n                # Swap segments\n                segments[i], segments[j] = segments[j], segments[i]\n            else:\n                # Merge segments with circular permutation\n                merged = segments[i] + segments[j]\n                k = random.randint(1, len(merged)-1)\n                merged = merged[k:] + merged[:k]\n                segments[i] = merged\n                segments.pop(j)\n\n    # Rebuild solution with circular permutations\n    new_solution = []\n    for seg in segments:\n        if len(seg) > 2 and random.random() < 0.4:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7124260427543032,
            0.4993085741996765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate relative contributions to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Determine segment boundary based on objective diversity\n        max_cost = max(cost1, cost2, cost3)\n        min_cost = min(cost1, cost2, cost3)\n        diversity = max_cost - min_cost\n\n        if random.random() < 0.5 or diversity > (sum(objectives) / (3 * n)):\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Adaptive segment reassembly\n    if len(segments) > 1:\n        # Select segments with highest diversity for reassembly\n        diversity_scores = []\n        for seg in segments:\n            seg_costs = []\n            for i in range(1, len(seg)):\n                prev = seg[i-1]\n                curr = seg[i]\n                seg_costs.extend([\n                    distance_matrix_1[prev, curr],\n                    distance_matrix_2[prev, curr],\n                    distance_matrix_3[prev, curr]\n                ])\n            max_cost = max(seg_costs) if seg_costs else 0\n            min_cost = min(seg_costs) if seg_costs else 0\n            diversity_scores.append(max_cost - min_cost)\n\n        # Select top 2 most diverse segments\n        top_indices = sorted(range(len(diversity_scores)), key=lambda i: -diversity_scores[i])[:2]\n\n        if len(top_indices) == 2:\n            i, j = top_indices\n            if random.random() < 0.7:\n                # Swap segments\n                segments[i], segments[j] = segments[j], segments[i]\n            else:\n                # Merge segments with circular permutation\n                merged = segments[i] + segments[j]\n                k = random.randint(1, len(merged)-1)\n                merged = merged[k:] + merged[:k]\n                segments[i] = merged\n                segments.pop(j)\n\n    # Rebuild solution with circular permutations\n    new_solution = []\n    for seg in segments:\n        if len(seg) > 2 and random.random() < 0.4:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions in the Pareto front, then applies a multi-objective-aware 3-opt move followed by a node swap operation to generate a neighbor solution that balances improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with minimum crowding distance (most crowded)\n    selected_idx = np.argmin(crowding)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Perform node swap\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6584731046471838,
            2.95460239648819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with minimum crowding distance (most crowded)\n    selected_idx = np.argmin(crowding)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Perform node swap\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7575080658931472,
            0.37191160917282107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with probability\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This new algorithm uses a multi-objective adaptive segment reversal with dynamic objective-aware segment selection, where it evaluates segments based on their contribution to each objective, reverses the worst-performing segments with probability proportional to their improvement potential, and dynamically adjusts segment boundaries based on weighted objective improvements to ensure feasibility and promote balanced optimization across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.8:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6910834848984597,
            0.48361912965774534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.8:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This new algorithm employs a multi-objective adaptive path relinking with dynamic objective-aware node swapping, where it intelligently selects critical nodes from different solutions in the archive, evaluates their contributions across all objectives with dynamic weights, and performs targeted swaps to create a new solution while dynamically adjusting the selection criteria based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, obj1 = archive[0]\n    sol2, obj2 = archive[1] if len(archive) > 1 else (sol1, obj1)\n\n    # Calculate dynamic weights based on objective values\n    total = sum(obj1) + sum(obj2)\n    weights = [(o1 + o2) / total for o1, o2 in zip(obj1, obj2)] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes with highest weighted contribution\n    critical_nodes = []\n    for i in range(len(sol1)):\n        node1 = sol1[i]\n        node2 = sol2[i]\n        cost1 = (weights[0] * (distance_matrix_1[sol1[i-1], node1] + distance_matrix_1[node1, sol1[(i+1)%len(sol1)]]) +\n                 weights[1] * (distance_matrix_2[sol1[i-1], node1] + distance_matrix_2[node1, sol1[(i+1)%len(sol1)]]) +\n                 weights[2] * (distance_matrix_3[sol1[i-1], node1] + distance_matrix_3[node1, sol1[(i+1)%len(sol1)]]))\n        cost2 = (weights[0] * (distance_matrix_1[sol2[i-1], node2] + distance_matrix_1[node2, sol2[(i+1)%len(sol2)]]) +\n                 weights[1] * (distance_matrix_2[sol2[i-1], node2] + distance_matrix_2[node2, sol2[(i+1)%len(sol2)]]) +\n                 weights[2] * (distance_matrix_3[sol2[i-1], node2] + distance_matrix_3[node2, sol2[(i+1)%len(sol2)]]))\n        if cost1 > cost2:\n            critical_nodes.append((i, node2))\n\n    # Perform targeted swaps\n    new_solution = sol1.copy()\n    for i, node in critical_nodes:\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i] = node\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6572969657518185,
            0.5729703664779663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, obj1 = archive[0]\n    sol2, obj2 = archive[1] if len(archive) > 1 else (sol1, obj1)\n\n    # Calculate dynamic weights based on objective values\n    total = sum(obj1) + sum(obj2)\n    weights = [(o1 + o2) / total for o1, o2 in zip(obj1, obj2)] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes with highest weighted contribution\n    critical_nodes = []\n    for i in range(len(sol1)):\n        node1 = sol1[i]\n        node2 = sol2[i]\n        cost1 = (weights[0] * (distance_matrix_1[sol1[i-1], node1] + distance_matrix_1[node1, sol1[(i+1)%len(sol1)]]) +\n                 weights[1] * (distance_matrix_2[sol1[i-1], node1] + distance_matrix_2[node1, sol1[(i+1)%len(sol1)]]) +\n                 weights[2] * (distance_matrix_3[sol1[i-1], node1] + distance_matrix_3[node1, sol1[(i+1)%len(sol1)]]))\n        cost2 = (weights[0] * (distance_matrix_1[sol2[i-1], node2] + distance_matrix_1[node2, sol2[(i+1)%len(sol2)]]) +\n                 weights[1] * (distance_matrix_2[sol2[i-1], node2] + distance_matrix_2[node2, sol2[(i+1)%len(sol2)]]) +\n                 weights[2] * (distance_matrix_3[sol2[i-1], node2] + distance_matrix_3[node2, sol2[(i+1)%len(sol2)]]))\n        if cost1 > cost2:\n            critical_nodes.append((i, node2))\n\n    # Perform targeted swaps\n    new_solution = sol1.copy()\n    for i, node in critical_nodes:\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i] = node\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and solution quality, then generates a neighbor by performing a hybrid of 2-opt and k-opt moves, followed by a multi-dimensional edge swap, ensuring feasibility while potentially improving all three objectives through a combination of local refinement and controlled randomization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * (max(x[1]) - min(x[1])) + 0.4 * sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 2-opt and k-opt move (k=3)\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        k = 3\n        indices = sorted(random.sample(range(n), k))\n        segment = new_solution[indices]\n        random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Multi-dimensional edge swap\n    if random.random() < 0.5:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if (distance_matrix_1[new_solution[a]][new_solution[c]] + distance_matrix_1[new_solution[b]][new_solution[d]]) < \\\n           (distance_matrix_1[new_solution[a]][new_solution[b]] + distance_matrix_1[new_solution[c]][new_solution[d]]):\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7352161460325967,
            0.659455144405365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * (max(x[1]) - min(x[1])) + 0.4 * sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 2-opt and k-opt move (k=3)\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        k = 3\n        indices = sorted(random.sample(range(n), k))\n        segment = new_solution[indices]\n        random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Multi-dimensional edge swap\n    if random.random() < 0.5:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if (distance_matrix_1[new_solution[a]][new_solution[c]] + distance_matrix_1[new_solution[b]][new_solution[d]]) < \\\n           (distance_matrix_1[new_solution[a]][new_solution[b]] + distance_matrix_1[new_solution[c]][new_solution[d]]):\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6818288447144496,
            0.3335715174674988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.721968648620843,
            0.3496576189994812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and solution structure, then generates a neighbor by performing a multi-dimensional segment rotation followed by an adaptive node insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[sum(obj) for _, obj in archive], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment rotation\n    k = random.randint(2, min(4, n//2))\n    segment = new_solution[:k]\n    rotated_segment = np.roll(segment, random.randint(1, k-1))\n    new_solution[:k] = rotated_segment\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6955627464781278,
            0.4737213134765625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[sum(obj) for _, obj in archive], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment rotation\n    k = random.randint(2, min(4, n//2))\n    segment = new_solution[:k]\n    rotated_segment = np.roll(segment, random.randint(1, k-1))\n    new_solution[:k] = rotated_segment\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node clustering and dynamic objective-aware path optimization that intelligently groups nodes based on their contributions to each objective, then performs path optimizations within clusters while dynamically adjusting cluster boundaries based on weighted improvements across all objectives, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_cluster) < 4:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n        if random.random() < 0.5:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n        else:\n            clusters[i] = clusters[i] + clusters[j]\n            clusters.pop(j)\n\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.4 and len(cluster) > 2:\n            k = random.randint(1, len(cluster)-1)\n            cluster = cluster[k:] + cluster[:k]\n        new_solution.extend(cluster)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7268634425204927,
            0.5634596109390259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_cluster) < 4:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n        if random.random() < 0.5:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n        else:\n            clusters[i] = clusters[i] + clusters[j]\n            clusters.pop(j)\n\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.4 and len(cluster) > 2:\n            k = random.randint(1, len(cluster)-1)\n            cluster = cluster[k:] + cluster[:k]\n        new_solution.extend(cluster)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective correlation and spatial clustering, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest average objective value for exploration\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / len(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate objective correlation between distance matrices\n    def correlation(a, b):\n        return np.corrcoef(a.flatten(), b.flatten())[0, 1]\n\n    corr12 = correlation(distance_matrix_1, distance_matrix_2)\n    corr13 = correlation(distance_matrix_1, distance_matrix_3)\n    corr23 = correlation(distance_matrix_2, distance_matrix_3)\n\n    # Select which objectives to prioritize based on correlation\n    if corr12 > 0.7 and corr13 > 0.7:\n        # All objectives are highly correlated - use standard insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, i, new_solution[j])\n        new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n    else:\n        # Objectives are less correlated - use multi-dimensional insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement in all objectives\n        def calculate_improvement(solution):\n            total1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(len(solution)))\n            total2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(len(solution)))\n            total3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(len(solution)))\n            return total1, total2, total3\n\n        original = calculate_improvement(new_solution)\n\n        # Try insertion\n        temp_solution = np.insert(new_solution, i, new_solution[j])\n        temp_solution = np.delete(temp_solution, j + (1 if j > i else 0))\n        new_vals = calculate_improvement(temp_solution)\n\n        # Try reversal if insertion didn't help\n        if not any(new_val < orig_val for new_val, orig_val in zip(new_vals, original)):\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            while k == l:\n                l = random.randint(0, n-1)\n            temp_solution = new_solution.copy()\n            temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n            new_vals = calculate_improvement(temp_solution)\n\n            if any(new_val < orig_val for new_val, orig_val in zip(new_vals, original)):\n                new_solution = temp_solution\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7019398001254913,
            3.751657521724701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest average objective value for exploration\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / len(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate objective correlation between distance matrices\n    def correlation(a, b):\n        return np.corrcoef(a.flatten(), b.flatten())[0, 1]\n\n    corr12 = correlation(distance_matrix_1, distance_matrix_2)\n    corr13 = correlation(distance_matrix_1, distance_matrix_3)\n    corr23 = correlation(distance_matrix_2, distance_matrix_3)\n\n    # Select which objectives to prioritize based on correlation\n    if corr12 > 0.7 and corr13 > 0.7:\n        # All objectives are highly correlated - use standard insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, i, new_solution[j])\n        new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n    else:\n        # Objectives are less correlated - use multi-dimensional insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement in all objectives\n        def calculate_improvement(solution):\n            total1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(len(solution)))\n            total2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(len(solution)))\n            total3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(len(solution)))\n            return total1, total2, total3\n\n        original = calculate_improvement(new_solution)\n\n        # Try insertion\n        temp_solution = np.insert(new_solution, i, new_solution[j])\n        temp_solution = np.delete(temp_solution, j + (1 if j > i else 0))\n        new_vals = calculate_improvement(temp_solution)\n\n        # Try reversal if insertion didn't help\n        if not any(new_val < orig_val for new_val, orig_val in zip(new_vals, original)):\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            while k == l:\n                l = random.randint(0, n-1)\n            temp_solution = new_solution.copy()\n            temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n            new_vals = calculate_improvement(temp_solution)\n\n            if any(new_val < orig_val for new_val, orig_val in zip(new_vals, original)):\n                new_solution = temp_solution\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection strategy, then generates a neighbor by performing a multi-objective adaptive segment rotation and inversion, where it identifies the most diverse segments in the tour, rotates them to align with the best-performing segments across objectives, and inverts segments to improve the weighted objective balance, ensuring feasibility while promoting exploration of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Identify the best segment for each objective\n    segment_size = max(2, n // 4)\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(n // segment_size)]\n\n    best_segments = []\n    for i in range(3):\n        segment_costs = []\n        for seg in segments:\n            if i == 0:\n                cost = sum(distance_matrix_1[seg[j-1], seg[j]] for j in range(1, len(seg)))\n            elif i == 1:\n                cost = sum(distance_matrix_2[seg[j-1], seg[j]] for j in range(1, len(seg)))\n            else:\n                cost = sum(distance_matrix_3[seg[j-1], seg[j]] for j in range(1, len(seg)))\n            segment_costs.append(cost)\n        best_segments.append(segments[np.argmin(segment_costs)])\n\n    # Rotate segments to align with best segments\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            best_seg = best_segments[random.randint(0, 2)]\n            rotation = random.randint(1, len(best_seg)-1)\n            segments[i] = np.roll(best_seg, rotation)\n\n    # Invert segments to improve objective balance\n    for i in range(len(segments)):\n        if random.random() < 0.3:\n            segments[i] = segments[i][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7591186736701108,
            3.031896197795868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Identify the best segment for each objective\n    segment_size = max(2, n // 4)\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(n // segment_size)]\n\n    best_segments = []\n    for i in range(3):\n        segment_costs = []\n        for seg in segments:\n            if i == 0:\n                cost = sum(distance_matrix_1[seg[j-1], seg[j]] for j in range(1, len(seg)))\n            elif i == 1:\n                cost = sum(distance_matrix_2[seg[j-1], seg[j]] for j in range(1, len(seg)))\n            else:\n                cost = sum(distance_matrix_3[seg[j-1], seg[j]] for j in range(1, len(seg)))\n            segment_costs.append(cost)\n        best_segments.append(segments[np.argmin(segment_costs)])\n\n    # Rotate segments to align with best segments\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            best_seg = best_segments[random.randint(0, 2)]\n            rotation = random.randint(1, len(best_seg)-1)\n            segments[i] = np.roll(best_seg, rotation)\n\n    # Invert segments to improve objective balance\n    for i in range(len(segments)):\n        if random.random() < 0.3:\n            segments[i] = segments[i][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This new algorithm employs an adaptive multi-objective tour fragmentation and hierarchical recombination strategy that dynamically partitions the solution into objective-aligned segments, evaluates their contributions with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Fragment the tour based on objective contributions\n    fragments = []\n    current_fragment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current fragment or start a new one\n        if random.random() < 0.6 and len(current_fragment) < 4:\n            current_fragment.append(node)\n        else:\n            fragments.append(current_fragment)\n            current_fragment = [node]\n\n    if current_fragment:\n        fragments.append(current_fragment)\n\n    # Perform hierarchical operations on fragments\n    if len(fragments) > 1:\n        # Randomly select two fragments to swap or merge\n        i, j = random.sample(range(len(fragments)), 2)\n\n        if random.random() < 0.4:\n            # Swap fragments\n            fragments[i], fragments[j] = fragments[j], fragments[i]\n        else:\n            # Merge fragments\n            fragments[i] = fragments[i] + fragments[j]\n            fragments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for frag in fragments:\n        if random.random() < 0.25 and len(frag) > 3:\n            # Apply circular permutation to fragment\n            k = random.randint(1, len(frag)-1)\n            frag = frag[k:] + frag[:k]\n        new_solution.extend(frag)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6829451286970518,
            0.6257890343666077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Fragment the tour based on objective contributions\n    fragments = []\n    current_fragment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current fragment or start a new one\n        if random.random() < 0.6 and len(current_fragment) < 4:\n            current_fragment.append(node)\n        else:\n            fragments.append(current_fragment)\n            current_fragment = [node]\n\n    if current_fragment:\n        fragments.append(current_fragment)\n\n    # Perform hierarchical operations on fragments\n    if len(fragments) > 1:\n        # Randomly select two fragments to swap or merge\n        i, j = random.sample(range(len(fragments)), 2)\n\n        if random.random() < 0.4:\n            # Swap fragments\n            fragments[i], fragments[j] = fragments[j], fragments[i]\n        else:\n            # Merge fragments\n            fragments[i] = fragments[i] + fragments[j]\n            fragments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for frag in fragments:\n        if random.random() < 0.25 and len(frag) > 3:\n            # Apply circular permutation to fragment\n            k = random.randint(1, len(frag)-1)\n            frag = frag[k:] + frag[:k]\n        new_solution.extend(frag)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This new algorithm employs a multi-objective-aware adaptive path relinking strategy that dynamically blends solution segments from multiple archive members, guided by a weighted combination of objective improvements and structural diversity, while maintaining feasibility through constrained segment reassembly and dynamic boundary adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two diverse solutions from archive\n    sol1, obj1 = archive[0]\n    sol2, obj2 = archive[-1]\n\n    # Calculate objective weights based on relative improvements\n    weights = [abs(obj1[i] - obj2[i]) for i in range(3)]\n    total = sum(weights)\n    weights = [w/total if total > 0 else 1/3 for w in weights]\n\n    # Find common segments between solutions\n    n = len(sol1)\n    common_segments = []\n    i = 0\n    while i < n:\n        if sol1[i] == sol2[i]:\n            j = i + 1\n            while j < n and sol1[j] == sol2[j]:\n                j += 1\n            common_segments.append((i, j-1))\n            i = j\n        else:\n            i += 1\n\n    # Create new solution by blending segments with weighted probability\n    new_solution = []\n    last_pos = 0\n    for start, end in common_segments:\n        # Add segment from sol1 with probability based on objective weights\n        if random.random() < weights[0]:\n            new_solution.extend(sol1[last_pos:start])\n            new_solution.extend(sol1[start:end+1])\n        else:\n            new_solution.extend(sol2[last_pos:start])\n            new_solution.extend(sol2[start:end+1])\n        last_pos = end + 1\n\n    # Add remaining nodes\n    if last_pos < n:\n        if random.random() < weights[1]:\n            new_solution.extend(sol1[last_pos:])\n        else:\n            new_solution.extend(sol2[last_pos:])\n\n    # Ensure all nodes are included and maintain feasibility\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    # Convert to numpy array and ensure circular tour\n    new_solution = np.array(new_solution)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6888908947125505,
            0.42197188138961794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two diverse solutions from archive\n    sol1, obj1 = archive[0]\n    sol2, obj2 = archive[-1]\n\n    # Calculate objective weights based on relative improvements\n    weights = [abs(obj1[i] - obj2[i]) for i in range(3)]\n    total = sum(weights)\n    weights = [w/total if total > 0 else 1/3 for w in weights]\n\n    # Find common segments between solutions\n    n = len(sol1)\n    common_segments = []\n    i = 0\n    while i < n:\n        if sol1[i] == sol2[i]:\n            j = i + 1\n            while j < n and sol1[j] == sol2[j]:\n                j += 1\n            common_segments.append((i, j-1))\n            i = j\n        else:\n            i += 1\n\n    # Create new solution by blending segments with weighted probability\n    new_solution = []\n    last_pos = 0\n    for start, end in common_segments:\n        # Add segment from sol1 with probability based on objective weights\n        if random.random() < weights[0]:\n            new_solution.extend(sol1[last_pos:start])\n            new_solution.extend(sol1[start:end+1])\n        else:\n            new_solution.extend(sol2[last_pos:start])\n            new_solution.extend(sol2[start:end+1])\n        last_pos = end + 1\n\n    # Add remaining nodes\n    if last_pos < n:\n        if random.random() < weights[1]:\n            new_solution.extend(sol1[last_pos:])\n        else:\n            new_solution.extend(sol2[last_pos:])\n\n    # Ensure all nodes are included and maintain feasibility\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    # Convert to numpy array and ensure circular tour\n    new_solution = np.array(new_solution)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This novel algorithm employs a multi-objective adaptive segment relocation with dynamic objective-aware segment selection, where it intelligently partitions the tour into variable-length segments, evaluates their contributions across all objectives with adaptive weights, and performs segment relocations based on weighted improvements while dynamically adjusting segment boundaries, ensuring feasibility and promoting balanced exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries (randomly variable-length)\n    segment_points = sorted(random.sample(range(1, n), random.randint(2, min(5, n-1))))\n    segments = []\n    prev = 0\n    for point in segment_points + [n]:\n        segments.append(new_solution[prev:point])\n        prev = point\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment and relocate it\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    worst_segment = segments.pop(worst_seg_idx)\n\n    # Insert the worst segment at a new random position\n    insert_pos = random.randint(0, len(segments))\n    segments.insert(insert_pos, worst_segment)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.690152286127184,
            1.7848663806915284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries (randomly variable-length)\n    segment_points = sorted(random.sample(range(1, n), random.randint(2, min(5, n-1))))\n    segments = []\n    prev = 0\n    for point in segment_points + [n]:\n        segments.append(new_solution[prev:point])\n        prev = point\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment and relocate it\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    worst_segment = segments.pop(worst_seg_idx)\n\n    # Insert the worst segment at a new random position\n    insert_pos = random.randint(0, len(segments))\n    segments.insert(insert_pos, worst_segment)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node-based perturbation with dynamic objective-aware node selection, where it identifies critical nodes based on their contributions to all objectives, applies a weighted perturbation that dynamically adjusts node positions while maintaining tour feasibility, and ensures diversity through probabilistic node swapping and insertion operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        probabilities = [1.0 / (i + 1) for i in range(len(archive))]\n        total = sum(probabilities)\n        probabilities = [p / total for p in probabilities]\n        base_solution, _ = random.choices(archive, weights=probabilities, k=1)[0]\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes based on their contributions to all objectives\n    node_contributions = []\n    for i in range(1, n):\n        prev, curr, next_node = new_solution[i-1], new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n        contribution = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n        node_contributions.append((contribution, i))\n\n    # Sort nodes by contribution (descending)\n    node_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 20% critical nodes for perturbation\n    num_critical = max(1, int(0.2 * len(node_contributions)))\n    critical_nodes = [idx for (_, idx) in node_contributions[:num_critical]]\n\n    # Apply weighted perturbation to critical nodes\n    for i in critical_nodes:\n        if random.random() < 0.5:\n            # Swap with another critical node\n            j = random.choice(critical_nodes)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Insert node at a different position\n            pos = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6917854864675839,
            1.1204910397529602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        probabilities = [1.0 / (i + 1) for i in range(len(archive))]\n        total = sum(probabilities)\n        probabilities = [p / total for p in probabilities]\n        base_solution, _ = random.choices(archive, weights=probabilities, k=1)[0]\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes based on their contributions to all objectives\n    node_contributions = []\n    for i in range(1, n):\n        prev, curr, next_node = new_solution[i-1], new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n        contribution = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n        node_contributions.append((contribution, i))\n\n    # Sort nodes by contribution (descending)\n    node_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 20% critical nodes for perturbation\n    num_critical = max(1, int(0.2 * len(node_contributions)))\n    critical_nodes = [idx for (_, idx) in node_contributions[:num_critical]]\n\n    # Apply weighted perturbation to critical nodes\n    for i in critical_nodes:\n        if random.random() < 0.5:\n            # Swap with another critical node\n            j = random.choice(critical_nodes)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Insert node at a different position\n            pos = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment inversion and objective-aware edge swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1][::-1]\n    segment2 = new_solution[c:d+1][::-1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment1, new_solution[b+1:c], segment2, new_solution[d+1:]\n    ])\n\n    # Objective-aware edge swapping\n    for _ in range(3):\n        i = random.randint(1, n - 2)\n        j = random.randint(1, n - 2)\n        while abs(i - j) <= 1:\n            j = random.randint(1, n - 2)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[i+1]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[i+1]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[i+1]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[i], temp_solution[i+1]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7461462307132598,
            3.252723145484924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1][::-1]\n    segment2 = new_solution[c:d+1][::-1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment1, new_solution[b+1:c], segment2, new_solution[d+1:]\n    ])\n\n    # Objective-aware edge swapping\n    for _ in range(3):\n        i = random.randint(1, n - 2)\n        j = random.randint(1, n - 2)\n        while abs(i - j) <= 1:\n            j = random.randint(1, n - 2)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[i+1]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[i+1]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[i+1]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[i], temp_solution[i+1]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This new algorithm combines multi-objective-aware node swapping with dynamic segment reversal, where it first identifies critical nodes based on their weighted contributions across all objectives, then performs targeted swaps and reversals of segments containing these nodes to simultaneously optimize all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]\n    selected_idx = min(range(len(archive)), key=lambda i: sum(w * o for w, o in zip(weights, archive[i][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Identify critical nodes based on their weighted contributions\n    critical_nodes = set()\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost > 1.2 * sum(weights):\n            critical_nodes.add(curr_node)\n\n    if not critical_nodes:\n        critical_nodes = {new_solution[random.randint(0, n-1)]}\n\n    # Perform targeted operations\n    for node in critical_nodes:\n        # Find all occurrences of the critical node\n        indices = [i for i in range(n) if new_solution[i] == node]\n\n        for idx in indices:\n            # Swap with a random non-critical node\n            if len(new_solution) > 2:\n                swap_idx = random.randint(0, n-1)\n                while new_solution[swap_idx] in critical_nodes:\n                    swap_idx = random.randint(0, n-1)\n                new_solution[idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx]\n\n            # Reverse a segment containing this node\n            if n >= 3:\n                start = random.randint(0, n-2)\n                end = random.randint(start+1, min(start+2, n-1))\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8057404206880829,
            3.4403335571289064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]\n    selected_idx = min(range(len(archive)), key=lambda i: sum(w * o for w, o in zip(weights, archive[i][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Identify critical nodes based on their weighted contributions\n    critical_nodes = set()\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost > 1.2 * sum(weights):\n            critical_nodes.add(curr_node)\n\n    if not critical_nodes:\n        critical_nodes = {new_solution[random.randint(0, n-1)]}\n\n    # Perform targeted operations\n    for node in critical_nodes:\n        # Find all occurrences of the critical node\n        indices = [i for i in range(n) if new_solution[i] == node]\n\n        for idx in indices:\n            # Swap with a random non-critical node\n            if len(new_solution) > 2:\n                swap_idx = random.randint(0, n-1)\n                while new_solution[swap_idx] in critical_nodes:\n                    swap_idx = random.randint(0, n-1)\n                new_solution[idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx]\n\n            # Reverse a segment containing this node\n            if n >= 3:\n                start = random.randint(0, n-2)\n                end = random.randint(start+1, min(start+2, n-1))\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7769515442322067,
            2.5529865026473999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum((max(x[1]) - min(x[1])) for _ in range(3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm employs a multi-objective adaptive k-opt local search that dynamically selects the optimal k-value based on the current solution's objective distribution, then performs a k-exchange operation while preserving tour feasibility through a novel objective-aware edge selection mechanism that balances improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Determine k based on objective diversity\n    obj1, obj2, obj3 = archive[0][1]\n    k = 2 if (obj1 + obj2 + obj3) % 3 == 0 else 3\n\n    # Select k distinct edges to modify\n    edges = []\n    for i in range(n-1):\n        edges.append((new_solution[i], new_solution[i+1]))\n    edges.append((new_solution[-1], new_solution[0]))\n\n    selected_edges = random.sample(edges, min(k, len(edges)))\n\n    # Perform k-opt exchange\n    nodes_to_remove = []\n    for a, b in selected_edges:\n        nodes_to_remove.extend([a, b])\n\n    nodes_to_remove = list(set(nodes_to_remove))\n    remaining_nodes = [node for node in new_solution if node not in nodes_to_remove]\n\n    # Reconstruct tour with remaining nodes\n    new_solution = remaining_nodes.copy()\n    if len(new_solution) > 0:\n        new_solution.append(new_solution[0])\n\n    # Insert removed nodes optimally\n    for node in nodes_to_remove:\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)-1):\n            a, b = new_solution[i], new_solution[i+1]\n            cost1 = distance_matrix_1[a, node] + distance_matrix_1[node, b] - distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, node] + distance_matrix_2[node, b] - distance_matrix_2[a, b]\n            cost3 = distance_matrix_3[a, node] + distance_matrix_3[node, b] - distance_matrix_3[a, b]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i + 1\n\n        new_solution.insert(best_pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7092517692304395,
            1.8402904868125916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Determine k based on objective diversity\n    obj1, obj2, obj3 = archive[0][1]\n    k = 2 if (obj1 + obj2 + obj3) % 3 == 0 else 3\n\n    # Select k distinct edges to modify\n    edges = []\n    for i in range(n-1):\n        edges.append((new_solution[i], new_solution[i+1]))\n    edges.append((new_solution[-1], new_solution[0]))\n\n    selected_edges = random.sample(edges, min(k, len(edges)))\n\n    # Perform k-opt exchange\n    nodes_to_remove = []\n    for a, b in selected_edges:\n        nodes_to_remove.extend([a, b])\n\n    nodes_to_remove = list(set(nodes_to_remove))\n    remaining_nodes = [node for node in new_solution if node not in nodes_to_remove]\n\n    # Reconstruct tour with remaining nodes\n    new_solution = remaining_nodes.copy()\n    if len(new_solution) > 0:\n        new_solution.append(new_solution[0])\n\n    # Insert removed nodes optimally\n    for node in nodes_to_remove:\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)-1):\n            a, b = new_solution[i], new_solution[i+1]\n            cost1 = distance_matrix_1[a, node] + distance_matrix_1[node, b] - distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, node] + distance_matrix_2[node, b] - distance_matrix_2[a, b]\n            cost3 = distance_matrix_3[a, node] + distance_matrix_3[node, b] - distance_matrix_3[a, b]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i + 1\n\n        new_solution.insert(best_pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This new algorithm selects a solution from the archive based on the diversity of its objective values and performs a multi-objective-aware segment crossover and insertion operation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment crossover and insertion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Find insertion point that minimizes total distance across all objectives\n    best_insert = 0\n    min_total_cost = float('inf')\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n\n        # Insert segment at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Ensure no duplicates (except for the segment)\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Calculate total cost across all objectives\n        total_cost = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            cost = 0\n            for j in range(n):\n                cost += dm[temp_solution[j-1], temp_solution[j]]\n            total_cost += cost\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert = i\n\n    # Perform the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert],\n        segment,\n        new_solution[best_insert:]\n    ])\n\n    # Ensure no duplicates\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7055704960713413,
            3.8072885990142824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment crossover and insertion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Find insertion point that minimizes total distance across all objectives\n    best_insert = 0\n    min_total_cost = float('inf')\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n\n        # Insert segment at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Ensure no duplicates (except for the segment)\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Calculate total cost across all objectives\n        total_cost = 0\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            cost = 0\n            for j in range(n):\n                cost += dm[temp_solution[j-1], temp_solution[j]]\n            total_cost += cost\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert = i\n\n    # Perform the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert],\n        segment,\n        new_solution[best_insert:]\n    ])\n\n    # Ensure no duplicates\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This new algorithm combines archive-based selection with objective-aware sub-tour inversion and dynamic segment reassignment, where it first identifies promising segments by evaluating their contribution to each objective, then inverts or reassigns these segments based on their relative performance across objectives, while dynamically adjusting segment boundaries to maintain feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify segments with high contribution to any objective\n    segment_size = max(2, n // 5)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return (cost1, cost2, cost3)\n\n    segment_costs = [evaluate_segment(seg) for seg in segments]\n    total_costs = [sum(costs) for costs in segment_costs]\n\n    # Select segments to invert or reassign\n    worst_seg_idx = max(range(len(segments)), key=lambda i: total_costs[i])\n    best_seg_idx = min(range(len(segments)), key=lambda i: total_costs[i])\n\n    # Perform objective-aware operation\n    if random.random() < 0.7:\n        # Invert the worst segment if it's worse in any objective\n        if any(segment_costs[worst_seg_idx][i] > segment_costs[best_seg_idx][i] for i in range(3)):\n            segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    else:\n        # Reassign nodes between segments if they improve any objective\n        for i in range(len(segments[worst_seg_idx])):\n            node = segments[worst_seg_idx][i]\n            for j in range(len(segments[best_seg_idx])):\n                temp_node = segments[best_seg_idx][j]\n                # Swap nodes and check improvement\n                temp_seg1 = segments[worst_seg_idx].copy()\n                temp_seg2 = segments[best_seg_idx].copy()\n                temp_seg1[i], temp_seg2[j] = temp_seg2[j], temp_seg1[i]\n\n                cost1 = (sum(distance_matrix_1[temp_seg1[k-1], temp_seg1[k]] for k in range(len(temp_seg1))) +\n                         sum(distance_matrix_1[temp_seg2[k-1], temp_seg2[k]] for k in range(len(temp_seg2))))\n                cost2 = (sum(distance_matrix_2[temp_seg1[k-1], temp_seg1[k]] for k in range(len(temp_seg1))) +\n                         sum(distance_matrix_2[temp_seg2[k-1], temp_seg2[k]] for k in range(len(temp_seg2))))\n                cost3 = (sum(distance_matrix_3[temp_seg1[k-1], temp_seg1[k]] for k in range(len(temp_seg1))) +\n                         sum(distance_matrix_3[temp_seg2[k-1], temp_seg2[k]] for k in range(len(temp_seg2))))\n\n                if (cost1 < total_costs[worst_seg_idx] + total_costs[best_seg_idx] or\n                    cost2 < total_costs[worst_seg_idx] + total_costs[best_seg_idx] or\n                    cost3 < total_costs[worst_seg_idx] + total_costs[best_seg_idx]):\n                    segments[worst_seg_idx], segments[best_seg_idx] = temp_seg1, temp_seg2\n                    break\n\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6768159976509088,
            0.9343602895736695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify segments with high contribution to any objective\n    segment_size = max(2, n // 5)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return (cost1, cost2, cost3)\n\n    segment_costs = [evaluate_segment(seg) for seg in segments]\n    total_costs = [sum(costs) for costs in segment_costs]\n\n    # Select segments to invert or reassign\n    worst_seg_idx = max(range(len(segments)), key=lambda i: total_costs[i])\n    best_seg_idx = min(range(len(segments)), key=lambda i: total_costs[i])\n\n    # Perform objective-aware operation\n    if random.random() < 0.7:\n        # Invert the worst segment if it's worse in any objective\n        if any(segment_costs[worst_seg_idx][i] > segment_costs[best_seg_idx][i] for i in range(3)):\n            segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    else:\n        # Reassign nodes between segments if they improve any objective\n        for i in range(len(segments[worst_seg_idx])):\n            node = segments[worst_seg_idx][i]\n            for j in range(len(segments[best_seg_idx])):\n                temp_node = segments[best_seg_idx][j]\n                # Swap nodes and check improvement\n                temp_seg1 = segments[worst_seg_idx].copy()\n                temp_seg2 = segments[best_seg_idx].copy()\n                temp_seg1[i], temp_seg2[j] = temp_seg2[j], temp_seg1[i]\n\n                cost1 = (sum(distance_matrix_1[temp_seg1[k-1], temp_seg1[k]] for k in range(len(temp_seg1))) +\n                         sum(distance_matrix_1[temp_seg2[k-1], temp_seg2[k]] for k in range(len(temp_seg2))))\n                cost2 = (sum(distance_matrix_2[temp_seg1[k-1], temp_seg1[k]] for k in range(len(temp_seg1))) +\n                         sum(distance_matrix_2[temp_seg2[k-1], temp_seg2[k]] for k in range(len(temp_seg2))))\n                cost3 = (sum(distance_matrix_3[temp_seg1[k-1], temp_seg1[k]] for k in range(len(temp_seg1))) +\n                         sum(distance_matrix_3[temp_seg2[k-1], temp_seg2[k]] for k in range(len(temp_seg2))))\n\n                if (cost1 < total_costs[worst_seg_idx] + total_costs[best_seg_idx] or\n                    cost2 < total_costs[worst_seg_idx] + total_costs[best_seg_idx] or\n                    cost3 < total_costs[worst_seg_idx] + total_costs[best_seg_idx]):\n                    segments[worst_seg_idx], segments[best_seg_idx] = temp_seg1, temp_seg2\n                    break\n\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7041038928765816,
            0.5378793120384217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This new algorithm employs a multi-objective adaptive tour partitioning strategy that dynamically segments the solution based on edge importance scores combining all three objectives, performs segment-wise operations with probability inversely proportional to their dominance scores, and applies a novel circular permutation mechanism that optimizes for all objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_dominance = sum([sum(obj) for _, obj in archive])\n    probabilities = [(total_dominance - sum(obj)) / total_dominance for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate edge importance scores combining all objectives\n    edge_scores = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        score1 = distance_matrix_1[node1, node2]\n        score2 = distance_matrix_2[node1, node2]\n        score3 = distance_matrix_3[node1, node2]\n        edge_scores.append((score1 + score2 + score3) / 3)\n\n    # Segment the tour based on edge importance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        score = edge_scores[i-1]\n\n        # Higher score edges are more likely to be segment boundaries\n        if random.random() < (score / max(edge_scores)) and len(current_segment) > 1:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations with probability inversely proportional to segment dominance\n    if len(segments) > 1:\n        segment_scores = []\n        for seg in segments:\n            total_score = 0\n            for i in range(len(seg)-1):\n                node1, node2 = seg[i], seg[i+1]\n                total_score += (distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]) / 3\n            segment_scores.append(total_score)\n\n        # Select segments with probability inversely proportional to their score\n        probs = [1/(s+1) for s in segment_scores]\n        i, j = random.choices(range(len(segments)), weights=probs, k=2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7610978046318364,
            1.1449885249137879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_dominance = sum([sum(obj) for _, obj in archive])\n    probabilities = [(total_dominance - sum(obj)) / total_dominance for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate edge importance scores combining all objectives\n    edge_scores = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        score1 = distance_matrix_1[node1, node2]\n        score2 = distance_matrix_2[node1, node2]\n        score3 = distance_matrix_3[node1, node2]\n        edge_scores.append((score1 + score2 + score3) / 3)\n\n    # Segment the tour based on edge importance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        score = edge_scores[i-1]\n\n        # Higher score edges are more likely to be segment boundaries\n        if random.random() < (score / max(edge_scores)) and len(current_segment) > 1:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations with probability inversely proportional to segment dominance\n    if len(segments) > 1:\n        segment_scores = []\n        for seg in segments:\n            total_score = 0\n            for i in range(len(seg)-1):\n                node1, node2 = seg[i], seg[i+1]\n                total_score += (distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]) / 3\n            segment_scores.append(total_score)\n\n        # Select segments with probability inversely proportional to their score\n        probs = [1/(s+1) for s in segment_scores]\n        i, j = random.choices(range(len(segments)), weights=probs, k=2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node-swap operator with dynamic objective-aware node selection, where it intelligently evaluates individual nodes based on their contribution to each objective, dynamically adjusts swap probabilities based on weighted improvements, and performs targeted swaps to optimize across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Evaluate each node's contribution to each objective\n    node_contributions = []\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n        weighted_contribution = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n        node_contributions.append((i, weighted_contribution))\n\n    # Select nodes for potential swap\n    node_contributions.sort(key=lambda x: x[1], reverse=True)\n    top_nodes = [x[0] for x in node_contributions[:max(2, n//10)]]\n\n    # Perform targeted swaps\n    for i in top_nodes:\n        j = random.randint(1, n-1)\n        if i != j and new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7958513658530465,
            3.4113628029823304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Evaluate each node's contribution to each objective\n    node_contributions = []\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n        weighted_contribution = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n        node_contributions.append((i, weighted_contribution))\n\n    # Select nodes for potential swap\n    node_contributions.sort(key=lambda x: x[1], reverse=True)\n    top_nodes = [x[0] for x in node_contributions[:max(2, n//10)]]\n\n    # Perform targeted swaps\n    for i in top_nodes:\n        j = random.randint(1, n-1)\n        if i != j and new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment inversion and objective-aware segment reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Objective-aware segment reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.856626753977235,
            3.5215954542160035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Objective-aware segment reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This new algorithm employs a dynamic objective-aware segment inversion with adaptive segment selection, where it identifies critical segments based on their contributions to each objective, inverts their order with dynamically adjusted weights, and merges them with probabilistic segment boundary adjustments to explore diverse solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for inversion\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Invert the worst segment\n    segments = [seg1, seg2, seg3]\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    new_solution = np.concatenate(segments)\n\n    # Adjust segment boundaries with probability\n    if random.random() < 0.3:\n        new_segment_points = sorted(random.sample(range(1, n-1), 2))\n        new_seg1_end = new_segment_points[0]\n        new_seg2_end = new_segment_points[1]\n        new_solution = np.concatenate([\n            new_solution[:new_seg1_end],\n            new_solution[new_seg1_end:new_seg2_end],\n            new_solution[new_seg2_end:]\n        ])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6663741307462898,
            0.7093461155891418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for inversion\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Invert the worst segment\n    segments = [seg1, seg2, seg3]\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    new_solution = np.concatenate(segments)\n\n    # Adjust segment boundaries with probability\n    if random.random() < 0.3:\n        new_segment_points = sorted(random.sample(range(1, n-1), 2))\n        new_seg1_end = new_segment_points[0]\n        new_seg2_end = new_segment_points[1]\n        new_solution = np.concatenate([\n            new_solution[:new_seg1_end],\n            new_solution[new_seg1_end:new_seg2_end],\n            new_solution[new_seg2_end:]\n        ])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node clustering and dynamic insertion strategy that partitions the tour into objective-aware clusters, identifies the most critical nodes based on their combined objective contributions, and performs targeted insertions and swaps while dynamically adjusting cluster boundaries and node priorities to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights\n    total = sum(objectives)\n    weights = [obj / total for obj in objectives] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes based on combined objective contributions\n    critical_nodes = []\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost > 0.3 * (sum(distance_matrix_1[prev_node]) / n):  # Threshold for criticality\n            critical_nodes.append(i)\n\n    # Perform targeted operations on critical nodes\n    if critical_nodes:\n        # Select a random critical node\n        critical_idx = random.choice(critical_nodes)\n        node = new_solution[critical_idx]\n\n        # Randomly choose between insertion and swap\n        if random.random() < 0.5:\n            # Insertion operation\n            pos = random.randint(0, n-1)\n            if pos != critical_idx and pos != (critical_idx + 1) % n:\n                new_solution = np.insert(new_solution, pos, node)\n                if critical_idx < pos:\n                    new_solution = np.delete(new_solution, critical_idx + 1)\n                else:\n                    new_solution = np.delete(new_solution, critical_idx)\n        else:\n            # Swap operation with another critical node\n            other_idx = random.choice([i for i in critical_nodes if i != critical_idx])\n            new_solution[critical_idx], new_solution[other_idx] = new_solution[other_idx], new_solution[critical_idx]\n\n    # Ensure the tour remains circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6584693668530173,
            0.9742102146148681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights\n    total = sum(objectives)\n    weights = [obj / total for obj in objectives] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes based on combined objective contributions\n    critical_nodes = []\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if weighted_cost > 0.3 * (sum(distance_matrix_1[prev_node]) / n):  # Threshold for criticality\n            critical_nodes.append(i)\n\n    # Perform targeted operations on critical nodes\n    if critical_nodes:\n        # Select a random critical node\n        critical_idx = random.choice(critical_nodes)\n        node = new_solution[critical_idx]\n\n        # Randomly choose between insertion and swap\n        if random.random() < 0.5:\n            # Insertion operation\n            pos = random.randint(0, n-1)\n            if pos != critical_idx and pos != (critical_idx + 1) % n:\n                new_solution = np.insert(new_solution, pos, node)\n                if critical_idx < pos:\n                    new_solution = np.delete(new_solution, critical_idx + 1)\n                else:\n                    new_solution = np.delete(new_solution, critical_idx)\n        else:\n            # Swap operation with another critical node\n            other_idx = random.choice([i for i in critical_nodes if i != critical_idx])\n            new_solution[critical_idx], new_solution[other_idx] = new_solution[other_idx], new_solution[critical_idx]\n\n    # Ensure the tour remains circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This new algorithm employs a multi-objective adaptive path-relinking with dynamic objective-aware edge selection, where it intelligently selects edges from both parent solutions based on weighted improvements across objectives, constructs a new path by dynamically combining edges while maintaining feasibility, and ensures diverse exploration by balancing exploitation of good edges with exploration of untested combinations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select two reference solutions for path relinking\n    ref1, _ = random.choice(archive)\n    ref2, _ = random.choice(archive)\n\n    # Create a set of edges from both reference solutions\n    edges = set()\n    for sol in [ref1, ref2]:\n        for i in range(len(sol)-1):\n            edges.add((sol[i], sol[i+1]))\n\n    # Build new solution by selecting edges with highest weighted improvement\n    visited = set()\n    current_node = new_solution[0]\n    visited.add(current_node)\n    tour = [current_node]\n\n    while len(visited) < n:\n        candidates = []\n        for next_node in range(n):\n            if next_node not in visited:\n                # Calculate weighted edge cost across all objectives\n                cost1 = distance_matrix_1[current_node, next_node]\n                cost2 = distance_matrix_2[current_node, next_node]\n                cost3 = distance_matrix_3[current_node, next_node]\n                weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n                # Prefer edges that exist in reference solutions\n                bonus = 1 if (current_node, next_node) in edges else 0\n                candidates.append((next_node, weighted_cost - bonus))\n\n        # Select the node with minimum weighted cost\n        next_node, _ = min(candidates, key=lambda x: x[1])\n        tour.append(next_node)\n        visited.add(next_node)\n        current_node = next_node\n\n    # Close the tour\n    tour.append(tour[0])\n    new_solution = np.array(tour)\n\n    return new_solution\n\n",
        "score": [
            -0.7213523373266371,
            2.2586316585540773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select two reference solutions for path relinking\n    ref1, _ = random.choice(archive)\n    ref2, _ = random.choice(archive)\n\n    # Create a set of edges from both reference solutions\n    edges = set()\n    for sol in [ref1, ref2]:\n        for i in range(len(sol)-1):\n            edges.add((sol[i], sol[i+1]))\n\n    # Build new solution by selecting edges with highest weighted improvement\n    visited = set()\n    current_node = new_solution[0]\n    visited.add(current_node)\n    tour = [current_node]\n\n    while len(visited) < n:\n        candidates = []\n        for next_node in range(n):\n            if next_node not in visited:\n                # Calculate weighted edge cost across all objectives\n                cost1 = distance_matrix_1[current_node, next_node]\n                cost2 = distance_matrix_2[current_node, next_node]\n                cost3 = distance_matrix_3[current_node, next_node]\n                weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n                # Prefer edges that exist in reference solutions\n                bonus = 1 if (current_node, next_node) in edges else 0\n                candidates.append((next_node, weighted_cost - bonus))\n\n        # Select the node with minimum weighted cost\n        next_node, _ = min(candidates, key=lambda x: x[1])\n        tour.append(next_node)\n        visited.add(next_node)\n        current_node = next_node\n\n    # Close the tour\n    tour.append(tour[0])\n    new_solution = np.array(tour)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm employs a dynamic objective-aware path inversion and node reinsertion strategy that adaptively selects critical path segments based on their multi-objective impact, inverts them with probability proportional to their imbalance across objectives, and reinserts nodes at positions that minimize the worst-case objective degradation, ensuring feasibility through constrained insertion points and circular tour validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical segments based on objective imbalance\n    critical_segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate objective costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Calculate imbalance\n        imbalance = max(cost1, cost2, cost3) - min(cost1, cost2, cost3)\n\n        # Decide whether to continue current segment\n        if random.random() < 0.7 * (imbalance / max(distance_matrix_1.max(), distance_matrix_2.max(), distance_matrix_3.max())):\n            current_segment.append(node)\n        else:\n            if len(current_segment) > 1:\n                critical_segments.append(current_segment)\n            current_segment = [node]\n\n    if len(current_segment) > 1:\n        critical_segments.append(current_segment)\n\n    # Process critical segments\n    if critical_segments:\n        # Select a segment to invert\n        segment_idx = random.randint(0, len(critical_segments)-1)\n        segment = critical_segments[segment_idx]\n        segment_start = new_solution.tolist().index(segment[0])\n        segment_end = segment_start + len(segment)\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate potential improvement\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(segment_start, segment_end)) +\n            distance_matrix_1[new_solution[segment_end-1], new_solution[segment_start]],\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(segment_start, segment_end)) +\n            distance_matrix_2[new_solution[segment_end-1], new_solution[segment_start]],\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(segment_start, segment_end)) +\n            distance_matrix_3[new_solution[segment_end-1], new_solution[segment_start]]\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment))) +\n            distance_matrix_1[inverted_segment[-1], inverted_segment[0]],\n            sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment))) +\n            distance_matrix_2[inverted_segment[-1], inverted_segment[0]],\n            sum(distance_matrix_3[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment))) +\n            distance_matrix_3[inverted_segment[-1], inverted_segment[0]]\n        ]\n\n        # Only invert if it improves at least one objective\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[segment_start:segment_end] = inverted_segment\n\n    # Node reinsertion with constrained positions\n    if n > 4:\n        # Select a node to reinsert\n        node_idx = random.randint(1, n-2)\n        node = new_solution[node_idx]\n\n        # Find best insertion position that minimizes worst-case objective degradation\n        best_pos = node_idx\n        best_improvement = 0\n\n        for pos in range(1, n):\n            if pos == node_idx or pos == node_idx + 1:\n                continue\n\n            # Calculate potential costs\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            original_costs = [\n                distance_matrix_1[prev_node, new_solution[pos]] + distance_matrix_1[new_solution[pos-1], new_solution[node_idx]],\n                distance_matrix_2[prev_node, new_solution[pos]] + distance_matrix_2[new_solution[pos-1], new_solution[node_idx]],\n                distance_matrix_3[prev_node, new_solution[pos]] + distance_matrix_3[new_solution[pos-1], new_solution[node_idx]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, new_solution[pos]],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, new_solution[pos]],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, new_solution[pos]]\n            ]\n\n            improvement = sum(min(original_cost - new_cost, 0) for original_cost, new_cost in zip(original_costs, new_costs))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Perform the reinsertion\n        if best_pos != node_idx:\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.concatenate([new_solution, [new_solution[0]]])\n\n    return new_solution\n\n",
        "score": [
            -0.6404747049875354,
            3.3743713974952696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical segments based on objective imbalance\n    critical_segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate objective costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Calculate imbalance\n        imbalance = max(cost1, cost2, cost3) - min(cost1, cost2, cost3)\n\n        # Decide whether to continue current segment\n        if random.random() < 0.7 * (imbalance / max(distance_matrix_1.max(), distance_matrix_2.max(), distance_matrix_3.max())):\n            current_segment.append(node)\n        else:\n            if len(current_segment) > 1:\n                critical_segments.append(current_segment)\n            current_segment = [node]\n\n    if len(current_segment) > 1:\n        critical_segments.append(current_segment)\n\n    # Process critical segments\n    if critical_segments:\n        # Select a segment to invert\n        segment_idx = random.randint(0, len(critical_segments)-1)\n        segment = critical_segments[segment_idx]\n        segment_start = new_solution.tolist().index(segment[0])\n        segment_end = segment_start + len(segment)\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate potential improvement\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(segment_start, segment_end)) +\n            distance_matrix_1[new_solution[segment_end-1], new_solution[segment_start]],\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(segment_start, segment_end)) +\n            distance_matrix_2[new_solution[segment_end-1], new_solution[segment_start]],\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(segment_start, segment_end)) +\n            distance_matrix_3[new_solution[segment_end-1], new_solution[segment_start]]\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment))) +\n            distance_matrix_1[inverted_segment[-1], inverted_segment[0]],\n            sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment))) +\n            distance_matrix_2[inverted_segment[-1], inverted_segment[0]],\n            sum(distance_matrix_3[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment))) +\n            distance_matrix_3[inverted_segment[-1], inverted_segment[0]]\n        ]\n\n        # Only invert if it improves at least one objective\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[segment_start:segment_end] = inverted_segment\n\n    # Node reinsertion with constrained positions\n    if n > 4:\n        # Select a node to reinsert\n        node_idx = random.randint(1, n-2)\n        node = new_solution[node_idx]\n\n        # Find best insertion position that minimizes worst-case objective degradation\n        best_pos = node_idx\n        best_improvement = 0\n\n        for pos in range(1, n):\n            if pos == node_idx or pos == node_idx + 1:\n                continue\n\n            # Calculate potential costs\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            original_costs = [\n                distance_matrix_1[prev_node, new_solution[pos]] + distance_matrix_1[new_solution[pos-1], new_solution[node_idx]],\n                distance_matrix_2[prev_node, new_solution[pos]] + distance_matrix_2[new_solution[pos-1], new_solution[node_idx]],\n                distance_matrix_3[prev_node, new_solution[pos]] + distance_matrix_3[new_solution[pos-1], new_solution[node_idx]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, new_solution[pos]],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, new_solution[pos]],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, new_solution[pos]]\n            ]\n\n            improvement = sum(min(original_cost - new_cost, 0) for original_cost, new_cost in zip(original_costs, new_costs))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Perform the reinsertion\n        if best_pos != node_idx:\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.concatenate([new_solution, [new_solution[0]]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This new algorithm employs a multi-objective tour decomposition and reassembly strategy that dynamically partitions the solution into objective-aware sub-tours, evaluates their contributions across all objectives with adaptive weights, and performs sub-tour rotations and inversions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    sub_tours = []\n    current_sub_tour = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_sub_tour) < 4:\n            current_sub_tour.append(node)\n        else:\n            sub_tours.append(current_sub_tour)\n            current_sub_tour = [node]\n\n    if current_sub_tour:\n        sub_tours.append(current_sub_tour)\n\n    if len(sub_tours) > 1:\n        i, j = random.sample(range(len(sub_tours)), 2)\n\n        if random.random() < 0.4:\n            sub_tours[i], sub_tours[j] = sub_tours[j], sub_tours[i]\n        else:\n            sub_tours[i] = sub_tours[i] + sub_tours[j]\n            sub_tours.pop(j)\n\n    new_solution = []\n    for sub_tour in sub_tours:\n        if random.random() < 0.5 and len(sub_tour) > 2:\n            k = random.randint(1, len(sub_tour)-1)\n            sub_tour = sub_tour[k:] + sub_tour[:k]\n        if random.random() < 0.3 and len(sub_tour) > 1:\n            sub_tour = sub_tour[::-1]\n        new_solution.extend(sub_tour)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7421125054124592,
            0.46006319522857664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    sub_tours = []\n    current_sub_tour = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_sub_tour) < 4:\n            current_sub_tour.append(node)\n        else:\n            sub_tours.append(current_sub_tour)\n            current_sub_tour = [node]\n\n    if current_sub_tour:\n        sub_tours.append(current_sub_tour)\n\n    if len(sub_tours) > 1:\n        i, j = random.sample(range(len(sub_tours)), 2)\n\n        if random.random() < 0.4:\n            sub_tours[i], sub_tours[j] = sub_tours[j], sub_tours[i]\n        else:\n            sub_tours[i] = sub_tours[i] + sub_tours[j]\n            sub_tours.pop(j)\n\n    new_solution = []\n    for sub_tour in sub_tours:\n        if random.random() < 0.5 and len(sub_tour) > 2:\n            k = random.randint(1, len(sub_tour)-1)\n            sub_tour = sub_tour[k:] + sub_tour[:k]\n        if random.random() < 0.3 and len(sub_tour) > 1:\n            sub_tour = sub_tour[::-1]\n        new_solution.extend(sub_tour)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7203005173752165,
            0.6307649135589599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node clustering and reordering strategy that dynamically groups nodes based on their multi-objective contributions, evaluates cluster quality using weighted objective improvements, and performs cluster-based reordering while maintaining tour feasibility through a novel cluster merging and splitting mechanism that optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    total = [sum(obj) for obj in objectives]\n    weights = [1/(t+1) for t in total]  # Higher weight for solutions with lower total objectives\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate adaptive weights based on current solution's performance\n    obj_values = archive[selected_idx][1]\n    total_obj = sum(obj_values)\n    weights = [obj / total_obj for obj in obj_values] if total_obj > 0 else [1/3, 1/3, 1/3]\n\n    # Cluster nodes based on multi-objective contributions\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted contribution\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to add to current cluster or start new cluster\n        if random.random() < 0.6 and len(current_cluster) < 4 and weighted_cost < 1.2 * sum(weights):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Evaluate clusters\n    def evaluate_cluster(cluster):\n        total_cost1 = sum(distance_matrix_1[cluster[i-1], cluster[i]] for i in range(1, len(cluster)))\n        total_cost2 = sum(distance_matrix_2[cluster[i-1], cluster[i]] for i in range(1, len(cluster)))\n        total_cost3 = sum(distance_matrix_3[cluster[i-1], cluster[i]] for i in range(1, len(cluster)))\n        return weights[0]*total_cost1 + weights[1]*total_cost2 + weights[2]*total_cost3\n\n    # Sort clusters by their evaluation (descending)\n    clusters.sort(key=evaluate_cluster, reverse=True)\n\n    # Reorder clusters with probability based on their evaluation\n    if len(clusters) > 1:\n        for i in range(len(clusters)):\n            if random.random() < 0.4 * (1 - i/len(clusters)):  # Higher probability for better clusters\n                j = random.randint(0, len(clusters)-1)\n                clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    # Rebuild solution with cluster merging/splitting\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.5 and len(cluster) > 2:\n            # Split cluster\n            split_point = random.randint(1, len(cluster)-1)\n            new_solution.extend(cluster[:split_point])\n            new_solution.extend(cluster[split_point:])\n        else:\n            new_solution.extend(cluster)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6412528060176961,
            1.1093924999237061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    total = [sum(obj) for obj in objectives]\n    weights = [1/(t+1) for t in total]  # Higher weight for solutions with lower total objectives\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate adaptive weights based on current solution's performance\n    obj_values = archive[selected_idx][1]\n    total_obj = sum(obj_values)\n    weights = [obj / total_obj for obj in obj_values] if total_obj > 0 else [1/3, 1/3, 1/3]\n\n    # Cluster nodes based on multi-objective contributions\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted contribution\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to add to current cluster or start new cluster\n        if random.random() < 0.6 and len(current_cluster) < 4 and weighted_cost < 1.2 * sum(weights):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Evaluate clusters\n    def evaluate_cluster(cluster):\n        total_cost1 = sum(distance_matrix_1[cluster[i-1], cluster[i]] for i in range(1, len(cluster)))\n        total_cost2 = sum(distance_matrix_2[cluster[i-1], cluster[i]] for i in range(1, len(cluster)))\n        total_cost3 = sum(distance_matrix_3[cluster[i-1], cluster[i]] for i in range(1, len(cluster)))\n        return weights[0]*total_cost1 + weights[1]*total_cost2 + weights[2]*total_cost3\n\n    # Sort clusters by their evaluation (descending)\n    clusters.sort(key=evaluate_cluster, reverse=True)\n\n    # Reorder clusters with probability based on their evaluation\n    if len(clusters) > 1:\n        for i in range(len(clusters)):\n            if random.random() < 0.4 * (1 - i/len(clusters)):  # Higher probability for better clusters\n                j = random.randint(0, len(clusters)-1)\n                clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    # Rebuild solution with cluster merging/splitting\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.5 and len(cluster) > 2:\n            # Split cluster\n            split_point = random.randint(1, len(cluster)-1)\n            new_solution.extend(cluster[:split_point])\n            new_solution.extend(cluster[split_point:])\n        else:\n            new_solution.extend(cluster)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and spatial diversity, then generates a neighbor by performing a multi-segment inversion and objective-aware edge swaps, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.4*x[1][0] + 0.3*x[1][1] + 0.3*x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(5):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if sum(new_costs) < sum(original_costs):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6564981721233297,
            4.243358159065247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.4*x[1][0] + 0.3*x[1][1] + 0.3*x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(5):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if sum(new_costs) < sum(original_costs):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This novel algorithm employs a multi-objective adaptive segment fusion with dynamic objective-aware path inversion, where it dynamically partitions the tour into segments, evaluates their contributions across all objectives with adaptive weights, and performs segment fusion while selectively inverting paths based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for segment fusion (random between 3 and 5)\n    k = random.randint(3, 5)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform segment fusion: merge worst and best segments\n    segments[worst_seg_idx] = np.concatenate([segments[worst_seg_idx], segments[best_seg_idx]])\n    segments.pop(best_seg_idx)\n\n    # Randomly decide to invert a segment\n    if random.random() < 0.3:\n        invert_idx = random.randint(0, len(segments)-1)\n        segments[invert_idx] = segments[invert_idx][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7271241351868468,
            0.5759768486022949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for segment fusion (random between 3 and 5)\n    k = random.randint(3, 5)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform segment fusion: merge worst and best segments\n    segments[worst_seg_idx] = np.concatenate([segments[worst_seg_idx], segments[best_seg_idx]])\n    segments.pop(best_seg_idx)\n\n    # Randomly decide to invert a segment\n    if random.random() < 0.3:\n        invert_idx = random.randint(0, len(segments)-1)\n        segments[invert_idx] = segments[invert_idx][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and spatial diversity, then generates a neighbor by performing a multi-dimensional 2-opt swap with probabilistic edge reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global perturbation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4*x[1][0] + 0.3*x[1][1] + 0.3*x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional 2-opt swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Probabilistic edge reversal\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(1, n-1), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7654919909742066,
            0.6273174524307251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4*x[1][0] + 0.3*x[1][1] + 0.3*x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional 2-opt swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Probabilistic edge reversal\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(1, n-1), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional segment inversion and adaptive k-opt moves, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / len(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Multi-dimensional segment inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive k-opt move\n    k = random.randint(2, min(4, n-2))\n    if random.random() < 0.5:\n        indices = sorted(random.sample(range(1, n-1), k))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.649463578213283,
            0.6937602519989013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / len(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Multi-dimensional segment inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive k-opt move\n    k = random.randint(2, min(4, n-2))\n    if random.random() < 0.5:\n        indices = sorted(random.sample(range(1, n-1), k))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional segment inversion with adaptive segment merging, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high diversity in objectives\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-dimensional segment inversion\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[i:j+1]\n\n    # Invert the segment in each objective space with probability based on objective improvement potential\n    for k in range(3):\n        if random.random() < 0.7:  # Higher probability for more promising objectives\n            segment = segment[::-1]\n\n    new_solution[i:j+1] = segment\n\n    # Adaptive segment merging\n    if random.random() < 0.3:\n        k = random.randint(1, n//2)\n        segment1 = new_solution[:k]\n        segment2 = new_solution[k:]\n\n        # Merge segments with probability based on spatial proximity\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment2, segment1])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7032877362162895,
            0.9398420691490174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high diversity in objectives\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-dimensional segment inversion\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[i:j+1]\n\n    # Invert the segment in each objective space with probability based on objective improvement potential\n    for k in range(3):\n        if random.random() < 0.7:  # Higher probability for more promising objectives\n            segment = segment[::-1]\n\n    new_solution[i:j+1] = segment\n\n    # Adaptive segment merging\n    if random.random() < 0.3:\n        k = random.randint(1, n//2)\n        segment1 = new_solution[:k]\n        segment2 = new_solution[k:]\n\n        # Merge segments with probability based on spatial proximity\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment2, segment1])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7670197988537979,
            4.3634209632873535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial clustering, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of local and global structural modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum((x[1][i] - min(x[1]) for i in range(3))))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Adaptive segment rotation\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        m = random.randint(k+1, n-1)\n        segment = new_solution[k:m+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[k:m+1] = rotated_segment\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6283258837588945,
            1.468884325027466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum((x[1][i] - min(x[1]) for i in range(3))))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Adaptive segment rotation\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        m = random.randint(k+1, n-1)\n        segment = new_solution[k:m+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[k:m+1] = rotated_segment\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment inversion with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and inverts selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while balancing exploitation of high-potential regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for inversion with higher probability of worst segment\n    if random.random() < 0.7:\n        worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Randomly select a segment to invert\n        seg_idx = random.randint(0, 2)\n        segments = [seg1, seg2, seg3]\n        segments[seg_idx] = segments[seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6702435867206809,
            0.4658035159111023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for inversion with higher probability of worst segment\n    if random.random() < 0.7:\n        worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Randomly select a segment to invert\n        seg_idx = random.randint(0, 2)\n        segments = [seg1, seg2, seg3]\n        segments[seg_idx] = segments[seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This new algorithm intelligently selects a solution from the archive based on a combination of objective balance and spatial diversity, then generates a neighbor by performing a multi-dimensional segment relocation with adaptive path reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive path reversal with objective-aware probability\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(1, len(new_solution)-1), 2))\n        # Calculate improvement potential\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        ]\n        reversed_segment = new_solution[c:d+1][::-1]\n        temp_solution = np.concatenate([new_solution[:c], reversed_segment, new_solution[d+1:]])\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        ]\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6460277451113902,
            0.7041365146636963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive path reversal with objective-aware probability\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(1, len(new_solution)-1), 2))\n        # Calculate improvement potential\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        ]\n        reversed_segment = new_solution[c:d+1][::-1]\n        temp_solution = np.concatenate([new_solution[:c], reversed_segment, new_solution[d+1:]])\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        ]\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional path relocation with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional path relocation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.5:\n        x, y = sorted(random.sample(range(n), 2))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.631123611125718,
            0.6180408239364624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional path relocation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Adaptive segment reversal\n    if random.random() < 0.5:\n        x, y = sorted(random.sample(range(n), 2))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective trade-off analysis, then generates a neighbor by performing a hybrid of node insertion and segment rotation, ensuring feasibility while potentially improving all three objectives through a combination of local refinement and strategic node repositioning.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = np.array([obj for _, obj in archive])\n    ideal = np.min(obj_values, axis=0)\n    nadir = np.max(obj_values, axis=0)\n    normalized = (obj_values - ideal) / (nadir - ideal + 1e-10)\n    scores = np.max(normalized, axis=1)\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid node insertion and segment rotation\n    if random.random() < 0.5:\n        # Node insertion\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment rotation\n        k = random.randint(2, min(4, n//2))\n        start = random.randint(1, n-k-1)\n        segment = new_solution[start:start+k]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+k:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.7402167319562953,
            3.6898420691490172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = np.array([obj for _, obj in archive])\n    ideal = np.min(obj_values, axis=0)\n    nadir = np.max(obj_values, axis=0)\n    normalized = (obj_values - ideal) / (nadir - ideal + 1e-10)\n    scores = np.max(normalized, axis=1)\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid node insertion and segment rotation\n    if random.random() < 0.5:\n        # Node insertion\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment rotation\n        k = random.randint(2, min(4, n//2))\n        start = random.randint(1, n-k-1)\n        segment = new_solution[start:start+k]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+k:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.8515659190326993,
            2.993836760520935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour decomposition and reassembly strategy that dynamically partitions the solution into objective-aware sub-tours, evaluates their contributions across all objectives with adaptive weights, and performs sub-tour rotations and inversions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    sub_tours = []\n    current_sub_tour = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_sub_tour) < 4:\n            current_sub_tour.append(node)\n        else:\n            sub_tours.append(current_sub_tour)\n            current_sub_tour = [node]\n\n    if current_sub_tour:\n        sub_tours.append(current_sub_tour)\n\n    if len(sub_tours) > 1:\n        i, j = random.sample(range(len(sub_tours)), 2)\n\n        if random.random() < 0.4:\n            sub_tours[i], sub_tours[j] = sub_tours[j], sub_tours[i]\n        else:\n            sub_tours[i] = sub_tours[i] + sub_tours[j]\n            sub_tours.pop(j)\n\n    new_solution = []\n    for sub_tour in sub_tours:\n        if random.random() < 0.5 and len(sub_tour) > 2:\n            k = random.randint(1, len(sub_tour)-1)\n            sub_tour = sub_tour[k:] + sub_tour[:k]\n        if random.random() < 0.3 and len(sub_tour) > 1:\n            sub_tour = sub_tour[::-1]\n        new_solution.extend(sub_tour)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This new algorithm employs an adaptive multi-objective tour segmentation and reassembly strategy that dynamically segments the solution into objective-sensitive segments, evaluates their contributions with adaptive weights, and performs segment rotations and inversions while maintaining feasibility through a circular permutation mechanism that ensures tour continuity and optimizes all three objectives in a coordinated manner.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.5 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for segment in segments:\n        if random.random() < 0.6 and len(segment) > 2:\n            k = random.randint(1, len(segment)-1)\n            segment = segment[k:] + segment[:k]\n        if random.random() < 0.4 and len(segment) > 1:\n            segment = segment[::-1]\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.5356768826406877,
            0.3567369103431702
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.5 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for segment in segments:\n        if random.random() < 0.6 and len(segment) > 2:\n            k = random.randint(1, len(segment)-1)\n            segment = segment[k:] + segment[:k]\n        if random.random() < 0.4 and len(segment) > 1:\n            segment = segment[::-1]\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a multi-objective-aware 3-opt move followed by a segment swap, ensuring feasibility while balancing exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n        new_solution = base_solution.copy()\n        n = len(new_solution)\n        if n >= 3:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:k+1] = np.concatenate([new_solution[j:k+1], new_solution[i:j]])\n        return new_solution\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with lowest crowding distance (less crowded regions)\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:k+1] = np.concatenate([new_solution[j:k+1], new_solution[i:j]])\n\n    # Perform segment swap\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = random.randint(1, min(3, n - max(a, b)))\n        if a + segment_length <= n and b + segment_length <= n:\n            temp = new_solution[a:a+segment_length].copy()\n            new_solution[a:a+segment_length] = new_solution[b:b+segment_length]\n            new_solution[b:b+segment_length] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.6346883437567252,
            3.2022756338119507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n        new_solution = base_solution.copy()\n        n = len(new_solution)\n        if n >= 3:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:k+1] = np.concatenate([new_solution[j:k+1], new_solution[i:j]])\n        return new_solution\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with lowest crowding distance (less crowded regions)\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:k+1] = np.concatenate([new_solution[j:k+1], new_solution[i:j]])\n\n    # Perform segment swap\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = random.randint(1, min(3, n - max(a, b)))\n        if a + segment_length <= n and b + segment_length <= n:\n            temp = new_solution[a:a+segment_length].copy()\n            new_solution[a:a+segment_length] = new_solution[b:b+segment_length]\n            new_solution[b:b+segment_length] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This new algorithm employs an adaptive multi-objective tour fragmentation with dynamic objective-aware node selection, where it fragments the tour into segments, evaluates node contributions across all objectives with dynamically adjusted weights, and performs segment-based swaps while dynamically adjusting node positions based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    def evaluate_node(node_idx):\n        prev_node = new_solution[node_idx - 1] if node_idx > 0 else new_solution[-2]\n        next_node = new_solution[node_idx + 1] if node_idx < n - 1 else new_solution[0]\n        cost1 = distance_matrix_1[prev_node, new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], next_node]\n        cost2 = distance_matrix_2[prev_node, new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], next_node]\n        cost3 = distance_matrix_3[prev_node, new_solution[node_idx]] + distance_matrix_3[new_solution[node_idx], next_node]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    node_scores = [evaluate_node(i) for i in range(n)]\n\n    worst_nodes = sorted(range(n), key=lambda i: node_scores[i])[-2:]\n    best_nodes = sorted(range(n), key=lambda i: node_scores[i])[:2]\n\n    if random.random() < 0.7:\n        new_solution[worst_nodes[0]], new_solution[best_nodes[0]] = new_solution[best_nodes[0]], new_solution[worst_nodes[0]]\n    else:\n        new_solution[worst_nodes[1]], new_solution[best_nodes[1]] = new_solution[best_nodes[1]], new_solution[worst_nodes[1]]\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6867971113784511,
            0.5505139708518982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    def evaluate_node(node_idx):\n        prev_node = new_solution[node_idx - 1] if node_idx > 0 else new_solution[-2]\n        next_node = new_solution[node_idx + 1] if node_idx < n - 1 else new_solution[0]\n        cost1 = distance_matrix_1[prev_node, new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], next_node]\n        cost2 = distance_matrix_2[prev_node, new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], next_node]\n        cost3 = distance_matrix_3[prev_node, new_solution[node_idx]] + distance_matrix_3[new_solution[node_idx], next_node]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    node_scores = [evaluate_node(i) for i in range(n)]\n\n    worst_nodes = sorted(range(n), key=lambda i: node_scores[i])[-2:]\n    best_nodes = sorted(range(n), key=lambda i: node_scores[i])[:2]\n\n    if random.random() < 0.7:\n        new_solution[worst_nodes[0]], new_solution[best_nodes[0]] = new_solution[best_nodes[0]], new_solution[worst_nodes[0]]\n    else:\n        new_solution[worst_nodes[1]], new_solution[best_nodes[1]] = new_solution[best_nodes[1]], new_solution[worst_nodes[1]]\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i-1)%n or j == (i+1)%n:\n        j = random.randint(0, n-1)\n\n    node = new_solution[i]\n    temp_solution = np.delete(new_solution, i)\n    temp_solution = np.insert(temp_solution, j, node)\n\n    # Accept insertion if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[(j+1)%(n-1)], temp_solution[j]],\n        distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[(j+1)%(n-1)], temp_solution[j]],\n        distance_matrix_3[temp_solution[j-1], temp_solution[j]] + distance_matrix_3[temp_solution[(j+1)%(n-1)], temp_solution[j]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment reversal\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7576461817723995,
            2.2718667149543763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i-1)%n or j == (i+1)%n:\n        j = random.randint(0, n-1)\n\n    node = new_solution[i]\n    temp_solution = np.delete(new_solution, i)\n    temp_solution = np.insert(temp_solution, j, node)\n\n    # Accept insertion if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[(j+1)%(n-1)], temp_solution[j]],\n        distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[(j+1)%(n-1)], temp_solution[j]],\n        distance_matrix_3[temp_solution[j-1], temp_solution[j]] + distance_matrix_3[temp_solution[(j+1)%(n-1)], temp_solution[j]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment reversal\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then generates a neighbor by performing a dynamic multi-dimensional 2-opt swap with probabilistic path reversal, ensuring feasibility while balancing exploration of different objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.random.dirichlet(np.ones(3))\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic multi-dimensional 2-opt swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic path reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6767087199701528,
            0.711298406124115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.random.dirichlet(np.ones(3))\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic multi-dimensional 2-opt swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic path reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted combination of objective values and structural diversity, then generates a neighbor by performing a multi-objective-aware 3-opt move followed by a segment rotation, ensuring feasibility while balancing exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n    weights = [1/(std + 1e-6) for std in std_objectives]\n    weights = [w/sum(weights) for w in weights]\n\n    # Selection strategy: prefer solutions with better combined score but occasionally explore diverse ones\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        length = random.randint(2, min(4, n - start))\n        segment = new_solution[start:start+length]\n        shift = random.randint(1, length - 1)\n        new_solution[start:start+length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    return new_solution\n\n",
        "score": [
            -0.7500548017860271,
            2.9953336477279664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n    weights = [1/(std + 1e-6) for std in std_objectives]\n    weights = [w/sum(weights) for w in weights]\n\n    # Selection strategy: prefer solutions with better combined score but occasionally explore diverse ones\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        length = random.randint(2, min(4, n - start))\n        segment = new_solution[start:start+length]\n        shift = random.randint(1, length - 1)\n        new_solution[start:start+length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6630409520155565,
            0.39206063747406006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware segment inversion and position-based swaps, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_balance(obj):\n        return sum(obj) / len(obj)\n\n    selected_solution = min(archive, key=lambda x: objective_balance(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n    new_solution[i:j+1] = inverted_segment\n\n    # Perform position-based swaps\n    if n >= 4:\n        for _ in range(2):\n            pos = random.randint(0, n-1)\n            swap_pos = (pos + random.randint(1, n//2)) % n\n            new_solution[pos], new_solution[swap_pos] = new_solution[swap_pos], new_solution[pos]\n\n    return new_solution\n\n",
        "score": [
            -0.7572552258885084,
            2.1217432618141174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_balance(obj):\n        return sum(obj) / len(obj)\n\n    selected_solution = min(archive, key=lambda x: objective_balance(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n    new_solution[i:j+1] = inverted_segment\n\n    # Perform position-based swaps\n    if n >= 4:\n        for _ in range(2):\n            pos = random.randint(0, n-1)\n            swap_pos = (pos + random.randint(1, n//2)) % n\n            new_solution[pos], new_solution[swap_pos] = new_solution[swap_pos], new_solution[pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm employs a multi-objective adaptive path decomposition with dynamic objective-aware path merging, where it dynamically partitions the tour into critical and non-critical paths based on their objective contributions, then intelligently merges or splits these paths while maintaining feasibility and promoting balanced optimization across all objectives through dynamic weight adjustment and path reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (max(x[1]) - min(x[1])) if len(x[1]) > 1 else x[1][0])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic objective weights based on current solution's objectives\n    obj_values = selected[1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical and non-critical paths\n    def evaluate_path(path):\n        cost1 = sum(distance_matrix_1[path[i], path[i+1]] for i in range(len(path)-1))\n        cost2 = sum(distance_matrix_2[path[i], path[i+1]] for i in range(len(path)-1))\n        cost3 = sum(distance_matrix_3[path[i], path[i+1]] for i in range(len(path)-1))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    # Split solution into potential paths\n    split_points = sorted(random.sample(range(1, n-1), min(3, n//2)))\n    paths = []\n    prev = 0\n    for point in split_points:\n        paths.append(new_solution[prev:point])\n        prev = point\n    paths.append(new_solution[prev:])\n\n    # Evaluate paths and identify critical ones\n    path_scores = [evaluate_path(path) for path in paths]\n    critical_indices = sorted(range(len(paths)), key=lambda i: path_scores[i])[:len(paths)//2]\n\n    # Merge critical paths\n    if len(critical_indices) > 1:\n        merged_path = []\n        for i in critical_indices:\n            merged_path.extend(paths[i])\n        # Insert merged path back into solution\n        new_solution = np.concatenate([merged_path, np.concatenate([p for i, p in enumerate(paths) if i not in critical_indices])])\n\n    # Reorder paths based on objective weights\n    if random.random() < 0.5:\n        # Reorder paths by weighted objective importance\n        ordered_paths = sorted(paths, key=lambda p: evaluate_path(p), reverse=True)\n        new_solution = np.concatenate(ordered_paths)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7004392908316703,
            0.6481403827667236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (max(x[1]) - min(x[1])) if len(x[1]) > 1 else x[1][0])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic objective weights based on current solution's objectives\n    obj_values = selected[1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical and non-critical paths\n    def evaluate_path(path):\n        cost1 = sum(distance_matrix_1[path[i], path[i+1]] for i in range(len(path)-1))\n        cost2 = sum(distance_matrix_2[path[i], path[i+1]] for i in range(len(path)-1))\n        cost3 = sum(distance_matrix_3[path[i], path[i+1]] for i in range(len(path)-1))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    # Split solution into potential paths\n    split_points = sorted(random.sample(range(1, n-1), min(3, n//2)))\n    paths = []\n    prev = 0\n    for point in split_points:\n        paths.append(new_solution[prev:point])\n        prev = point\n    paths.append(new_solution[prev:])\n\n    # Evaluate paths and identify critical ones\n    path_scores = [evaluate_path(path) for path in paths]\n    critical_indices = sorted(range(len(paths)), key=lambda i: path_scores[i])[:len(paths)//2]\n\n    # Merge critical paths\n    if len(critical_indices) > 1:\n        merged_path = []\n        for i in critical_indices:\n            merged_path.extend(paths[i])\n        # Insert merged path back into solution\n        new_solution = np.concatenate([merged_path, np.concatenate([p for i, p in enumerate(paths) if i not in critical_indices])])\n\n    # Reorder paths based on objective weights\n    if random.random() < 0.5:\n        # Reorder paths by weighted objective importance\n        ordered_paths = sorted(paths, key=lambda p: evaluate_path(p), reverse=True)\n        new_solution = np.concatenate(ordered_paths)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware partial reversal and segment transposition, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform partial reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform segment transposition\n    if n >= 4:\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-1)\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:a], new_solution[b:]])\n\n    return new_solution\n\n",
        "score": [
            -0.4931279347438037,
            1.3366631627082826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform partial reversal\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+4, n-1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform segment transposition\n    if n >= 4:\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-1)\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:a], new_solution[b:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional segment rotation with adaptive node insertion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment rotation\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    new_solution = np.concatenate([\n        new_solution[:a], rotated_segment, new_solution[b+1:]\n    ])\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        while j == i or j == i+1 or j == i-1:\n            j = random.randint(1, n-2)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([\n            new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]\n        ])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6545878188637717,
            0.49990450143814086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment rotation\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    new_solution = np.concatenate([\n        new_solution[:a], rotated_segment, new_solution[b+1:]\n    ])\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        while j == i or j == i+1 or j == i-1:\n            j = random.randint(1, n-2)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([\n            new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]\n        ])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm employs an adaptive multi-objective path relinking with dynamic objective-aware node swapping, where it intelligently selects nodes based on their contributions across all objectives with dynamically adjusted weights, performs targeted swaps between nodes, and dynamically refines the tour by reordering segments while ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Evaluate nodes based on their contribution to all objectives\n    node_scores = []\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n        node_scores.append(weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3)\n\n    # Select nodes for swapping\n    if len(node_scores) > 1:\n        worst_node_idx = node_scores.index(max(node_scores))\n        best_node_idx = node_scores.index(min(node_scores))\n\n        # Perform targeted swap\n        new_solution[worst_node_idx], new_solution[best_node_idx] = new_solution[best_node_idx], new_solution[worst_node_idx]\n\n    # Dynamic segment reordering\n    if n > 3:\n        segment_length = max(2, n // 4)\n        for i in range(0, n-segment_length, segment_length):\n            segment = new_solution[i:i+segment_length]\n            if random.random() < 0.3:\n                new_solution[i:i+segment_length] = segment[::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7309426528037442,
            0.3326067328453064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Evaluate nodes based on their contribution to all objectives\n    node_scores = []\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n        node_scores.append(weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3)\n\n    # Select nodes for swapping\n    if len(node_scores) > 1:\n        worst_node_idx = node_scores.index(max(node_scores))\n        best_node_idx = node_scores.index(min(node_scores))\n\n        # Perform targeted swap\n        new_solution[worst_node_idx], new_solution[best_node_idx] = new_solution[best_node_idx], new_solution[worst_node_idx]\n\n    # Dynamic segment reordering\n    if n > 3:\n        segment_length = max(2, n // 4)\n        for i in range(0, n-segment_length, segment_length):\n            segment = new_solution[i:i+segment_length]\n            if random.random() < 0.3:\n                new_solution[i:i+segment_length] = segment[::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This new algorithm selects a solution from the archive based on the most balanced objectives (minimizing the range between objectives) and then generates a neighbor by performing a multi-objective-aware 2-opt swap combined with a probabilistic segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of local and global search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-objective-aware 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    # Calculate cost changes for all objectives\n    original_cost = sum([\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n    ])\n\n    new_cost = sum([\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n    ])\n\n    # Accept if improvement in any objective or probabilistic acceptance\n    if new_cost < original_cost or random.random() < 0.3:\n        new_solution = temp_solution\n\n    # Perform probabilistic segment reversal\n    if random.random() < 0.5 and n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8318175615474546,
            3.248609483242035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-objective-aware 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    # Calculate cost changes for all objectives\n    original_cost = sum([\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n    ])\n\n    new_cost = sum([\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n    ])\n\n    # Accept if improvement in any objective or probabilistic acceptance\n    if new_cost < original_cost or random.random() < 0.3:\n        new_solution = temp_solution\n\n    # Perform probabilistic segment reversal\n    if random.random() < 0.5 and n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection and weighted segment evaluation, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [0.3, 0.3, 0.4]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.3:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6339775430924554,
            0.37205915451049804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [0.3, 0.3, 0.4]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.3:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    # Check if 2-opt improves any objective\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment inversion\n    if n >= 4:\n        k = random.randint(1, n-2)\n        l = random.randint(k+1, n-1)\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.426980465774076,
            2.580606186389923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    # Check if 2-opt improves any objective\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment inversion\n    if n >= 4:\n        k = random.randint(1, n-2)\n        l = random.randint(k+1, n-1)\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and solution structure diversity, then generates a neighbor by performing a multi-objective-aware edge insertion followed by a segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(abs(x[1][i] - x[1][j]) for i in range(3) for j in range(i+1, 3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform edge insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 4)\n        segment = new_solution[start:start+4]\n        rotated_segment = np.roll(segment, random.randint(1, 3))\n        new_solution[start:start+4] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.4946705226428508,
            1.5574284791946411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(abs(x[1][i] - x[1][j]) for i in range(3) for j in range(i+1, 3)))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform edge insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 4)\n        segment = new_solution[start:start+4]\n        rotated_segment = np.roll(segment, random.randint(1, 3))\n        new_solution[start:start+4] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6659908139149268,
            0.2437220573425293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6659908139149268,
            0.2437220573425293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{A novel multi-objective local search algorithm that combines a hybrid of 4-opt with adaptive segment reversal, dynamically selects the most promising segments based on objective improvement, and evaluates the trade-off between all three objectives to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Calculate original costs\n    def calculate_costs(solution):\n        return (\n            sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n)),\n            sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n)),\n            sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(n))\n        )\n\n    original_costs = calculate_costs(new_solution)\n\n    # Perform 4-opt move: select four distinct positions and reverse segments between them\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:l+1]\n\n    # Reconstruct the solution with reversed segments\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment1[::-1],\n        segment2[::-1],\n        segment3[::-1],\n        new_solution[l+1:]\n    ])\n\n    # Calculate new costs\n    new_costs = calculate_costs(new_solution)\n\n    # Revert if no improvement in any objective\n    if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = base_solution.copy()\n\n    # Perform adaptive segment reversal based on objective improvement\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Calculate new costs\n        new_costs = calculate_costs(new_solution)\n\n        # Revert if no improvement in any objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7545704944534055,
            2.713128316402435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Calculate original costs\n    def calculate_costs(solution):\n        return (\n            sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n)),\n            sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n)),\n            sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(n))\n        )\n\n    original_costs = calculate_costs(new_solution)\n\n    # Perform 4-opt move: select four distinct positions and reverse segments between them\n    i, j, k, l = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:l+1]\n\n    # Reconstruct the solution with reversed segments\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment1[::-1],\n        segment2[::-1],\n        segment3[::-1],\n        new_solution[l+1:]\n    ])\n\n    # Calculate new costs\n    new_costs = calculate_costs(new_solution)\n\n    # Revert if no improvement in any objective\n    if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = base_solution.copy()\n\n    # Perform adaptive segment reversal based on objective improvement\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Calculate new costs\n        new_costs = calculate_costs(new_solution)\n\n        # Revert if no improvement in any objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional segment inversion with adaptive node swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment inversion\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive node swapping\n    if random.random() < 0.7:\n        k, l = random.sample(range(1, n-1), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6489021040839383,
            0.3115077972412109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment inversion\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive node swapping\n    if random.random() < 0.7:\n        k, l = random.sample(range(1, n-1), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial diversity, then generates a neighbor by performing a multi-dimensional k-opt exchange with adaptive segment insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    k = random.randint(2, min(5, n-1))\n    indices = sorted(random.sample(range(n), k))\n    segment = new_solution[indices[0]:indices[-1]+1]\n    new_solution = np.concatenate([new_solution[:indices[0]], new_solution[indices[-1]+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6793060827935499,
            0.6068922758102417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    k = random.randint(2, min(5, n-1))\n    indices = sorted(random.sample(range(n), k))\n    segment = new_solution[indices[0]:indices[-1]+1]\n    new_solution = np.concatenate([new_solution[:indices[0]], new_solution[indices[-1]+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This new algorithm employs a multi-objective hybrid local search that dynamically combines 2-opt and segment-based crossover with adaptive objective weighting, where it first identifies critical segments based on their weighted contributions across objectives, then applies targeted 2-opt improvements within these segments while dynamically adjusting the weights based on segment performance, ensuring feasibility and promoting balanced exploration of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments\n    segment_length = max(3, n // 4)\n    segments = [new_solution[i:i+segment_length] for i in range(0, n, segment_length)]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    segment_scores = [evaluate_segment(seg) for seg in segments]\n    critical_seg_idx = max(range(len(segments)), key=lambda i: segment_scores[i])\n    critical_seg = segments[critical_seg_idx]\n\n    # Apply 2-opt within critical segment\n    improved = False\n    for i in range(len(critical_seg)-1):\n        for j in range(i+2, len(critical_seg)):\n            if i == 0 and j == len(critical_seg)-1:\n                continue\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[critical_seg[i-1], critical_seg[i]] +\n                        distance_matrix_1[critical_seg[j], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_2[critical_seg[i-1], critical_seg[i]] +\n                        distance_matrix_2[critical_seg[j], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_3[critical_seg[i-1], critical_seg[i]] +\n                        distance_matrix_3[critical_seg[j], critical_seg[(j+1)%len(critical_seg)]])\n            new_cost = (distance_matrix_1[critical_seg[i-1], critical_seg[j]] +\n                        distance_matrix_1[critical_seg[i], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_2[critical_seg[i-1], critical_seg[j]] +\n                        distance_matrix_2[critical_seg[i], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_3[critical_seg[i-1], critical_seg[j]] +\n                        distance_matrix_3[critical_seg[i], critical_seg[(j+1)%len(critical_seg)]])\n            if new_cost < old_cost:\n                critical_seg[i:j+1] = critical_seg[i:j+1][::-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    # Reconstruct solution\n    segments[critical_seg_idx] = critical_seg\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7233581572344285,
            0.3661839008331299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments\n    segment_length = max(3, n // 4)\n    segments = [new_solution[i:i+segment_length] for i in range(0, n, segment_length)]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    segment_scores = [evaluate_segment(seg) for seg in segments]\n    critical_seg_idx = max(range(len(segments)), key=lambda i: segment_scores[i])\n    critical_seg = segments[critical_seg_idx]\n\n    # Apply 2-opt within critical segment\n    improved = False\n    for i in range(len(critical_seg)-1):\n        for j in range(i+2, len(critical_seg)):\n            if i == 0 and j == len(critical_seg)-1:\n                continue\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[critical_seg[i-1], critical_seg[i]] +\n                        distance_matrix_1[critical_seg[j], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_2[critical_seg[i-1], critical_seg[i]] +\n                        distance_matrix_2[critical_seg[j], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_3[critical_seg[i-1], critical_seg[i]] +\n                        distance_matrix_3[critical_seg[j], critical_seg[(j+1)%len(critical_seg)]])\n            new_cost = (distance_matrix_1[critical_seg[i-1], critical_seg[j]] +\n                        distance_matrix_1[critical_seg[i], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_2[critical_seg[i-1], critical_seg[j]] +\n                        distance_matrix_2[critical_seg[i], critical_seg[(j+1)%len(critical_seg)]] +\n                        distance_matrix_3[critical_seg[i-1], critical_seg[j]] +\n                        distance_matrix_3[critical_seg[i], critical_seg[(j+1)%len(critical_seg)]])\n            if new_cost < old_cost:\n                critical_seg[i:j+1] = critical_seg[i:j+1][::-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    # Reconstruct solution\n    segments[critical_seg_idx] = critical_seg\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional crossover with adaptive segment insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-dimensional crossover\n    crossover_point = random.randint(1, n-2)\n    donor_solution = random.choice(archive)[0]\n\n    # Adaptive segment insertion\n    segment_length = random.randint(2, min(5, n//2))\n    segment_start = random.randint(0, n - segment_length)\n    segment = donor_solution[segment_start:segment_start+segment_length]\n\n    # Insert segment into new solution\n    insert_pos = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos + segment_length:]\n    ])\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6342887954069801,
            1.1378873825073241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-dimensional crossover\n    crossover_point = random.randint(1, n-2)\n    donor_solution = random.choice(archive)[0]\n\n    # Adaptive segment insertion\n    segment_length = random.randint(2, min(5, n//2))\n    segment_start = random.randint(0, n - segment_length)\n    segment = donor_solution[segment_start:segment_start+segment_length]\n\n    # Insert segment into new solution\n    insert_pos = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos + segment_length:]\n    ])\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This new algorithm employs a multi-objective tour fragmentation and reassembly strategy that dynamically partitions the tour into non-overlapping segments based on their Pareto dominance across objectives, then reassembles them using a hybrid of segment inversion and rotation to explore diverse trade-offs while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segmentation based on Pareto dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate objective improvements\n        improvements = [\n            distance_matrix_1[prev_node, node] - distance_matrix_1[prev_node, new_solution[0]],\n            distance_matrix_2[prev_node, node] - distance_matrix_2[prev_node, new_solution[0]],\n            distance_matrix_3[prev_node, node] - distance_matrix_3[prev_node, new_solution[0]]\n        ]\n\n        # Check if node dominates previous segment\n        if all(imp <= 0 for imp in improvements) and any(imp < 0 for imp in improvements):\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Reassemble segments with hybrid operations\n    if len(segments) > 1:\n        if random.random() < 0.5:\n            # Segment inversion\n            seg_idx = random.randint(0, len(segments)-1)\n            segments[seg_idx] = segments[seg_idx][::-1]\n        else:\n            # Segment rotation\n            seg_idx = random.randint(0, len(segments)-1)\n            rotate_pos = random.randint(0, len(segments[seg_idx])-1)\n            segments[seg_idx] = segments[seg_idx][rotate_pos:] + segments[seg_idx][:rotate_pos]\n\n    # Reconstruct tour\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6665107532796182,
            1.5394178748130798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segmentation based on Pareto dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate objective improvements\n        improvements = [\n            distance_matrix_1[prev_node, node] - distance_matrix_1[prev_node, new_solution[0]],\n            distance_matrix_2[prev_node, node] - distance_matrix_2[prev_node, new_solution[0]],\n            distance_matrix_3[prev_node, node] - distance_matrix_3[prev_node, new_solution[0]]\n        ]\n\n        # Check if node dominates previous segment\n        if all(imp <= 0 for imp in improvements) and any(imp < 0 for imp in improvements):\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Reassemble segments with hybrid operations\n    if len(segments) > 1:\n        if random.random() < 0.5:\n            # Segment inversion\n            seg_idx = random.randint(0, len(segments)-1)\n            segments[seg_idx] = segments[seg_idx][::-1]\n        else:\n            # Segment rotation\n            seg_idx = random.randint(0, len(segments)-1)\n            rotate_pos = random.randint(0, len(segments[seg_idx])-1)\n            segments[seg_idx] = segments[seg_idx][rotate_pos:] + segments[seg_idx][:rotate_pos]\n\n    # Reconstruct tour\n    new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm employs a novel multi-objective-aware segment merging and reordering strategy that dynamically combines segments based on their relative dominance in each objective space, performs cross-segment merges with probability proportional to the segment's contribution to the objectives, and applies adaptive segment rotations to optimize all three objectives while maintaining tour feasibility through a circular permutation mechanism that preserves node order continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.5 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        for _ in range(2):\n            if len(segments) < 2:\n                break\n            i, j = random.sample(range(len(segments)), 2)\n            if random.random() < 0.6:\n                merged = segments[i] + segments[j]\n                segments.pop(max(i, j))\n                segments.pop(min(i, j))\n                segments.append(merged)\n            else:\n                segments[i], segments[j] = segments[j], segments[i]\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6949283292253072,
            0.6022791147232056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.5 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        for _ in range(2):\n            if len(segments) < 2:\n                break\n            i, j = random.sample(range(len(segments)), 2)\n            if random.random() < 0.6:\n                merged = segments[i] + segments[j]\n                segments.pop(max(i, j))\n                segments.pop(min(i, j))\n                segments.append(merged)\n            else:\n                segments[i], segments[j] = segments[j], segments[i]\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This new algorithm employs a dynamic objective-aware segment inversion with adaptive weight-based segment selection, where it identifies segments with high weighted costs, inverts their order, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility while promoting exploration of the solution space across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segment with highest weighted cost and invert it\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n    segments = [seg1, seg2, seg3]\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6314779911184474,
            0.6009064555168152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segment with highest weighted cost and invert it\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n    segments = [seg1, seg2, seg3]\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment inversion with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and inverts selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n    segments = [seg1, seg2, seg3]\n\n    if random.random() < 0.7:\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    else:\n        split_point = random.randint(1, len(segments[worst_seg_idx])-1)\n        segments[worst_seg_idx] = np.concatenate([segments[worst_seg_idx][:split_point][::-1], segments[worst_seg_idx][split_point:][::-1]])\n\n    new_solution = np.concatenate(segments)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6475023764172112,
            0.5362366199493408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n    segments = [seg1, seg2, seg3]\n\n    if random.random() < 0.7:\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    else:\n        split_point = random.randint(1, len(segments[worst_seg_idx])-1)\n        segments[worst_seg_idx] = np.concatenate([segments[worst_seg_idx][:split_point][::-1], segments[worst_seg_idx][split_point:][::-1]])\n\n    new_solution = np.concatenate(segments)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This new algorithm employs a dynamic objective-weighted path inversion and node exchange strategy that adaptively selects critical path segments based on their multi-objective contributions, applies weighted inversions to improve balance across objectives, and performs node exchanges while maintaining tour feasibility through a constrained swap mechanism that ensures no node is revisited or skipped.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on weighted contributions\n    critical_segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted contribution\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Probabilistically extend or finalize segment\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            if len(current_segment) > 1:\n                critical_segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment and len(current_segment) > 1:\n        critical_segments.append(current_segment)\n\n    # Apply weighted inversion to critical segments\n    if critical_segments:\n        seg_idx = random.randint(0, len(critical_segments)-1)\n        segment = critical_segments[seg_idx]\n\n        if len(segment) > 2 and random.random() < 0.7:\n            # Weighted inversion decision\n            inv_weight = sum(weights[i] * (distance_matrix_1[segment[0], segment[-1]] +\n                                          distance_matrix_2[segment[0], segment[-1]] +\n                                          distance_matrix_3[segment[0], segment[-1]]) for i in range(3))\n            if inv_weight > 0.5:  # Higher weight means more likely to invert\n                segment.reverse()\n\n    # Perform constrained node exchange\n    if n > 3:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i-j) > 1:  # Ensure minimal disruption\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7268703057192845,
            0.3853242635726929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on weighted contributions\n    critical_segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted contribution\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Probabilistically extend or finalize segment\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            if len(current_segment) > 1:\n                critical_segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment and len(current_segment) > 1:\n        critical_segments.append(current_segment)\n\n    # Apply weighted inversion to critical segments\n    if critical_segments:\n        seg_idx = random.randint(0, len(critical_segments)-1)\n        segment = critical_segments[seg_idx]\n\n        if len(segment) > 2 and random.random() < 0.7:\n            # Weighted inversion decision\n            inv_weight = sum(weights[i] * (distance_matrix_1[segment[0], segment[-1]] +\n                                          distance_matrix_2[segment[0], segment[-1]] +\n                                          distance_matrix_3[segment[0], segment[-1]]) for i in range(3))\n            if inv_weight > 0.5:  # Higher weight means more likely to invert\n                segment.reverse()\n\n    # Perform constrained node exchange\n    if n > 3:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i-j) > 1:  # Ensure minimal disruption\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a hierarchical segment inversion and objective-aware edge swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hierarchical segment inversion\n    k = random.randint(2, min(5, n // 2))\n    segments = [new_solution[i:i+k] for i in range(0, n, k)]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware edge swapping\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7693586658272763,
            3.4712522625923157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hierarchical segment inversion\n    k = random.randint(2, min(5, n // 2))\n    segments = [new_solution[i:i+k] for i in range(0, n, k)]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware edge swapping\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial clustering, then generates a neighbor by performing a multi-objective-aware node insertion and segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]) - max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n-1)\n\n    # Calculate potential improvement\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n    ]\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment inversion\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.672525799508111,
            3.3915090680122377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]) - max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n-1)\n\n    # Calculate potential improvement\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n    ]\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment inversion\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and structural diversity, then generates a neighbor by performing a multi-objective-aware path inversion and segment insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform path inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Perform segment insertion\n    c, d = sorted(random.sample(range(n), 2))\n    segment = new_solution[c:d+1]\n    temp_solution = np.concatenate([\n        new_solution[:c], new_solution[d+1:], segment\n    ])\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n    ]\n\n    # Accept if any objective improves\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8293673389834069,
            3.7828216552734375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform path inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Perform segment insertion\n    c, d = sorted(random.sample(range(n), 2))\n    segment = new_solution[c:d+1]\n    temp_solution = np.concatenate([\n        new_solution[:c], new_solution[d+1:], segment\n    ])\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n        sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n    ]\n\n    # Accept if any objective improves\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{A novel multi-objective local search algorithm that selects solutions based on their potential for improvement in multiple objectives, applies a hybrid of 2-opt and adaptive edge swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt move: select two distinct positions and reverse the segment between them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive edge swaps based on objective improvement\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            # Swap edges if it doesn't create a cycle\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n            ]\n\n            # Revert swap if it doesn't improve at least one objective\n            if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6334564793441809,
            4.0905536890029905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt move: select two distinct positions and reverse the segment between them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive edge swaps based on objective improvement\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            # Swap edges if it doesn't create a cycle\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n                sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n            ]\n\n            # Revert swap if it doesn't improve at least one objective\n            if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This new algorithm employs a multi-objective path decomposition and adaptive node clustering strategy that dynamically partitions the tour into objective-specific clusters, evaluates their contributions across all objectives with adaptive weights, and performs cluster-wise node reallocation while ensuring feasibility through a novel path merging mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_cluster) < 4:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n\n        if random.random() < 0.5:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n        else:\n            clusters[i] = clusters[i] + clusters[j]\n            clusters.pop(j)\n\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.4 and len(cluster) > 2:\n            k = random.randint(1, len(cluster)-1)\n            cluster = cluster[k:] + cluster[:k]\n        new_solution.extend(cluster)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6699784656360736,
            0.5014641404151916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_cluster) < 4:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n\n        if random.random() < 0.5:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n        else:\n            clusters[i] = clusters[i] + clusters[j]\n            clusters.pop(j)\n\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.4 and len(cluster) > 2:\n            k = random.randint(1, len(cluster)-1)\n            cluster = cluster[k:] + cluster[:k]\n        new_solution.extend(cluster)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This new algorithm employs a multi-objective-aware node clustering and reassembly strategy that dynamically groups nodes based on their Pareto dominance across objectives, then reconstructs the tour by alternating between objective-specific local rearrangements and global cluster-based permutations, ensuring feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights\n    obj1, obj2, obj3 = objectives\n    total = obj1 + obj2 + obj3\n    w1, w2, w3 = obj1/total, obj2/total, obj3/total if total > 0 else (1/3, 1/3, 1/3)\n\n    # Cluster nodes based on objective dominance\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Calculate weighted dominance score\n        dominance = (w1*cost1 + w2*cost2 + w3*cost3) / (cost1 + cost2 + cost3 + 1e-8)\n\n        if random.random() < dominance and len(current_cluster) < 5:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reassemble tour with alternating objective-specific operations\n    new_solution = []\n    for i, cluster in enumerate(clusters):\n        if len(cluster) < 2:\n            new_solution.extend(cluster)\n            continue\n\n        # Choose operation based on objective weights\n        op = random.choices(\n            ['inversion', 'swap', 'rotation'],\n            weights=[w1, w2, w3],\n            k=1\n        )[0]\n\n        if op == 'inversion':\n            if len(cluster) > 2:\n                k = random.randint(1, len(cluster)-1)\n                cluster = cluster[:k] + cluster[k:][::-1]\n        elif op == 'swap':\n            if len(cluster) > 3:\n                a, b = sorted(random.sample(range(len(cluster)), 2))\n                cluster[a], cluster[b] = cluster[b], cluster[a]\n        elif op == 'rotation':\n            if len(cluster) > 3:\n                k = random.randint(1, len(cluster)-1)\n                cluster = cluster[k:] + cluster[:k]\n\n        new_solution.extend(cluster)\n\n    # Ensure circular permutation\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6673486834013759,
            0.6884529709815979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights\n    obj1, obj2, obj3 = objectives\n    total = obj1 + obj2 + obj3\n    w1, w2, w3 = obj1/total, obj2/total, obj3/total if total > 0 else (1/3, 1/3, 1/3)\n\n    # Cluster nodes based on objective dominance\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Calculate weighted dominance score\n        dominance = (w1*cost1 + w2*cost2 + w3*cost3) / (cost1 + cost2 + cost3 + 1e-8)\n\n        if random.random() < dominance and len(current_cluster) < 5:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reassemble tour with alternating objective-specific operations\n    new_solution = []\n    for i, cluster in enumerate(clusters):\n        if len(cluster) < 2:\n            new_solution.extend(cluster)\n            continue\n\n        # Choose operation based on objective weights\n        op = random.choices(\n            ['inversion', 'swap', 'rotation'],\n            weights=[w1, w2, w3],\n            k=1\n        )[0]\n\n        if op == 'inversion':\n            if len(cluster) > 2:\n                k = random.randint(1, len(cluster)-1)\n                cluster = cluster[:k] + cluster[k:][::-1]\n        elif op == 'swap':\n            if len(cluster) > 3:\n                a, b = sorted(random.sample(range(len(cluster)), 2))\n                cluster[a], cluster[b] = cluster[b], cluster[a]\n        elif op == 'rotation':\n            if len(cluster) > 3:\n                k = random.randint(1, len(cluster)-1)\n                cluster = cluster[k:] + cluster[:k]\n\n        new_solution.extend(cluster)\n\n    # Ensure circular permutation\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware segment inversion and adaptive node insertion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Multi-objective-aware segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive node insertion\n    if n >= 4 and random.random() < 0.3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6671147854468488,
            0.9585561275482177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Multi-objective-aware segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive node insertion\n    if n >= 4 and random.random() < 0.3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This novel algorithm employs an adaptive multi-objective edge-based local search with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their weighted contributions across all objectives, performs edge swaps or insertions while dynamically adjusting edge priorities based on their potential for multi-objective improvement, and ensures feasibility by maintaining a valid tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select critical edges based on multi-objective evaluation\n    def evaluate_edge(i, j):\n        cost1 = distance_matrix_1[i, j]\n        cost2 = distance_matrix_2[i, j]\n        cost3 = distance_matrix_3[i, j]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    # Find edges with highest and lowest contributions\n    edge_scores = []\n    for i in range(n-1):\n        edge_scores.append((evaluate_edge(new_solution[i], new_solution[i+1]), i))\n    edge_scores.append((evaluate_edge(new_solution[-1], new_solution[0]), n-1))\n\n    edge_scores.sort()\n    worst_edge_idx = edge_scores[-1][1]\n    best_edge_idx = edge_scores[0][1]\n\n    # Perform edge-based operation\n    if random.random() < 0.7:\n        # Edge swap\n        if worst_edge_idx < n-1:\n            new_solution[worst_edge_idx], new_solution[worst_edge_idx+1] = new_solution[worst_edge_idx+1], new_solution[worst_edge_idx]\n    else:\n        # Edge insertion\n        if worst_edge_idx < n-1 and best_edge_idx < n-1:\n            node = new_solution[worst_edge_idx+1]\n            new_solution = np.delete(new_solution, worst_edge_idx+1)\n            insert_pos = (best_edge_idx + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6478969080034865,
            0.7087547302246093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select critical edges based on multi-objective evaluation\n    def evaluate_edge(i, j):\n        cost1 = distance_matrix_1[i, j]\n        cost2 = distance_matrix_2[i, j]\n        cost3 = distance_matrix_3[i, j]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    # Find edges with highest and lowest contributions\n    edge_scores = []\n    for i in range(n-1):\n        edge_scores.append((evaluate_edge(new_solution[i], new_solution[i+1]), i))\n    edge_scores.append((evaluate_edge(new_solution[-1], new_solution[0]), n-1))\n\n    edge_scores.sort()\n    worst_edge_idx = edge_scores[-1][1]\n    best_edge_idx = edge_scores[0][1]\n\n    # Perform edge-based operation\n    if random.random() < 0.7:\n        # Edge swap\n        if worst_edge_idx < n-1:\n            new_solution[worst_edge_idx], new_solution[worst_edge_idx+1] = new_solution[worst_edge_idx+1], new_solution[worst_edge_idx]\n    else:\n        # Edge insertion\n        if worst_edge_idx < n-1 and best_edge_idx < n-1:\n            node = new_solution[worst_edge_idx+1]\n            new_solution = np.delete(new_solution, worst_edge_idx+1)\n            insert_pos = (best_edge_idx + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This new algorithm employs a multi-objective tour decomposition and adaptive segment reassembly strategy that dynamically partitions the solution into objective-aligned segments, evaluates their contributions using a Pareto front-based weighting mechanism, and performs segment-wise insertions and deletions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions for each edge\n    contributions = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        contributions.append((cost1, cost2, cost3))\n\n    # Identify segments to decompose\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n-1):\n        # Check if current edge's contributions are balanced\n        balanced = all(abs(contributions[i][j] - contributions[i-1][j]) < 0.1 * contributions[i-1][j] for j in range(3))\n        if balanced and len(current_segment) < 3:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reassemble segments with adaptive permutations\n    if len(segments) > 1:\n        # Select two segments to process\n        i, j = random.sample(range(len(segments)), 2)\n\n        # For the first segment, apply circular permutation\n        if len(segments[i]) > 2:\n            k = random.randint(1, len(segments[i])-1)\n            segments[i] = segments[i][k:] + segments[i][:k]\n\n        # For the second segment, apply random insertion\n        if len(segments[j]) > 1:\n            node = segments[j].pop(random.randint(0, len(segments[j])-1))\n            pos = random.randint(0, len(segments[i])-1)\n            segments[i].insert(pos, node)\n\n    # Rebuild the solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6446922249453857,
            0.9228218793869019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions for each edge\n    contributions = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        contributions.append((cost1, cost2, cost3))\n\n    # Identify segments to decompose\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n-1):\n        # Check if current edge's contributions are balanced\n        balanced = all(abs(contributions[i][j] - contributions[i-1][j]) < 0.1 * contributions[i-1][j] for j in range(3))\n        if balanced and len(current_segment) < 3:\n            current_segment.append(new_solution[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n    segments.append(current_segment)\n\n    # Reassemble segments with adaptive permutations\n    if len(segments) > 1:\n        # Select two segments to process\n        i, j = random.sample(range(len(segments)), 2)\n\n        # For the first segment, apply circular permutation\n        if len(segments[i]) > 2:\n            k = random.randint(1, len(segments[i])-1)\n            segments[i] = segments[i][k:] + segments[i][:k]\n\n        # For the second segment, apply random insertion\n        if len(segments[j]) > 1:\n            node = segments[j].pop(random.randint(0, len(segments[j])-1))\n            pos = random.randint(0, len(segments[i])-1)\n            segments[i].insert(pos, node)\n\n    # Rebuild the solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6664204793881756,
            0.5804527997970581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and spatial diversity, then generates a neighbor by performing a multi-segment inversion and objective-aware edge swaps, ensuring feasibility while potentially improving all three objectives through a balance of local and global search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n    segment = new_solution[c:d+1]\n    new_solution[c:d+1] = segment[::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost = (\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        )\n\n        if sum(new_cost) < sum(original_cost):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.650687313883427,
            3.9395790338516234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4 * x[1][0] + 0.3 * x[1][1] + 0.3 * x[1][2])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n    segment = new_solution[c:d+1]\n    new_solution[c:d+1] = segment[::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost = (\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        )\n\n        if sum(new_cost) < sum(original_cost):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional segment relocation with adaptive path rotation, ensuring feasibility while improving multiple objectives through targeted segment optimization and spatial alignment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Multi-dimensional segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(1, n - segment_length - 1)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    insert_pos = random.randint(1, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Adaptive path rotation\n    if random.random() < 0.5:\n        rotate_pos = random.randint(1, n - 1)\n        new_solution[1:rotate_pos] = np.roll(new_solution[1:rotate_pos], 1)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6665309232587828,
            1.3170862674713135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Multi-dimensional segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(1, n - segment_length - 1)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    insert_pos = random.randint(1, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Adaptive path rotation\n    if random.random() < 0.5:\n        rotate_pos = random.randint(1, n - 1)\n        new_solution[1:rotate_pos] = np.roll(new_solution[1:rotate_pos], 1)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm employs a hybrid objective-aware multi-segment exchange strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions with adaptive weights, and performs cross-objective segment exchanges while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]) / max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform cross-objective segment exchanges\n    if len(segments) > 1:\n        # Select segments based on objective weights\n        segment_weights = []\n        for seg in segments:\n            seg_cost = 0\n            for i in range(len(seg)-1):\n                prev_node = seg[i]\n                node = seg[i+1]\n                seg_cost += weights[0]*distance_matrix_1[prev_node, node] + \\\n                            weights[1]*distance_matrix_2[prev_node, node] + \\\n                            weights[2]*distance_matrix_3[prev_node, node]\n            segment_weights.append(seg_cost)\n\n        # Find segments with highest and lowest weighted costs\n        max_idx = segment_weights.index(max(segment_weights))\n        min_idx = segment_weights.index(min(segment_weights))\n\n        # Exchange segments if they belong to different objectives\n        if max_idx != min_idx:\n            segments[max_idx], segments[min_idx] = segments[min_idx], segments[max_idx]\n\n    # Rebuild solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6877815361456402,
            1.283745002746582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]) / max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition tour into segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform cross-objective segment exchanges\n    if len(segments) > 1:\n        # Select segments based on objective weights\n        segment_weights = []\n        for seg in segments:\n            seg_cost = 0\n            for i in range(len(seg)-1):\n                prev_node = seg[i]\n                node = seg[i+1]\n                seg_cost += weights[0]*distance_matrix_1[prev_node, node] + \\\n                            weights[1]*distance_matrix_2[prev_node, node] + \\\n                            weights[2]*distance_matrix_3[prev_node, node]\n            segment_weights.append(seg_cost)\n\n        # Find segments with highest and lowest weighted costs\n        max_idx = segment_weights.index(max(segment_weights))\n        min_idx = segment_weights.index(min(segment_weights))\n\n        # Exchange segments if they belong to different objectives\n        if max_idx != min_idx:\n            segments[max_idx], segments[min_idx] = segments[min_idx], segments[max_idx]\n\n    # Rebuild solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm employs a dynamic objective-weighted segment swapping strategy that identifies critical nodes based on their Pareto dominance in all three objectives, performs targeted segment inversions with adaptive probabilities, and ensures feasibility through a multi-objective circular permutation mechanism that prioritizes high-contribution nodes while maintaining tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    max_diff = -1\n    selected_idx = 0\n    for i in range(len(objectives)):\n        diff = max(objectives[i]) - min(objectives[i])\n        if diff > max_diff:\n            max_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate node contributions to each objective\n    contributions = [0] * n\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Normalize contributions\n        total = cost1 + cost2 + cost3\n        if total > 0:\n            contributions[i] = (cost1 + cost2 + cost3) / total\n        else:\n            contributions[i] = 1/3\n\n    # Identify critical segments based on high contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        if contributions[i] > 0.7 or random.random() < 0.3:\n            current_segment.append(new_solution[i])\n        else:\n            if len(current_segment) > 1:\n                segments.append(current_segment)\n            current_segment = [new_solution[i]]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment)\n\n    # Perform segment operations\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge with reverse\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    # Reconstruct solution\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            # Randomly shift segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7183179534785652,
            1.0497146129608155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    max_diff = -1\n    selected_idx = 0\n    for i in range(len(objectives)):\n        diff = max(objectives[i]) - min(objectives[i])\n        if diff > max_diff:\n            max_diff = diff\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate node contributions to each objective\n    contributions = [0] * n\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Normalize contributions\n        total = cost1 + cost2 + cost3\n        if total > 0:\n            contributions[i] = (cost1 + cost2 + cost3) / total\n        else:\n            contributions[i] = 1/3\n\n    # Identify critical segments based on high contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        if contributions[i] > 0.7 or random.random() < 0.3:\n            current_segment.append(new_solution[i])\n        else:\n            if len(current_segment) > 1:\n                segments.append(current_segment)\n            current_segment = [new_solution[i]]\n\n    if len(current_segment) > 1:\n        segments.append(current_segment)\n\n    # Perform segment operations\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge with reverse\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    # Reconstruct solution\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            # Randomly shift segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This new algorithm employs a multi-objective-aware tour partitioning and segment reordering strategy that dynamically balances segment contributions across all objectives, while intelligently selecting and reordering segments based on their combined objective improvements, ensuring feasibility and promoting diverse exploration through adaptive segment boundary adjustments and weighted segment swapping.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity in objectives\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    base_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Reorder segments based on their weighted costs\n    sorted_indices = sorted(range(3), key=lambda i: seg_costs[i])\n    segments = [seg1, seg2, seg3]\n    reordered_segments = [segments[i] for i in sorted_indices]\n\n    # Randomly decide whether to merge or split segments\n    if random.random() < 0.5:\n        # Merge segments with dynamic split point\n        merged = np.concatenate(reordered_segments)\n        split_point = random.randint(1, len(merged)-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n    else:\n        # Split and reorder segments\n        new_solution = np.concatenate(reordered_segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6850551652204382,
            0.8677618384361268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity in objectives\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    base_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Partition the tour into segments\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Reorder segments based on their weighted costs\n    sorted_indices = sorted(range(3), key=lambda i: seg_costs[i])\n    segments = [seg1, seg2, seg3]\n    reordered_segments = [segments[i] for i in sorted_indices]\n\n    # Randomly decide whether to merge or split segments\n    if random.random() < 0.5:\n        # Merge segments with dynamic split point\n        merged = np.concatenate(reordered_segments)\n        split_point = random.randint(1, len(merged)-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n    else:\n        # Split and reorder segments\n        new_solution = np.concatenate(reordered_segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware segment inversion and adaptive node relocation, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest diversity in objectives\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective-aware segment inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n\n    # Adaptive node relocation\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        if j > i:\n            new_solution = np.concatenate([temp_solution[:i+1], [temp_solution[j]], temp_solution[i+1:j], temp_solution[i:i+1], temp_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([temp_solution[:j], [temp_solution[i]], temp_solution[j:i], temp_solution[i+1:]])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7175297168971452,
            0.7678220391273498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest diversity in objectives\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective-aware segment inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n\n    # Adaptive node relocation\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        if j > i:\n            new_solution = np.concatenate([temp_solution[:i+1], [temp_solution[j]], temp_solution[i+1:j], temp_solution[i:i+1], temp_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([temp_solution[:j], [temp_solution[i]], temp_solution[j:i], temp_solution[i+1:]])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This new algorithm employs a multi-objective tour reconstruction approach that dynamically combines node clustering with adaptive objective-weighted path insertion, where it first partitions the solution into node clusters based on their spatial proximity across all objectives, then selectively reinserts nodes into the tour using a weighted insertion strategy that balances the improvement across all three objectives, while maintaining tour feasibility through a novel cluster-based path adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / (1 + max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate dynamic weights based on current objectives\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Cluster nodes based on multi-objective spatial proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined distance to current cluster\n        combined_dist = 0\n        for node in current_cluster:\n            combined_dist += (weights[0] * distance_matrix_1[node, new_solution[i]] +\n                             weights[1] * distance_matrix_2[node, new_solution[i]] +\n                             weights[2] * distance_matrix_3[node, new_solution[i]])\n\n        if combined_dist / len(current_cluster) < 1.2 * (weights[0] + weights[1] + weights[2]):\n            current_cluster.append(new_solution[i])\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based path reconstruction\n    if len(clusters) > 1:\n        # Select a cluster to modify\n        cluster_idx = random.randint(0, len(clusters)-1)\n        selected_cluster = clusters[cluster_idx]\n\n        # Remove the cluster from the tour\n        remaining_nodes = [node for node in new_solution if node not in selected_cluster]\n        remaining_nodes.append(remaining_nodes[0])  # Ensure circular\n\n        # Find best insertion point for cluster\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(remaining_nodes)-1):\n            # Calculate insertion cost\n            cost = (weights[0] * (distance_matrix_1[remaining_nodes[i], selected_cluster[0]] +\n                                 distance_matrix_1[selected_cluster[-1], remaining_nodes[i+1]]) +\n                    weights[1] * (distance_matrix_2[remaining_nodes[i], selected_cluster[0]] +\n                                 distance_matrix_2[selected_cluster[-1], remaining_nodes[i+1]]) +\n                    weights[2] * (distance_matrix_3[remaining_nodes[i], selected_cluster[0]] +\n                                 distance_matrix_3[selected_cluster[-1], remaining_nodes[i+1]]))\n\n            if cost < best_score:\n                best_score = cost\n                best_pos = i + 1\n\n        # Reinsert the cluster\n        new_solution = np.concatenate([\n            remaining_nodes[:best_pos],\n            np.array(selected_cluster),\n            remaining_nodes[best_pos:]\n        ])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7527411003187906,
            3.044942545890808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / (1 + max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate dynamic weights based on current objectives\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Cluster nodes based on multi-objective spatial proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined distance to current cluster\n        combined_dist = 0\n        for node in current_cluster:\n            combined_dist += (weights[0] * distance_matrix_1[node, new_solution[i]] +\n                             weights[1] * distance_matrix_2[node, new_solution[i]] +\n                             weights[2] * distance_matrix_3[node, new_solution[i]])\n\n        if combined_dist / len(current_cluster) < 1.2 * (weights[0] + weights[1] + weights[2]):\n            current_cluster.append(new_solution[i])\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based path reconstruction\n    if len(clusters) > 1:\n        # Select a cluster to modify\n        cluster_idx = random.randint(0, len(clusters)-1)\n        selected_cluster = clusters[cluster_idx]\n\n        # Remove the cluster from the tour\n        remaining_nodes = [node for node in new_solution if node not in selected_cluster]\n        remaining_nodes.append(remaining_nodes[0])  # Ensure circular\n\n        # Find best insertion point for cluster\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(remaining_nodes)-1):\n            # Calculate insertion cost\n            cost = (weights[0] * (distance_matrix_1[remaining_nodes[i], selected_cluster[0]] +\n                                 distance_matrix_1[selected_cluster[-1], remaining_nodes[i+1]]) +\n                    weights[1] * (distance_matrix_2[remaining_nodes[i], selected_cluster[0]] +\n                                 distance_matrix_2[selected_cluster[-1], remaining_nodes[i+1]]) +\n                    weights[2] * (distance_matrix_3[remaining_nodes[i], selected_cluster[0]] +\n                                 distance_matrix_3[selected_cluster[-1], remaining_nodes[i+1]]))\n\n            if cost < best_score:\n                best_score = cost\n                best_pos = i + 1\n\n        # Reinsert the cluster\n        new_solution = np.concatenate([\n            remaining_nodes[:best_pos],\n            np.array(selected_cluster),\n            remaining_nodes[best_pos:]\n        ])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This new algorithm employs a multi-objective tour fragmentation and reassembly strategy that adaptively decomposes the tour into segments based on node dominance in each objective space, performs segment-wise rotations and cross-segment merges with probability proportional to the node's contribution to each objective, and ensures feasibility through a hierarchical permutation mechanism that maintains tour continuity while optimizing for all three objectives with dynamically adjusted weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.5 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7357291819714009,
            0.38024125099182127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.5 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest combined objective value (sum of all three objectives) and generates a neighbor by performing a multi-dimensional segment relocation with adaptive segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment relocation\n    seg_start = random.randint(1, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+2, n-2))\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    insert_pos = random.randint(1, n-seg_end+seg_start-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive segment rotation\n    if random.random() < 0.5:\n        rotate_pos = random.randint(0, len(segment)-1)\n        segment = np.roll(segment, rotate_pos)\n        new_solution[insert_pos:insert_pos+len(segment)] = segment\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6556625121739135,
            0.4613214135169983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment relocation\n    seg_start = random.randint(1, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+2, n-2))\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    insert_pos = random.randint(1, n-seg_end+seg_start-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive segment rotation\n    if random.random() < 0.5:\n        rotate_pos = random.randint(0, len(segment)-1)\n        segment = np.roll(segment, rotate_pos)\n        new_solution[insert_pos:insert_pos+len(segment)] = segment\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This new algorithm selects a solution from the archive based on the most balanced objectives (smallest range between max and min objective values), then generates a neighbor by performing a multi-segment inversion and objective-aware edge swaps, ensuring feasibility while potentially improving all three objectives through a combination of local and global perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if sum(new_costs) < sum(original_costs):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7718942142219734,
            4.1276603698730465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if sum(new_costs) < sum(original_costs):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This new algorithm employs an adaptive multi-objective path inversion with dynamic objective-aware segment selection, where it identifies critical path segments based on their weighted contributions to all objectives, inverts selected segments with probability proportional to their improvement potential, and dynamically adjusts segment boundaries while ensuring feasibility through a novel path continuity maintenance mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    probabilities = np.linspace(0.1, 1.0, len(archive))\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current solution's performance\n    total = sum(objectives)\n    weights = [obj/total for obj in objectives] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical path segments based on weighted contributions\n    segment_length = max(2, n // 5)\n    segments = []\n    for i in range(0, n-1, segment_length):\n        segment = new_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segments.append((segment, weighted_cost))\n\n    # Sort segments by weighted cost (descending) to identify most critical segments\n    segments.sort(key=lambda x: -x[1])\n\n    # Select top segments for potential inversion with probability based on improvement potential\n    for i in range(min(3, len(segments))):\n        segment, cost = segments[i]\n        if random.random() < 0.5 * (1 - i/len(segments)):\n            # Invert the segment with probability proportional to its rank\n            start_idx = np.where(new_solution == segment[0])[0][0]\n            new_solution[start_idx:start_idx+len(segment)] = segment[::-1]\n\n    # Ensure the tour remains circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6846412592271278,
            1.3369918465614319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    probabilities = np.linspace(0.1, 1.0, len(archive))\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current solution's performance\n    total = sum(objectives)\n    weights = [obj/total for obj in objectives] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical path segments based on weighted contributions\n    segment_length = max(2, n // 5)\n    segments = []\n    for i in range(0, n-1, segment_length):\n        segment = new_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segments.append((segment, weighted_cost))\n\n    # Sort segments by weighted cost (descending) to identify most critical segments\n    segments.sort(key=lambda x: -x[1])\n\n    # Select top segments for potential inversion with probability based on improvement potential\n    for i in range(min(3, len(segments))):\n        segment, cost = segments[i]\n        if random.random() < 0.5 * (1 - i/len(segments)):\n            # Invert the segment with probability proportional to its rank\n            start_idx = np.where(new_solution == segment[0])[0][0]\n            new_solution[start_idx:start_idx+len(segment)] = segment[::-1]\n\n    # Ensure the tour remains circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This new algorithm uses adaptive objective-weighted segment partitioning with dynamic weight adjustment based on solution quality, followed by segment-wise 2-opt swaps and insertions while maintaining tour feasibility through a novel circular permutation mechanism that optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate adaptive weights based on solution quality\n    obj_values = objectives\n    max_obj = max(obj_values)\n    weights = [(max_obj - obj + 1e-6) / (sum(max_obj - obj + 1e-6 for obj in obj_values)) for obj in obj_values]\n\n    # Segment tour based on weighted edge costs\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 * (1 - weighted_cost / max_obj) and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment operations\n    if len(segments) > 1:\n        # Select segments with high potential for improvement\n        segment_scores = []\n        for seg in segments:\n            score = 0\n            for i in range(len(seg)-1):\n                node1, node2 = seg[i], seg[i+1]\n                cost1 = distance_matrix_1[node1, node2]\n                cost2 = distance_matrix_2[node1, node2]\n                cost3 = distance_matrix_3[node1, node2]\n                score += weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n            segment_scores.append(score)\n\n        # Select two segments with highest scores\n        sorted_indices = sorted(range(len(segment_scores)), key=lambda k: -segment_scores[k])\n        i, j = sorted_indices[0], sorted_indices[1] if len(sorted_indices) > 1 else sorted_indices[0]\n\n        if random.random() < 0.7:\n            # Perform 2-opt swap within segments\n            if len(segments[i]) > 2 and len(segments[j]) > 2:\n                pos_i = random.randint(1, len(segments[i])-2)\n                pos_j = random.randint(1, len(segments[j])-2)\n                segments[i][pos_i:pos_i+1], segments[j][pos_j:pos_j+1] = segments[j][pos_j:pos_j+1], segments[i][pos_i:pos_i+1]\n        else:\n            # Merge segments with high potential\n            if segment_scores[i] > segment_scores[j]:\n                segments[i] = segments[i] + segments[j]\n                segments.pop(j)\n\n    # Rebuild solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-2)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.705659302353856,
            0.5576050400733947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate adaptive weights based on solution quality\n    obj_values = objectives\n    max_obj = max(obj_values)\n    weights = [(max_obj - obj + 1e-6) / (sum(max_obj - obj + 1e-6 for obj in obj_values)) for obj in obj_values]\n\n    # Segment tour based on weighted edge costs\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 * (1 - weighted_cost / max_obj) and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment operations\n    if len(segments) > 1:\n        # Select segments with high potential for improvement\n        segment_scores = []\n        for seg in segments:\n            score = 0\n            for i in range(len(seg)-1):\n                node1, node2 = seg[i], seg[i+1]\n                cost1 = distance_matrix_1[node1, node2]\n                cost2 = distance_matrix_2[node1, node2]\n                cost3 = distance_matrix_3[node1, node2]\n                score += weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n            segment_scores.append(score)\n\n        # Select two segments with highest scores\n        sorted_indices = sorted(range(len(segment_scores)), key=lambda k: -segment_scores[k])\n        i, j = sorted_indices[0], sorted_indices[1] if len(sorted_indices) > 1 else sorted_indices[0]\n\n        if random.random() < 0.7:\n            # Perform 2-opt swap within segments\n            if len(segments[i]) > 2 and len(segments[j]) > 2:\n                pos_i = random.randint(1, len(segments[i])-2)\n                pos_j = random.randint(1, len(segments[j])-2)\n                segments[i][pos_i:pos_i+1], segments[j][pos_j:pos_j+1] = segments[j][pos_j:pos_j+1], segments[i][pos_i:pos_i+1]\n        else:\n            # Merge segments with high potential\n            if segment_scores[i] > segment_scores[j]:\n                segments[i] = segments[i] + segments[j]\n                segments.pop(j)\n\n    # Rebuild solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-2)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt swap and a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        new_solution = new_solution[::-1]\n    else:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6924837686469787,
            3.4643223881721497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        new_solution = new_solution[::-1]\n    else:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based local search that dynamically partitions the tour into segments based on node dominance in each objective space, applies segment inversions and cross-segment relocations with probability proportional to the node's relative contribution, and maintains feasibility through a circular permutation mechanism that ensures tour continuity while optimizing for all three objectives with adaptive weights and segment merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.5 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            if len(segments[i]) > 1 and len(segments[j]) > 1:\n                k = random.randint(1, min(len(segments[i])-1, len(segments[j])-1))\n                segments[i] = segments[i][:-k] + segments[j][:k]\n                segments[j] = segments[j][k:] + segments[i][-k:]\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6592690981864249,
            0.5749717116355896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.5 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            if len(segments[i]) > 1 and len(segments[j]) > 1:\n                k = random.randint(1, min(len(segments[i])-1, len(segments[j])-1))\n                segments[i] = segments[i][:-k] + segments[j][:k]\n                segments[j] = segments[j][k:] + segments[i][-k:]\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial proximity, then generates a neighbor by performing a multi-dimensional crossover with adaptive segment relocation, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional crossover with segment relocation\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment = new_solution[a:b+1]\n\n    # Adaptive segment relocation\n    if random.random() < 0.5:\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        # Remove duplicates (keep first occurrence)\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n    else:\n        # Replace segment with random nodes from instance\n        random_nodes = np.random.choice(instance[:, 0], size=len(segment), replace=False)\n        new_solution[a:b+1] = random_nodes\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7144451936815791,
            1.4185460805892944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional crossover with segment relocation\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment = new_solution[a:b+1]\n\n    # Adaptive segment relocation\n    if random.random() < 0.5:\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        # Remove duplicates (keep first occurrence)\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n    else:\n        # Replace segment with random nodes from instance\n        random_nodes = np.random.choice(instance[:, 0], size=len(segment), replace=False)\n        new_solution[a:b+1] = random_nodes\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6221988494618811,
            0.9043153524398804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based mutation with dynamic objective-aware segment inversion, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs segment inversion with random segment boundaries while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    seg_start = random.randint(1, n-2)\n    seg_end = random.randint(seg_start+1, n-1)\n\n    # Extract segment and invert it\n    segment = new_solution[seg_start:seg_end]\n    inverted_segment = segment[::-1]\n    new_solution[seg_start:seg_end] = inverted_segment\n\n    # Evaluate the inverted segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    inverted_cost = evaluate_segment(inverted_segment)\n    original_cost = evaluate_segment(segment)\n\n    # Accept inversion if it improves the weighted cost\n    if inverted_cost > original_cost:\n        new_solution[seg_start:seg_end] = segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.673961414935201,
            0.5743013978004455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    seg_start = random.randint(1, n-2)\n    seg_end = random.randint(seg_start+1, n-1)\n\n    # Extract segment and invert it\n    segment = new_solution[seg_start:seg_end]\n    inverted_segment = segment[::-1]\n    new_solution[seg_start:seg_end] = inverted_segment\n\n    # Evaluate the inverted segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    inverted_cost = evaluate_segment(inverted_segment)\n    original_cost = evaluate_segment(segment)\n\n    # Accept inversion if it improves the weighted cost\n    if inverted_cost > original_cost:\n        new_solution[seg_start:seg_end] = segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This new algorithm employs a multi-objective tour decomposition and reintegration strategy that dynamically partitions the solution into objective-specific sub-tours, evaluates their contributions across all objectives with adaptive weights, and performs sub-tour exchanges with circular permutation while ensuring feasibility through a novel connectivity validation mechanism that maintains tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Decompose tour into sub-tours based on objective contributions\n    sub_tours = []\n    current_sub_tour = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current sub-tour or start a new one\n        if random.random() < 0.6 and len(current_sub_tour) < 4:\n            current_sub_tour.append(node)\n        else:\n            sub_tours.append(current_sub_tour)\n            current_sub_tour = [node]\n\n    if current_sub_tour:\n        sub_tours.append(current_sub_tour)\n\n    # Perform sub-tour exchanges\n    if len(sub_tours) > 1:\n        # Randomly select two sub-tours to exchange\n        i, j = random.sample(range(len(sub_tours)), 2)\n        sub_tours[i], sub_tours[j] = sub_tours[j], sub_tours[i]\n\n        # Apply circular permutation to each sub-tour\n        for k in range(len(sub_tours)):\n            if len(sub_tours[k]) > 2 and random.random() < 0.4:\n                m = random.randint(1, len(sub_tours[k])-1)\n                sub_tours[k] = sub_tours[k][m:] + sub_tours[k][:m]\n\n    # Rebuild the solution\n    new_solution = []\n    for sub_tour in sub_tours:\n        new_solution.extend(sub_tour)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6962526170733246,
            1.2532020449638366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Decompose tour into sub-tours based on objective contributions\n    sub_tours = []\n    current_sub_tour = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current sub-tour or start a new one\n        if random.random() < 0.6 and len(current_sub_tour) < 4:\n            current_sub_tour.append(node)\n        else:\n            sub_tours.append(current_sub_tour)\n            current_sub_tour = [node]\n\n    if current_sub_tour:\n        sub_tours.append(current_sub_tour)\n\n    # Perform sub-tour exchanges\n    if len(sub_tours) > 1:\n        # Randomly select two sub-tours to exchange\n        i, j = random.sample(range(len(sub_tours)), 2)\n        sub_tours[i], sub_tours[j] = sub_tours[j], sub_tours[i]\n\n        # Apply circular permutation to each sub-tour\n        for k in range(len(sub_tours)):\n            if len(sub_tours[k]) > 2 and random.random() < 0.4:\n                m = random.randint(1, len(sub_tours[k])-1)\n                sub_tours[k] = sub_tours[k][m:] + sub_tours[k][:m]\n\n    # Rebuild the solution\n    new_solution = []\n    for sub_tour in sub_tours:\n        new_solution.extend(sub_tour)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This new algorithm employs a multi-objective guided edge insertion and removal strategy that dynamically selects critical edges based on their combined contribution to all three objectives, then performs a series of edge swaps and insertions while maintaining feasibility through a novel path relinking mechanism that preserves solution structure while exploring the Pareto frontier.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Identify critical edges based on multi-objective contribution\n    critical_edges = []\n    for i in range(n):\n        node1 = new_solution[i]\n        node2 = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        combined_cost = (cost1 + cost2 + cost3) / 3\n        critical_edges.append((i, combined_cost))\n\n    # Sort edges by importance\n    critical_edges.sort(key=lambda x: x[1], reverse=True)\n\n    # Perform edge swaps or insertions\n    for _ in range(2):\n        if len(critical_edges) < 2:\n            break\n\n        # Select two edges to operate on\n        edge1, edge2 = random.sample(critical_edges[:3], 2)\n        i1, _ = edge1\n        i2, _ = edge2\n\n        if random.random() < 0.5:\n            # Edge swap\n            new_solution[i1], new_solution[(i1+1)%n] = new_solution[(i1+1)%n], new_solution[i1]\n            new_solution[i2], new_solution[(i2+1)%n] = new_solution[(i2+1)%n], new_solution[i2]\n        else:\n            # Edge insertion\n            node = new_solution[i1]\n            new_solution = np.delete(new_solution, i1)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6963784795401133,
            1.0359257698059081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Identify critical edges based on multi-objective contribution\n    critical_edges = []\n    for i in range(n):\n        node1 = new_solution[i]\n        node2 = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        combined_cost = (cost1 + cost2 + cost3) / 3\n        critical_edges.append((i, combined_cost))\n\n    # Sort edges by importance\n    critical_edges.sort(key=lambda x: x[1], reverse=True)\n\n    # Perform edge swaps or insertions\n    for _ in range(2):\n        if len(critical_edges) < 2:\n            break\n\n        # Select two edges to operate on\n        edge1, edge2 = random.sample(critical_edges[:3], 2)\n        i1, _ = edge1\n        i2, _ = edge2\n\n        if random.random() < 0.5:\n            # Edge swap\n            new_solution[i1], new_solution[(i1+1)%n] = new_solution[(i1+1)%n], new_solution[i1]\n            new_solution[i2], new_solution[(i2+1)%n] = new_solution[(i2+1)%n], new_solution[i2]\n        else:\n            # Edge insertion\n            node = new_solution[i1]\n            new_solution = np.delete(new_solution, i1)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7075549709657016,
            0.9176246643066406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm employs a multi-objective node reinsertion strategy that dynamically selects critical nodes based on their Pareto dominance in all three objective spaces, performs segment-wise reinsertions with adaptive depth proportional to node contribution, and uses a hybrid of inversion and rotation moves to explore diverse neighborhoods while maintaining tour feasibility through a circular permutation framework.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:max(3, len(archive)//3)]\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Identify critical nodes based on Pareto dominance\n    critical_nodes = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Node is critical if it's not Pareto-optimal in all objectives\n        if (cost1 > distance_matrix_1[prev_node, next_node] or\n            cost2 > distance_matrix_2[prev_node, next_node] or\n            cost3 > distance_matrix_3[prev_node, next_node]):\n            critical_nodes.append(i)\n\n    if not critical_nodes:\n        return new_solution\n\n    # Perform segment-wise reinsertion\n    k = random.choice(critical_nodes)\n    segment_length = min(3, n - k - 1)\n    segment = new_solution[k:k+segment_length+1]\n\n    # Remove segment and reinsert at a new position\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+segment_length+1:]])\n    new_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Apply adaptive move based on segment characteristics\n    if random.random() < 0.6:\n        # Inversion move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Rotation move\n        k = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[-k:], new_solution[:-k]])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7039575515697072,
            1.652874517440796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:max(3, len(archive)//3)]\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Identify critical nodes based on Pareto dominance\n    critical_nodes = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Node is critical if it's not Pareto-optimal in all objectives\n        if (cost1 > distance_matrix_1[prev_node, next_node] or\n            cost2 > distance_matrix_2[prev_node, next_node] or\n            cost3 > distance_matrix_3[prev_node, next_node]):\n            critical_nodes.append(i)\n\n    if not critical_nodes:\n        return new_solution\n\n    # Perform segment-wise reinsertion\n    k = random.choice(critical_nodes)\n    segment_length = min(3, n - k - 1)\n    segment = new_solution[k:k+segment_length+1]\n\n    # Remove segment and reinsert at a new position\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+segment_length+1:]])\n    new_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Apply adaptive move based on segment characteristics\n    if random.random() < 0.6:\n        # Inversion move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Rotation move\n        k = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[-k:], new_solution[:-k]])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment fusion strategy that dynamically combines segments based on node dominance in each objective space, performs segment-wise 2-opt moves with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            a, b = sorted(random.sample(range(len(seg)), 2))\n            seg = seg[:a] + seg[a:b][::-1] + seg[b:]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7266173447417088,
            0.6715864181518555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            a, b = sorted(random.sample(range(len(seg)), 2))\n            seg = seg[:a] + seg[a:b][::-1] + seg[b:]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm employs a dynamic multi-objective path decomposition that adaptively partitions the tour into objective-aligned segments, evaluates their contributions with context-aware weights, and performs segment-wise 2-opt and insertion moves while maintaining feasibility through a circular permutation mechanism that ensures continuity across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.4:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6926154221851836,
            0.7053276896476746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.4:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment merging strategy that dynamically combines segments based on node dominance in each objective space, performs segment-wise cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7216868146933549,
            0.6523285865783691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges across objectives, evaluates their contributions with dynamically adjusted weights, and performs crossover by swapping edges while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    def edge_score(i):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    edge_scores = [edge_score(i) for i in range(n)]\n    worst_edge = max(range(n), key=lambda i: edge_scores[i])\n\n    # Perform edge-based crossover\n    if random.random() < 0.5:\n        # Swap nodes in the worst edge\n        i = worst_edge\n        j = (i + random.randint(2, n-2)) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Reverse a segment around the worst edge\n        i = worst_edge\n        j = (i + random.randint(2, n-2)) % n\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7185341441844859,
            0.5937447905540466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    def edge_score(i):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    edge_scores = [edge_score(i) for i in range(n)]\n    worst_edge = max(range(n), key=lambda i: edge_scores[i])\n\n    # Perform edge-based crossover\n    if random.random() < 0.5:\n        # Swap nodes in the worst edge\n        i = worst_edge\n        j = (i + random.randint(2, n-2)) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Reverse a segment around the worst edge\n        i = worst_edge\n        j = (i + random.randint(2, n-2)) % n\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This new algorithm employs a hybrid multi-objective adaptive path relinking with dynamic objective-aware node selection, where it dynamically selects nodes based on their contributions across all objectives with adaptive weights, performs path relinking between selected nodes while dynamically adjusting the relinking paths based on weighted improvements, and applies a novel circular permutation mechanism to ensure feasibility and promote exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify nodes with high potential for improvement\n    improvement_nodes = []\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # If the current edge is above average, consider it for improvement\n        if weighted_cost > (sum(obj_values) / (n-1)):\n            improvement_nodes.append(i)\n\n    if not improvement_nodes:\n        improvement_nodes = list(range(1, n))\n\n    # Select two nodes for path relinking\n    i, j = random.sample(improvement_nodes, 2)\n    if i > j:\n        i, j = j, i\n\n    # Perform path relinking between selected nodes\n    relink_path = []\n    for k in range(i, j+1):\n        node = new_solution[k]\n        relink_path.append(node)\n\n    # Reverse the path with a certain probability\n    if random.random() < 0.5:\n        relink_path = relink_path[::-1]\n\n    # Apply circular permutation to the relink path\n    if len(relink_path) > 2:\n        k = random.randint(1, len(relink_path)-1)\n        relink_path = relink_path[k:] + relink_path[:k]\n\n    # Rebuild the solution\n    new_solution = np.concatenate([new_solution[:i], relink_path, new_solution[j+1:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6575538622384214,
            0.6211246609687805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify nodes with high potential for improvement\n    improvement_nodes = []\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # If the current edge is above average, consider it for improvement\n        if weighted_cost > (sum(obj_values) / (n-1)):\n            improvement_nodes.append(i)\n\n    if not improvement_nodes:\n        improvement_nodes = list(range(1, n))\n\n    # Select two nodes for path relinking\n    i, j = random.sample(improvement_nodes, 2)\n    if i > j:\n        i, j = j, i\n\n    # Perform path relinking between selected nodes\n    relink_path = []\n    for k in range(i, j+1):\n        node = new_solution[k]\n        relink_path.append(node)\n\n    # Reverse the path with a certain probability\n    if random.random() < 0.5:\n        relink_path = relink_path[::-1]\n\n    # Apply circular permutation to the relink path\n    if len(relink_path) > 2:\n        k = random.randint(1, len(relink_path)-1)\n        relink_path = relink_path[k:] + relink_path[:k]\n\n    # Rebuild the solution\n    new_solution = np.concatenate([new_solution[:i], relink_path, new_solution[j+1:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional segment crossover with adaptive node insertion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment crossover\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[a:b+1]\n\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    segment2 = new_solution[c:d+1]\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2[::-1], new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:c], segment1[::-1], new_solution[d+1:]])\n\n    # Remove duplicates and ensure all nodes are included\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(selected_solution, unique_nodes)\n    for node in missing_nodes:\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6821384938263988,
            1.954176163673401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional segment crossover\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[a:b+1]\n\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    segment2 = new_solution[c:d+1]\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2[::-1], new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:c], segment1[::-1], new_solution[d+1:]])\n\n    # Remove duplicates and ensure all nodes are included\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(selected_solution, unique_nodes)\n    for node in missing_nodes:\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node-swapping strategy that dynamically identifies critical nodes based on their weighted contributions to each objective, performs targeted swaps between nodes from different segments with probabilities proportional to their relative dominance in each objective space, and ensures feasibility through a circular permutation mechanism while dynamically adjusting weights based on the current solution's performance across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    node_scores = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        score = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n        node_scores.append(score)\n\n    if not node_scores:\n        return new_solution\n\n    threshold = np.percentile(node_scores, 70)\n    critical_nodes = [i for i, score in enumerate(node_scores) if score > threshold]\n\n    if len(critical_nodes) >= 2:\n        i, j = random.sample(critical_nodes, 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.5 and len(new_solution) > 4:\n        k = random.randint(1, len(new_solution)-2)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k:][::-1]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7328106651419282,
            2.256752669811249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    node_scores = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        score = weights[0] * cost1 + weights[1] * cost2 + weights[2] * cost3\n        node_scores.append(score)\n\n    if not node_scores:\n        return new_solution\n\n    threshold = np.percentile(node_scores, 70)\n    critical_nodes = [i for i, score in enumerate(node_scores) if score > threshold]\n\n    if len(critical_nodes) >= 2:\n        i, j = random.sample(critical_nodes, 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.5 and len(new_solution) > 4:\n        k = random.randint(1, len(new_solution)-2)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k:][::-1]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial clustering, then generates a neighbor by performing a multi-objective 2-opt with adaptive segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (sum(x[1]) / len(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Adaptive segment rotation\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        rotation = random.randint(1, n-2)\n        new_solution[k:] = np.roll(new_solution[k:], rotation)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6947784889316395,
            1.0746177196502686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (sum(x[1]) / len(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Adaptive segment rotation\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        rotation = random.randint(1, n-2)\n        new_solution[k:] = np.roll(new_solution[k:], rotation)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This algorithm employs a dynamic objective-aware edge reversal strategy that adaptively selects and reverses segments of the tour based on their relative contribution to each objective, while maintaining feasibility through circular permutation checks and ensuring diversity through probabilistic segment selection and inversion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_length = max(2, n // 5)\n    segment_starts = list(range(0, n, segment_length))\n\n    for start in segment_starts:\n        end = start + segment_length\n        if end > n:\n            end = n\n\n        segment = new_solution[start:end]\n\n        if len(segment) < 2:\n            continue\n\n        node_costs = []\n        for i in range(len(segment)):\n            node = segment[i]\n            prev_node = segment[i-1] if i > 0 else new_solution[start-1]\n            next_node = segment[i+1] if i < len(segment)-1 else new_solution[end % n]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n            weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n            node_costs.append(weighted_cost)\n\n        if random.random() < 0.5:\n            segment = segment[::-1]\n            new_solution[start:end] = segment\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7124689946151953,
            0.6156137347221374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_length = max(2, n // 5)\n    segment_starts = list(range(0, n, segment_length))\n\n    for start in segment_starts:\n        end = start + segment_length\n        if end > n:\n            end = n\n\n        segment = new_solution[start:end]\n\n        if len(segment) < 2:\n            continue\n\n        node_costs = []\n        for i in range(len(segment)):\n            node = segment[i]\n            prev_node = segment[i-1] if i > 0 else new_solution[start-1]\n            next_node = segment[i+1] if i < len(segment)-1 else new_solution[end % n]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n            weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n            node_costs.append(weighted_cost)\n\n        if random.random() < 0.5:\n            segment = segment[::-1]\n            new_solution[start:end] = segment\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This new algorithm employs a dynamic objective-aware segment-based mutation with adaptive segment recombination, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs segment-based mutations while dynamically adjusting segment boundaries to ensure feasibility and promote diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for mutation\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based mutation\n    if random.random() < 0.5:\n        # Reverse the worst segment\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    else:\n        # Shuffle the worst segment\n        segments = [seg1, seg2, seg3]\n        np.random.shuffle(segments[worst_seg_idx])\n\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6879082785874815,
            0.6948436021804809
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for mutation\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based mutation\n    if random.random() < 0.5:\n        # Reverse the worst segment\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n    else:\n        # Shuffle the worst segment\n        segments = [seg1, seg2, seg3]\n        np.random.shuffle(segments[worst_seg_idx])\n\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial centrality, then generates a neighbor by performing a multi-dimensional node insertion with adaptive segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / (sum(x[1]) + 1e-6))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion with segment rotation\n    i = random.randint(1, n-2)\n    j = random.randint(1, n-2)\n    while abs(i - j) < 2:\n        j = random.randint(1, n-2)\n\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    insert_pos = random.randint(1, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6267440923152676,
            1.3094947695732118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / (sum(x[1]) + 1e-6))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node insertion with segment rotation\n    i = random.randint(1, n-2)\n    j = random.randint(1, n-2)\n    while abs(i - j) < 2:\n        j = random.randint(1, n-2)\n\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    insert_pos = random.randint(1, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt exchange and a segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-objective-aware 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        return new_solution\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment reversal\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5630047749542322,
            3.707544982433319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-objective-aware 2-opt exchange\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        return new_solution\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment reversal\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective ranking, then generates a neighbor by performing a multi-objective-aware segment relocation and adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objective_ranges = [max(obj[i] for _, obj in archive) - min(obj[i] for _, obj in archive) for i in range(3)]\n    weights = [1/r if r > 0 else 1 for r in objective_ranges]\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment relocation\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Perform adaptive segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7228858224460082,
            4.222348248958587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objective_ranges = [max(obj[i] for _, obj in archive) - min(obj[i] for _, obj in archive) for i in range(3)]\n    weights = [1/r if r > 0 else 1 for r in objective_ranges]\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment relocation\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Perform adaptive segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then generates a neighbor by performing a multi-segment inversion and objective-aware edge swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge swapping\n    for _ in range(5):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5446248086432213,
            3.646259832382202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge swapping\n    for _ in range(5):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight adjustment mechanism that prioritizes objectives with higher variance in the archive, then generates a neighbor by performing a multi-objective-aware 3-opt move followed by a crossover-inspired segment replacement, ensuring feasibility while balancing exploration and exploitation across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else [1/3, 1/3, 1/3]\n\n    # Select solution with weighted objective scores\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Perform crossover-inspired segment replacement\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 4, n - 1))\n        donor_idx = random.randint(0, len(archive) - 1)\n        donor_segment = archive[donor_idx][0][start:end+1]\n        new_solution[start:end+1] = donor_segment\n\n    return new_solution\n\n",
        "score": [
            -0.5421509178798909,
            1.6871399760246277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else [1/3, 1/3, 1/3]\n\n    # Select solution with weighted objective scores\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Perform crossover-inspired segment replacement\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 4, n - 1))\n        donor_idx = random.randint(0, len(archive) - 1)\n        donor_segment = archive[donor_idx][0][start:end+1]\n        new_solution[start:end+1] = donor_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover by replacing entire segments bounded by critical edges while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    def evaluate_edge(u, v):\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    critical_edges = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        edge_score = evaluate_edge(u, v)\n        if edge_score > 0.7 * sum(evaluate_edge(new_solution[j], new_solution[j+1]) for j in range(n-1)) / (n-1):\n            critical_edges.append(i)\n\n    if not critical_edges:\n        critical_edges = [random.randint(0, n-2)]\n\n    selected_edge = random.choice(critical_edges)\n    segment_start = selected_edge\n    segment_end = (segment_start + random.randint(1, min(5, n-1-segment_start))) % n\n\n    if segment_end <= segment_start:\n        segment_end = n - 1\n\n    segment = new_solution[segment_start:segment_end+1]\n    reversed_segment = segment[::-1]\n\n    new_solution[segment_start:segment_end+1] = reversed_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6705442499700174,
            4.169405162334442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    def evaluate_edge(u, v):\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    critical_edges = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        edge_score = evaluate_edge(u, v)\n        if edge_score > 0.7 * sum(evaluate_edge(new_solution[j], new_solution[j+1]) for j in range(n-1)) / (n-1):\n            critical_edges.append(i)\n\n    if not critical_edges:\n        critical_edges = [random.randint(0, n-2)]\n\n    selected_edge = random.choice(critical_edges)\n    segment_start = selected_edge\n    segment_end = (segment_start + random.randint(1, min(5, n-1-segment_start))) % n\n\n    if segment_end <= segment_start:\n        segment_end = n - 1\n\n    segment = new_solution[segment_start:segment_end+1]\n    reversed_segment = segment[::-1]\n\n    new_solution[segment_start:segment_end+1] = reversed_segment\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware multi-objective ranking, then generates a neighbor by performing a hybrid 3-objective-aware 2-opt and 3-opt move, ensuring feasibility while balancing exploitation of objective trade-offs and exploration of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        n_obj = len(solutions[0][1])\n        distances = [0] * len(solutions)\n        for m in range(n_obj):\n            sorted_solutions = sorted(solutions, key=lambda x: x[1][m])\n            min_val = sorted_solutions[0][1][m]\n            max_val = sorted_solutions[-1][1][m]\n            if max_val == min_val:\n                continue\n            distances[0] += float('inf')\n            distances[-1] += float('inf')\n            for i in range(1, len(solutions)-1):\n                distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m]) / (max_val - min_val)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 3-objective-aware 2-opt and 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        # 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n        new_solution = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.713266660168025,
            3.333380174636841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        n_obj = len(solutions[0][1])\n        distances = [0] * len(solutions)\n        for m in range(n_obj):\n            sorted_solutions = sorted(solutions, key=lambda x: x[1][m])\n            min_val = sorted_solutions[0][1][m]\n            max_val = sorted_solutions[-1][1][m]\n            if max_val == min_val:\n                continue\n            distances[0] += float('inf')\n            distances[-1] += float('inf')\n            for i in range(1, len(solutions)-1):\n                distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m]) / (max_val - min_val)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 3-objective-aware 2-opt and 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        # 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n        new_solution = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This new algorithm employs a multi-objective tour decomposition and adaptive node reinsertion strategy that dynamically partitions the solution into objective-specific clusters, performs cluster-wise node reinsertions with probability proportional to their Pareto dominance, and ensures feasibility through a novel circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with dynamically adjusted weights based on cluster performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cluster nodes based on objective dominance\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate dominance in each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Determine if node is Pareto-dominant in any objective\n        is_dominant = (cost1 <= min(cost2, cost3) or\n                       cost2 <= min(cost1, cost3) or\n                       cost3 <= min(cost1, cost2))\n\n        if is_dominant and len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Perform cluster-wise operations\n    if len(clusters) > 1:\n        # Randomly select a cluster to modify\n        cluster_idx = random.randint(0, len(clusters)-1)\n        cluster = clusters[cluster_idx]\n\n        if len(cluster) > 2:\n            # Remove the cluster and reinsert nodes in different positions\n            removed_cluster = cluster.copy()\n            clusters.pop(cluster_idx)\n\n            # Flatten the remaining clusters\n            remaining_nodes = [node for c in clusters for node in c]\n\n            # Insert nodes back in different positions\n            for node in removed_cluster:\n                pos = random.randint(0, len(remaining_nodes))\n                remaining_nodes.insert(pos, node)\n\n            # Rebuild the solution\n            new_solution = remaining_nodes.copy()\n        else:\n            # Swap two clusters if they exist\n            if len(clusters) > 1:\n                i, j = random.sample(range(len(clusters)), 2)\n                clusters[i], clusters[j] = clusters[j], clusters[i]\n                new_solution = [node for c in clusters for node in c]\n\n    # Apply circular permutation to ensure tour continuity\n    if len(new_solution) > 2:\n        k = random.randint(1, len(new_solution)-1)\n        new_solution = new_solution[k:] + new_solution[:k]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6120972380530009,
            0.7096645832061768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cluster nodes based on objective dominance\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate dominance in each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Determine if node is Pareto-dominant in any objective\n        is_dominant = (cost1 <= min(cost2, cost3) or\n                       cost2 <= min(cost1, cost3) or\n                       cost3 <= min(cost1, cost2))\n\n        if is_dominant and len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Perform cluster-wise operations\n    if len(clusters) > 1:\n        # Randomly select a cluster to modify\n        cluster_idx = random.randint(0, len(clusters)-1)\n        cluster = clusters[cluster_idx]\n\n        if len(cluster) > 2:\n            # Remove the cluster and reinsert nodes in different positions\n            removed_cluster = cluster.copy()\n            clusters.pop(cluster_idx)\n\n            # Flatten the remaining clusters\n            remaining_nodes = [node for c in clusters for node in c]\n\n            # Insert nodes back in different positions\n            for node in removed_cluster:\n                pos = random.randint(0, len(remaining_nodes))\n                remaining_nodes.insert(pos, node)\n\n            # Rebuild the solution\n            new_solution = remaining_nodes.copy()\n        else:\n            # Swap two clusters if they exist\n            if len(clusters) > 1:\n                i, j = random.sample(range(len(clusters)), 2)\n                clusters[i], clusters[j] = clusters[j], clusters[i]\n                new_solution = [node for c in clusters for node in c]\n\n    # Apply circular permutation to ensure tour continuity\n    if len(new_solution) > 2:\n        k = random.randint(1, len(new_solution)-1)\n        new_solution = new_solution[k:] + new_solution[:k]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap with objective-aware selection\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Adaptive path inversion based on spatial centrality\n    if random.random() < 0.5:\n        # Calculate centrality in all three objective spaces\n        centrality = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            centrality[k] = (distance_matrix_1[node].mean() +\n                            distance_matrix_2[node].mean() +\n                            distance_matrix_3[node].mean())\n\n        # Select inversion segment around most central node\n        center_node = np.argmax(centrality)\n        segment_size = min(3, n-2)\n        a = max(1, center_node - segment_size//2)\n        b = min(n-2, center_node + segment_size//2)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6456465873923695,
            2.4620681405067444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap with objective-aware selection\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Adaptive path inversion based on spatial centrality\n    if random.random() < 0.5:\n        # Calculate centrality in all three objective spaces\n        centrality = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            centrality[k] = (distance_matrix_1[node].mean() +\n                            distance_matrix_2[node].mean() +\n                            distance_matrix_3[node].mean())\n\n        # Select inversion segment around most central node\n        center_node = np.argmax(centrality)\n        segment_size = min(3, n-2)\n        a = max(1, center_node - segment_size//2)\n        b = min(n-2, center_node + segment_size//2)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This new algorithm employs a multi-objective-aware adaptive segment merging and splitting strategy that dynamically partitions the tour into variable-length segments based on objective-specific improvements, then performs intelligent segment merging and reinsertion while maintaining feasibility through a novel reordering mechanism that ensures all objectives are improved through a balanced exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate improvement potential based on objective values\n        potential = sum(obj) / (len(sol) ** 0.5)  # Normalize by tour length\n        potential_scores.append(potential)\n    selected_idx = np.argmax(potential_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment partitioning based on objective improvements\n    segment_lengths = []\n    for i in range(n-1):\n        node_a = new_solution[i]\n        node_b = new_solution[i+1]\n        # Calculate improvement potential for each edge in all objectives\n        imp1 = distance_matrix_1[node_a, node_b]\n        imp2 = distance_matrix_2[node_a, node_b]\n        imp3 = distance_matrix_3[node_a, node_b]\n        segment_lengths.append(max(imp1, imp2, imp3))\n\n    # Create segments based on cumulative improvement potential\n    cumulative = np.cumsum(segment_lengths)\n    total = cumulative[-1]\n    split_points = [0]\n    for p in np.linspace(0, total, num=4)[1:-1]:  # 3 segments\n        idx = np.searchsorted(cumulative, p)\n        split_points.append(idx + 1)\n    split_points.append(n)\n\n    # Extract segments\n    segments = []\n    for i in range(len(split_points)-1):\n        segments.append(new_solution[split_points[i]:split_points[i+1]])\n\n    # Adaptive segment merging and reinsertion\n    if len(segments) > 1:\n        # Merge two random segments\n        merge_idx = random.randint(0, len(segments)-2)\n        merged = np.concatenate([segments[merge_idx], segments[merge_idx+1]])\n        del segments[merge_idx+1]\n        segments[merge_idx] = merged\n\n    # Reinsert merged segment at optimal position\n    if len(segments) > 1:\n        # Evaluate insertion positions\n        best_pos = 0\n        best_improvement = float('inf')\n        for i in range(len(segments)):\n            # Create candidate solution\n            candidate = np.concatenate([s for j, s in enumerate(segments) if j != i] + [segments[i]])\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n            cost3 = sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n            # Evaluate improvement\n            improvement = cost1 + cost2 + cost3\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        # Reorder segments to optimal position\n        segments.append(segments.pop(best_pos))\n        new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7303896695775366,
            1.9867762446403503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_scores = []\n    for sol, obj in archive:\n        # Calculate improvement potential based on objective values\n        potential = sum(obj) / (len(sol) ** 0.5)  # Normalize by tour length\n        potential_scores.append(potential)\n    selected_idx = np.argmax(potential_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment partitioning based on objective improvements\n    segment_lengths = []\n    for i in range(n-1):\n        node_a = new_solution[i]\n        node_b = new_solution[i+1]\n        # Calculate improvement potential for each edge in all objectives\n        imp1 = distance_matrix_1[node_a, node_b]\n        imp2 = distance_matrix_2[node_a, node_b]\n        imp3 = distance_matrix_3[node_a, node_b]\n        segment_lengths.append(max(imp1, imp2, imp3))\n\n    # Create segments based on cumulative improvement potential\n    cumulative = np.cumsum(segment_lengths)\n    total = cumulative[-1]\n    split_points = [0]\n    for p in np.linspace(0, total, num=4)[1:-1]:  # 3 segments\n        idx = np.searchsorted(cumulative, p)\n        split_points.append(idx + 1)\n    split_points.append(n)\n\n    # Extract segments\n    segments = []\n    for i in range(len(split_points)-1):\n        segments.append(new_solution[split_points[i]:split_points[i+1]])\n\n    # Adaptive segment merging and reinsertion\n    if len(segments) > 1:\n        # Merge two random segments\n        merge_idx = random.randint(0, len(segments)-2)\n        merged = np.concatenate([segments[merge_idx], segments[merge_idx+1]])\n        del segments[merge_idx+1]\n        segments[merge_idx] = merged\n\n    # Reinsert merged segment at optimal position\n    if len(segments) > 1:\n        # Evaluate insertion positions\n        best_pos = 0\n        best_improvement = float('inf')\n        for i in range(len(segments)):\n            # Create candidate solution\n            candidate = np.concatenate([s for j, s in enumerate(segments) if j != i] + [segments[i]])\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n            cost3 = sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n            # Evaluate improvement\n            improvement = cost1 + cost2 + cost3\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        # Reorder segments to optimal position\n        segments.append(segments.pop(best_pos))\n        new_solution = np.concatenate(segments)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space, but uses a novel segment selection mechanism that combines rank-based selection with diversity-aware segment evaluation to balance exploitation and exploration more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[selected_idx][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries with diversity consideration\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments with diversity-aware metric\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        diversity = len(np.unique(seg)) / len(seg)  # Normalized diversity\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3 - 0.5*diversity\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover with probability based on rank\n    seg_ranks = [i for i in range(3)]\n    best_seg_idx = random.choices(seg_ranks, weights=[1/(i+1) for i in seg_ranks], k=1)[0]\n    worst_seg_idx = random.choices(seg_ranks, weights=[i+1 for i in seg_ranks], k=1)[0]\n\n    # Perform segment-based crossover with adaptive probability\n    if random.random() < 0.6:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7058753254030452,
            1.1625635981559754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[selected_idx][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries with diversity consideration\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments with diversity-aware metric\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        diversity = len(np.unique(seg)) / len(seg)  # Normalized diversity\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3 - 0.5*diversity\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover with probability based on rank\n    seg_ranks = [i for i in range(3)]\n    best_seg_idx = random.choices(seg_ranks, weights=[1/(i+1) for i in seg_ranks], k=1)[0]\n    worst_seg_idx = random.choices(seg_ranks, weights=[i+1 for i in seg_ranks], k=1)[0]\n\n    # Perform segment-based crossover with adaptive probability\n    if random.random() < 0.6:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This new algorithm employs a multi-objective tour decomposition and adaptive segment-wise optimization strategy that dynamically partitions the solution into objective-aligned segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise 2-opt swaps while dynamically adjusting segment boundaries based on weighted improvements to optimize for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_indices = [i for i, (sol, obj) in enumerate(archive) if sum(obj) > sum(archive[0][1]) * 0.9]\n    if not candidate_indices:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(candidate_indices)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if len(current_segment) < 3 or weighted_cost < sum(obj_values)/3 * 0.8:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform 2-opt swaps on segments\n    for seg in segments:\n        if len(seg) >= 4:\n            i, j = random.sample(range(len(seg)), 2)\n            if i > j:\n                i, j = j, i\n            # Perform 2-opt swap\n            seg[i:j+1] = seg[i:j+1][::-1]\n\n    # Rebuild the solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6647873488097283,
            0.9971798181533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_indices = [i for i, (sol, obj) in enumerate(archive) if sum(obj) > sum(archive[0][1]) * 0.9]\n    if not candidate_indices:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(candidate_indices)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if len(current_segment) < 3 or weighted_cost < sum(obj_values)/3 * 0.8:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform 2-opt swaps on segments\n    for seg in segments:\n        if len(seg) >= 4:\n            i, j = random.sample(range(len(seg)), 2)\n            if i > j:\n                i, j = j, i\n            # Perform 2-opt swap\n            seg[i:j+1] = seg[i:j+1][::-1]\n\n    # Rebuild the solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This new algorithm employs a dynamic multi-objective segment inversion with adaptive objective-weighted segment selection, where it identifies segments with high weighted costs across objectives, inverts their order with dynamic segment boundaries, and applies probabilistic segment merging to explore the solution space while maintaining feasibility and promoting balanced objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for inversion\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Invert the worst segment\n    segments = [seg1, seg2, seg3]\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n\n    # Probabilistic segment merge\n    if random.random() < 0.3:\n        if len(segments[worst_seg_idx]) > 1 and len(segments[(worst_seg_idx + 1) % 3]) > 1:\n            merge_idx = (worst_seg_idx + 1) % 3\n            segments[worst_seg_idx] = np.concatenate([segments[worst_seg_idx], segments[merge_idx]])\n            segments.pop(merge_idx)\n\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6894138040418969,
            0.5522096276283264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for inversion\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Invert the worst segment\n    segments = [seg1, seg2, seg3]\n    segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n\n    # Probabilistic segment merge\n    if random.random() < 0.3:\n        if len(segments[worst_seg_idx]) > 1 and len(segments[(worst_seg_idx + 1) % 3]) > 1:\n            merge_idx = (worst_seg_idx + 1) % 3\n            segments[worst_seg_idx] = np.concatenate([segments[worst_seg_idx], segments[merge_idx]])\n            segments.pop(merge_idx)\n\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This new algorithm employs a multi-objective adaptive node-swap and segment-rearrangement strategy that dynamically selects and swaps node segments based on their relative contributions to each objective, while using a probabilistic segment inversion mechanism to explore diverse tour configurations, ensuring feasibility through a circular permutation mechanism that maintains tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i][::-1]\n            segments[j] = segments[j][::-1]\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6555408180601328,
            0.31894885301589965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i][::-1]\n            segments[j] = segments[j][::-1]\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7894405470270661,
            0.8843402624130249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This new algorithm employs a multi-objective adaptive tour partitioning and recombination strategy that dynamically segments the solution based on Pareto dominance and objective correlation, performs segment-wise operations with adaptive weights, and applies a novel circular shift mechanism to optimize across all three objectives while maintaining feasibility through constrained local moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective correlations\n    obj1, obj2, obj3 = objectives\n    corr12 = np.corrcoef([distance_matrix_1[new_solution[:-1], new_solution[1:]].flatten(),\n                          distance_matrix_2[new_solution[:-1], new_solution[1:]].flatten()])[0,1]\n    corr13 = np.corrcoef([distance_matrix_1[new_solution[:-1], new_solution[1:]].flatten(),\n                          distance_matrix_3[new_solution[:-1], new_solution[1:]].flatten()])[0,1]\n    corr23 = np.corrcoef([distance_matrix_2[new_solution[:-1], new_solution[1:]].flatten(),\n                          distance_matrix_3[new_solution[:-1], new_solution[1:]].flatten()])[0,1]\n\n    # Determine segment boundaries based on objective correlations\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate edge costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Decide segment boundary based on correlation patterns\n        if (abs(corr12) > 0.7 and abs(corr13) > 0.7) or len(current_segment) > 4:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment operations\n    if len(segments) > 1:\n        # Select segments for operation based on their objective contributions\n        segment_scores = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[:-1], seg[1:]])\n            seg_cost2 = sum(distance_matrix_2[seg[:-1], seg[1:]])\n            seg_cost3 = sum(distance_matrix_3[seg[:-1], seg[1:]])\n            segment_scores.append((seg_cost1 + seg_cost2 + seg_cost3) / len(seg))\n\n        # Select top 2 segments for operation\n        selected_segments = sorted(range(len(segment_scores)), key=lambda i: -segment_scores[i])[:2]\n\n        if random.random() < 0.6:\n            # Reverse one of the segments\n            seg_idx = selected_segments[0]\n            segments[seg_idx] = segments[seg_idx][::-1]\n        else:\n            # Shift segment content circularly\n            seg_idx = selected_segments[1]\n            shift = random.randint(1, len(segments[seg_idx])-1)\n            segments[seg_idx] = segments[seg_idx][shift:] + segments[seg_idx][:shift]\n\n    # Rebuild solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7145888528813928,
            3.9100512146949766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective correlations\n    obj1, obj2, obj3 = objectives\n    corr12 = np.corrcoef([distance_matrix_1[new_solution[:-1], new_solution[1:]].flatten(),\n                          distance_matrix_2[new_solution[:-1], new_solution[1:]].flatten()])[0,1]\n    corr13 = np.corrcoef([distance_matrix_1[new_solution[:-1], new_solution[1:]].flatten(),\n                          distance_matrix_3[new_solution[:-1], new_solution[1:]].flatten()])[0,1]\n    corr23 = np.corrcoef([distance_matrix_2[new_solution[:-1], new_solution[1:]].flatten(),\n                          distance_matrix_3[new_solution[:-1], new_solution[1:]].flatten()])[0,1]\n\n    # Determine segment boundaries based on objective correlations\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate edge costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n\n        # Decide segment boundary based on correlation patterns\n        if (abs(corr12) > 0.7 and abs(corr13) > 0.7) or len(current_segment) > 4:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment operations\n    if len(segments) > 1:\n        # Select segments for operation based on their objective contributions\n        segment_scores = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[:-1], seg[1:]])\n            seg_cost2 = sum(distance_matrix_2[seg[:-1], seg[1:]])\n            seg_cost3 = sum(distance_matrix_3[seg[:-1], seg[1:]])\n            segment_scores.append((seg_cost1 + seg_cost2 + seg_cost3) / len(seg))\n\n        # Select top 2 segments for operation\n        selected_segments = sorted(range(len(segment_scores)), key=lambda i: -segment_scores[i])[:2]\n\n        if random.random() < 0.6:\n            # Reverse one of the segments\n            seg_idx = selected_segments[0]\n            segments[seg_idx] = segments[seg_idx][::-1]\n        else:\n            # Shift segment content circularly\n            seg_idx = selected_segments[1]\n            shift = random.randint(1, len(segments[seg_idx])-1)\n            segments[seg_idx] = segments[seg_idx][shift:] + segments[seg_idx][:shift]\n\n    # Rebuild solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their contributions across all objectives with dynamically adjusted weights and performs crossover by replacing sub-tours with alternative paths while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7750110781202867,
            0.42604401111602785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This new algorithm adapts a multi-objective adaptive segment-based crossover with dynamically weighted segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.7:  # Increased probability for merge-split\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n    else:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7084184953458064,
            0.8077275276184082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.7:  # Increased probability for merge-split\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n    else:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective improvement potential and diversity measure, then generates a neighbor by performing a multi-objective-aware 2-opt swap combined with a novel segment rotation operation, ensuring feasibility while balancing exploration of the search space and exploitation of objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def improvement_potential(obj):\n        return sum(obj)\n\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n\n    def combined_score(solution_obj):\n        return 0.7 * improvement_potential(solution_obj) + 0.3 * diversity_score(solution_obj)\n\n    selected_solution = min(archive, key=lambda x: combined_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment rotation\n    k = random.randint(0, n-3)\n    segment = new_solution[k:k+3]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[k:k+3] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7010818701103391,
            3.376442277431488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def improvement_potential(obj):\n        return sum(obj)\n\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n\n    def combined_score(solution_obj):\n        return 0.7 * improvement_potential(solution_obj) + 0.3 * diversity_score(solution_obj)\n\n    selected_solution = min(archive, key=lambda x: combined_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment rotation\n    k = random.randint(0, n-3)\n    segment = new_solution[k:k+3]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[k:k+3] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm employs a dynamic objective-aware node clustering approach that groups nodes based on their relative contributions to each objective, performs cluster-wise rotations with adaptive weights determined by the current solution's objective values, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with dynamically adjusted cluster weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_cluster) < 5:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n\n        if random.random() < 0.6:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n        else:\n            clusters[i] = clusters[i] + clusters[j][::-1]\n            clusters.pop(j)\n\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.5 and len(cluster) > 2:\n            k = random.randint(1, len(cluster)-1)\n            cluster = cluster[-k:] + cluster[:-k]\n        new_solution.extend(cluster)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.740412411192775,
            0.45615878105163576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_cluster) < 5:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n\n        if random.random() < 0.6:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n        else:\n            clusters[i] = clusters[i] + clusters[j][::-1]\n            clusters.pop(j)\n\n    new_solution = []\n    for cluster in clusters:\n        if random.random() < 0.5 and len(cluster) > 2:\n            k = random.randint(1, len(cluster)-1)\n            cluster = cluster[-k:] + cluster[:-k]\n        new_solution.extend(cluster)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This new algorithm employs a hierarchical objective-aware node clustering approach that first groups nodes based on their relative performance in each objective space, then performs cluster-wise rotations and inter-cluster transpositions with adaptive probabilities determined by the cluster's contribution to each objective, while maintaining feasibility through a circular permutation framework that preserves tour continuity across all three objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select the solution with the best average objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node contributions to each objective\n    node_contributions = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        node_contributions.append((cost1, cost2, cost3))\n\n    # Cluster nodes based on objective dominance\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted cost difference\n        cost_diff1 = node_contributions[i][0] - node_contributions[i-1][0]\n        cost_diff2 = node_contributions[i][1] - node_contributions[i-1][1]\n        cost_diff3 = node_contributions[i][2] - node_contributions[i-1][2]\n\n        if abs(cost_diff1) + abs(cost_diff2) + abs(cost_diff3) > 0.1 * (sum(node_contributions[i]) + sum(node_contributions[i-1])):\n            clusters.append(current_cluster)\n            current_cluster = [node]\n        else:\n            current_cluster.append(node)\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Perform cluster operations\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n\n        # Rotate cluster i\n        if random.random() < 0.5 and len(clusters[i]) > 2:\n            k = random.randint(1, len(clusters[i])-1)\n            clusters[i] = clusters[i][-k:] + clusters[i][:-k]\n\n        # Transpose clusters if they have different objectives\n        if random.random() < 0.3 and len(clusters[i]) > 1 and len(clusters[j]) > 1:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    # Reconstruct solution\n    new_solution = []\n    for cluster in clusters:\n        new_solution.extend(cluster)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6976474064874297,
            0.8415706396102905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select the solution with the best average objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node contributions to each objective\n    node_contributions = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        node_contributions.append((cost1, cost2, cost3))\n\n    # Cluster nodes based on objective dominance\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate weighted cost difference\n        cost_diff1 = node_contributions[i][0] - node_contributions[i-1][0]\n        cost_diff2 = node_contributions[i][1] - node_contributions[i-1][1]\n        cost_diff3 = node_contributions[i][2] - node_contributions[i-1][2]\n\n        if abs(cost_diff1) + abs(cost_diff2) + abs(cost_diff3) > 0.1 * (sum(node_contributions[i]) + sum(node_contributions[i-1])):\n            clusters.append(current_cluster)\n            current_cluster = [node]\n        else:\n            current_cluster.append(node)\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Perform cluster operations\n    if len(clusters) > 1:\n        i, j = random.sample(range(len(clusters)), 2)\n\n        # Rotate cluster i\n        if random.random() < 0.5 and len(clusters[i]) > 2:\n            k = random.randint(1, len(clusters[i])-1)\n            clusters[i] = clusters[i][-k:] + clusters[i][:-k]\n\n        # Transpose clusters if they have different objectives\n        if random.random() < 0.3 and len(clusters[i]) > 1 and len(clusters[j]) > 1:\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    # Reconstruct solution\n    new_solution = []\n    for cluster in clusters:\n        new_solution.extend(cluster)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This new algorithm implements a multi-objective-aware node clustering and reordering strategy that dynamically groups nodes based on their proximity in all three objective spaces, then reorders clusters using a weighted combination of objective-specific distances to create a neighbor solution that balances exploration of different objective trade-offs while preserving tour feasibility through a cluster-based permutation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(sum(obj) - 0.5 * len(set(sol))) for sol, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate adaptive weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [0.3, 0.35, 0.35]\n\n    # Cluster nodes based on multi-objective proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate combined distance\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n        dist3 = distance_matrix_3[prev_node, node]\n        combined_dist = weights[0]*dist1 + weights[1]*dist2 + weights[2]*dist3\n\n        # Decide whether to continue current cluster or start a new one\n        if random.random() < 0.6 and combined_dist < 0.7 * np.mean([dist1, dist2, dist3]):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reorder clusters based on multi-objective criteria\n    if len(clusters) > 1:\n        # Calculate cluster quality scores\n        cluster_scores = []\n        for cluster in clusters:\n            total_dist = 0\n            for i in range(len(cluster)-1):\n                node1 = cluster[i]\n                node2 = cluster[i+1]\n                dist1 = distance_matrix_1[node1, node2]\n                dist2 = distance_matrix_2[node1, node2]\n                dist3 = distance_matrix_3[node1, node2]\n                total_dist += weights[0]*dist1 + weights[1]*dist2 + weights[2]*dist3\n            cluster_scores.append(total_dist / len(cluster))\n\n        # Sort clusters by score with some randomness\n        sorted_indices = sorted(range(len(clusters)), key=lambda k: cluster_scores[k] + 0.2 * random.random())\n\n        # Rebuild solution with reordered clusters\n        new_solution = []\n        for idx in sorted_indices:\n            cluster = clusters[idx]\n            if random.random() < 0.4 and len(cluster) > 2:\n                # Apply random permutation to cluster\n                random.shuffle(cluster)\n            new_solution.extend(cluster)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6126562707631091,
            4.067721259593964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(sum(obj) - 0.5 * len(set(sol))) for sol, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate adaptive weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [0.3, 0.35, 0.35]\n\n    # Cluster nodes based on multi-objective proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate combined distance\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n        dist3 = distance_matrix_3[prev_node, node]\n        combined_dist = weights[0]*dist1 + weights[1]*dist2 + weights[2]*dist3\n\n        # Decide whether to continue current cluster or start a new one\n        if random.random() < 0.6 and combined_dist < 0.7 * np.mean([dist1, dist2, dist3]):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reorder clusters based on multi-objective criteria\n    if len(clusters) > 1:\n        # Calculate cluster quality scores\n        cluster_scores = []\n        for cluster in clusters:\n            total_dist = 0\n            for i in range(len(cluster)-1):\n                node1 = cluster[i]\n                node2 = cluster[i+1]\n                dist1 = distance_matrix_1[node1, node2]\n                dist2 = distance_matrix_2[node1, node2]\n                dist3 = distance_matrix_3[node1, node2]\n                total_dist += weights[0]*dist1 + weights[1]*dist2 + weights[2]*dist3\n            cluster_scores.append(total_dist / len(cluster))\n\n        # Sort clusters by score with some randomness\n        sorted_indices = sorted(range(len(clusters)), key=lambda k: cluster_scores[k] + 0.2 * random.random())\n\n        # Rebuild solution with reordered clusters\n        new_solution = []\n        for idx in sorted_indices:\n            cluster = clusters[idx]\n            if random.random() < 0.4 and len(cluster) > 2:\n                # Apply random permutation to cluster\n                random.shuffle(cluster)\n            new_solution.extend(cluster)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This new algorithm employs a multi-objective adaptive path inversion with dynamic objective-aware segment selection, where it intelligently inverts segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6994992830554688,
            0.2804996371269226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective balance, then generates a neighbor by performing a multi-objective-aware segment reversal and insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n    selected_solution = min(archive, key=lambda x: diversity_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment insertion\n    if n >= 4:\n        k = random.randint(1, n-1)\n        segment = new_solution[k:k+2]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective balance, then generates a neighbor by performing a multi-objective-aware 2-opt and edge exchange, ensuring feasibility while potentially improving all three objectives through a balance of exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(obj):\n        sorted_obj = sorted(obj)\n        distance = 0\n        for i in range(1, len(sorted_obj)-1):\n            distance += sorted_obj[i+1] - sorted_obj[i-1]\n        return distance\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.4649956029465045,
            3.6520354390144347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(obj):\n        sorted_obj = sorted(obj)\n        distance = 0\n        for i in range(1, len(sorted_obj)-1):\n            distance += sorted_obj[i+1] - sorted_obj[i-1]\n        return distance\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then generates a neighbor by performing a multi-objective-aware 3-opt move followed by a segment relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = max(obj) - min(obj)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Perform segment relocation\n    if n >= 5:\n        seg_len = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_len - 1)\n        end = start + seg_len\n        segment = new_solution[start:end]\n        insert_pos = random.randint(0, n - seg_len)\n        if insert_pos > start:\n            insert_pos -= seg_len\n        new_solution = np.concatenate([\n            new_solution[:start], new_solution[end:insert_pos], segment, new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.5690094291666538,
            1.3640730738639832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = max(obj) - min(obj)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores) if random.random() < 0.6 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Perform segment relocation\n    if n >= 5:\n        seg_len = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_len - 1)\n        end = start + seg_len\n        segment = new_solution[start:end]\n        insert_pos = random.randint(0, n - seg_len)\n        if insert_pos > start:\n            insert_pos -= seg_len\n        new_solution = np.concatenate([\n            new_solution[:start], new_solution[end:insert_pos], segment, new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their contributions across all objectives with dynamically adjusted weights and performs crossover by replacing sub-tours with alternative paths while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This new algorithm employs a dynamic objective-aware edge replacement strategy with adaptive objective weighting, where it identifies critical edges based on their contributions across all objectives with dynamically adjusted weights and performs local search by replacing edges with alternative paths while prioritizing improvements in the most critical objectives, ensuring feasibility and promoting targeted exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1**2 + weights[1]*cost2**2 + weights[2]*cost3**2\n        edge_scores.append(score)\n\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            new_solution[worst_edge_idx+1] = w\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6413590403797156,
            0.46114386320114137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1**2 + weights[1]*cost2**2 + weights[2]*cost3**2\n        edge_scores.append(score)\n\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            new_solution[worst_edge_idx+1] = w\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their contributions across all objectives with dynamically adjusted weights and performs crossover by replacing sub-tours with alternative paths while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive path inversion with dynamic objective-aware segment selection, where it intelligently inverts segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment merging and splitting operator that dynamically combines and divides segments of the tour based on their contributions across all objectives, evaluates potential merges and splits using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements while ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Select two random segments\n    split1 = random.randint(1, n-3)\n    split2 = random.randint(split1+1, n-2)\n\n    # Split the solution into three segments\n    seg1 = base_solution[:split1]\n    seg2 = base_solution[split1:split2]\n    seg3 = base_solution[split2:]\n\n    # Evaluate the current configuration\n    def evaluate_segments(s1, s2, s3):\n        total_cost = 0\n        for seg in [s1, s2, s3]:\n            if len(seg) > 1:\n                cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n                cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n                cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n                total_cost += weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        return total_cost\n\n    current_cost = evaluate_segments(seg1, seg2, seg3)\n\n    # Try merging adjacent segments\n    merged_options = [\n        (np.concatenate([seg1, seg2, seg3]), seg1, seg2, seg3),\n        (np.concatenate([seg1, seg3, seg2]), seg1, seg3, seg2),\n        (np.concatenate([seg2, seg1, seg3]), seg2, seg1, seg3),\n        (np.concatenate([seg2, seg3, seg1]), seg2, seg3, seg1),\n        (np.concatenate([seg3, seg1, seg2]), seg3, seg1, seg2),\n        (np.concatenate([seg3, seg2, seg1]), seg3, seg2, seg1)\n    ]\n\n    best_merge = None\n    best_cost = current_cost\n\n    for merged, s1, s2, s3 in merged_options:\n        cost = evaluate_segments(s1, s2, s3)\n        if cost < best_cost:\n            best_cost = cost\n            best_merge = merged\n\n    if best_merge is not None:\n        new_solution = best_merge\n    else:\n        # If no improvement, try splitting a segment\n        split_seg = random.choice([seg1, seg2, seg3])\n        if len(split_seg) > 2:\n            split_point = random.randint(1, len(split_seg)-1)\n            new_seg1 = split_seg[:split_point]\n            new_seg2 = split_seg[split_point:]\n\n            if split_seg is seg1:\n                new_solution = np.concatenate([new_seg1, new_seg2, seg2, seg3])\n            elif split_seg is seg2:\n                new_solution = np.concatenate([seg1, new_seg1, new_seg2, seg3])\n            else:\n                new_solution = np.concatenate([seg1, seg2, new_seg1, new_seg2])\n        else:\n            new_solution = base_solution.copy()\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6782517194430058,
            1.8995811104774476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Select two random segments\n    split1 = random.randint(1, n-3)\n    split2 = random.randint(split1+1, n-2)\n\n    # Split the solution into three segments\n    seg1 = base_solution[:split1]\n    seg2 = base_solution[split1:split2]\n    seg3 = base_solution[split2:]\n\n    # Evaluate the current configuration\n    def evaluate_segments(s1, s2, s3):\n        total_cost = 0\n        for seg in [s1, s2, s3]:\n            if len(seg) > 1:\n                cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n                cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n                cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n                total_cost += weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        return total_cost\n\n    current_cost = evaluate_segments(seg1, seg2, seg3)\n\n    # Try merging adjacent segments\n    merged_options = [\n        (np.concatenate([seg1, seg2, seg3]), seg1, seg2, seg3),\n        (np.concatenate([seg1, seg3, seg2]), seg1, seg3, seg2),\n        (np.concatenate([seg2, seg1, seg3]), seg2, seg1, seg3),\n        (np.concatenate([seg2, seg3, seg1]), seg2, seg3, seg1),\n        (np.concatenate([seg3, seg1, seg2]), seg3, seg1, seg2),\n        (np.concatenate([seg3, seg2, seg1]), seg3, seg2, seg1)\n    ]\n\n    best_merge = None\n    best_cost = current_cost\n\n    for merged, s1, s2, s3 in merged_options:\n        cost = evaluate_segments(s1, s2, s3)\n        if cost < best_cost:\n            best_cost = cost\n            best_merge = merged\n\n    if best_merge is not None:\n        new_solution = best_merge\n    else:\n        # If no improvement, try splitting a segment\n        split_seg = random.choice([seg1, seg2, seg3])\n        if len(split_seg) > 2:\n            split_point = random.randint(1, len(split_seg)-1)\n            new_seg1 = split_seg[:split_point]\n            new_seg2 = split_seg[split_point:]\n\n            if split_seg is seg1:\n                new_solution = np.concatenate([new_seg1, new_seg2, seg2, seg3])\n            elif split_seg is seg2:\n                new_solution = np.concatenate([seg1, new_seg1, new_seg2, seg3])\n            else:\n                new_solution = np.concatenate([seg1, seg2, new_seg1, new_seg2])\n        else:\n            new_solution = base_solution.copy()\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their contributions across all objectives with dynamically adjusted weights and performs crossover by replacing sub-tours with alternative paths while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This new algorithm employs a dynamic multi-objective node-based crossover with adaptive objective-aware node selection, where it evaluates nodes based on their contributions across all objectives with dynamically adjusted weights and performs crossover by swapping nodes while dynamically adjusting node priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes\n    node_scores = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        node_scores.append(score)\n\n    # Select node to swap\n    if node_scores:\n        worst_node_idx = max(range(len(node_scores)), key=lambda i: node_scores[i])\n        worst_node = new_solution[worst_node_idx]\n\n        # Find alternative node\n        candidates = [i for i in range(n) if new_solution[i] != worst_node]\n        if candidates:\n            swap_idx = random.choice(candidates)\n            new_solution[worst_node_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_node_idx]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7033975087855726,
            0.8362086176872253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical nodes\n    node_scores = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        node_scores.append(score)\n\n    # Select node to swap\n    if node_scores:\n        worst_node_idx = max(range(len(node_scores)), key=lambda i: node_scores[i])\n        worst_node = new_solution[worst_node_idx]\n\n        # Find alternative node\n        candidates = [i for i in range(n) if new_solution[i] != worst_node]\n        if candidates:\n            swap_idx = random.choice(candidates)\n            new_solution[worst_node_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_node_idx]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This new algorithm combines the strengths of both provided approaches by selecting a solution from the archive based on a hybrid objective-structure metric, then applies a novel multi-objective-aware segment inversion and dynamic node insertion operator, ensuring feasibility while promoting balanced improvement across all three objectives through adaptive segment selection and insertion point evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (max(x[1]) - min(x[1])) + (len(set(x[0])) / len(x[0])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment selection based on objective contributions\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments across all objectives\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return (cost1 + cost2 + cost3) / 3  # Average across objectives\n\n    seg_scores = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n    worst_seg_idx = max(range(3), key=lambda i: seg_scores[i])\n\n    # Apply segment inversion with probability based on segment score\n    if random.random() < 0.7 * (seg_scores[worst_seg_idx] / max(seg_scores)):\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Dynamic node insertion for further improvement\n    if n > 4 and random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node_to_insert = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6872759221332099,
            4.133398056030273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (max(x[1]) - min(x[1])) + (len(set(x[0])) / len(x[0])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment selection based on objective contributions\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments across all objectives\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return (cost1 + cost2 + cost3) / 3  # Average across objectives\n\n    seg_scores = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n    worst_seg_idx = max(range(3), key=lambda i: seg_scores[i])\n\n    # Apply segment inversion with probability based on segment score\n    if random.random() < 0.7 * (seg_scores[worst_seg_idx] / max(seg_scores)):\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n\n    # Dynamic node insertion for further improvement\n    if n > 4 and random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node_to_insert = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their weighted contributions across all objectives, performs crossover by swapping these edges while dynamically adjusting the weights based on the current solution's performance, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges based on weighted contributions\n    edge_scores = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append((score, i))\n\n    # Select top and bottom edges for crossover\n    edge_scores.sort(key=lambda x: x[0])\n    worst_edge_idx = edge_scores[0][1]\n    best_edge_idx = edge_scores[-1][1]\n\n    # Swap nodes between worst and best edges\n    if worst_edge_idx < best_edge_idx:\n        new_solution[worst_edge_idx+1], new_solution[best_edge_idx+1] = new_solution[best_edge_idx+1], new_solution[worst_edge_idx+1]\n    else:\n        new_solution[worst_edge_idx+1], new_solution[best_edge_idx+1] = new_solution[best_edge_idx+1], new_solution[worst_edge_idx+1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7373961720738704,
            0.4892926812171936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges based on weighted contributions\n    edge_scores = []\n    for i in range(n-1):\n        node1, node2 = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append((score, i))\n\n    # Select top and bottom edges for crossover\n    edge_scores.sort(key=lambda x: x[0])\n    worst_edge_idx = edge_scores[0][1]\n    best_edge_idx = edge_scores[-1][1]\n\n    # Swap nodes between worst and best edges\n    if worst_edge_idx < best_edge_idx:\n        new_solution[worst_edge_idx+1], new_solution[best_edge_idx+1] = new_solution[best_edge_idx+1], new_solution[worst_edge_idx+1]\n    else:\n        new_solution[worst_edge_idx+1], new_solution[best_edge_idx+1] = new_solution[best_edge_idx+1], new_solution[worst_edge_idx+1]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive path inversion with dynamic objective-aware segment selection, where it intelligently inverts segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then generates a neighbor by performing a multi-objective-aware double-bridge move with adaptive segment selection, ensuring feasibility while promoting balanced improvements across all objectives through a dynamic segment reordering strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]) + abs(x[1][1] - x[1][2]) + abs(x[1][2] - x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Select four distinct segments for double-bridge move\n    indices = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = indices\n\n    # Create new solution by reconnecting segments in different order\n    segments = [\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c],\n        new_solution[c:d],\n        new_solution[d:]\n    ]\n\n    # Reorder segments with probability based on objective improvements\n    if random.random() < 0.7:  # 70% chance of reordering\n        # Calculate objective improvements for each segment\n        improvements = []\n        for i in range(len(segments)):\n            seg = segments[i]\n            if len(seg) < 2:\n                improvements.append(0)\n                continue\n\n            original_cost = (distance_matrix_1[seg[-1], seg[0]] +\n                            distance_matrix_2[seg[-1], seg[0]] +\n                            distance_matrix_3[seg[-1], seg[0]])\n\n            reversed_seg = seg[::-1]\n            reversed_cost = (distance_matrix_1[reversed_seg[-1], reversed_seg[0]] +\n                            distance_matrix_2[reversed_seg[-1], reversed_seg[0]] +\n                            distance_matrix_3[reversed_seg[-1], reversed_seg[0]])\n\n            improvements.append(original_cost - reversed_cost)\n\n        # Select segments to reverse based on improvements\n        to_reverse = [i for i, imp in enumerate(improvements) if imp > 0]\n        if to_reverse:\n            for i in to_reverse:\n                segments[i] = segments[i][::-1]\n\n        # Create new order with at least one segment reversed\n        new_order = segments.copy()\n        if len(to_reverse) >= 2:\n            i, j = random.sample(to_reverse, 2)\n            new_order[i], new_order[j] = new_order[j], new_order[i]\n\n        new_solution = np.concatenate(new_order)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.704887087073765,
            0.8500123977661133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]) + abs(x[1][1] - x[1][2]) + abs(x[1][2] - x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Select four distinct segments for double-bridge move\n    indices = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = indices\n\n    # Create new solution by reconnecting segments in different order\n    segments = [\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c],\n        new_solution[c:d],\n        new_solution[d:]\n    ]\n\n    # Reorder segments with probability based on objective improvements\n    if random.random() < 0.7:  # 70% chance of reordering\n        # Calculate objective improvements for each segment\n        improvements = []\n        for i in range(len(segments)):\n            seg = segments[i]\n            if len(seg) < 2:\n                improvements.append(0)\n                continue\n\n            original_cost = (distance_matrix_1[seg[-1], seg[0]] +\n                            distance_matrix_2[seg[-1], seg[0]] +\n                            distance_matrix_3[seg[-1], seg[0]])\n\n            reversed_seg = seg[::-1]\n            reversed_cost = (distance_matrix_1[reversed_seg[-1], reversed_seg[0]] +\n                            distance_matrix_2[reversed_seg[-1], reversed_seg[0]] +\n                            distance_matrix_3[reversed_seg[-1], reversed_seg[0]])\n\n            improvements.append(original_cost - reversed_cost)\n\n        # Select segments to reverse based on improvements\n        to_reverse = [i for i, imp in enumerate(improvements) if imp > 0]\n        if to_reverse:\n            for i in to_reverse:\n                segments[i] = segments[i][::-1]\n\n        # Create new order with at least one segment reversed\n        new_order = segments.copy()\n        if len(to_reverse) >= 2:\n            i, j = random.sample(to_reverse, 2)\n            new_order[i], new_order[j] = new_order[j], new_order[i]\n\n        new_solution = np.concatenate(new_order)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This new algorithm implements a multi-objective adaptive node insertion heuristic that dynamically selects nodes to reinsert based on their combined contribution to all objectives, using a weighted evaluation that adapts to the current solution's objective values, while maintaining feasibility through a controlled insertion process that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current solution's objective values\n    total = sum(objectives)\n    weights = [obj / total for obj in objectives] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select a random node to remove (excluding start/end nodes)\n    remove_idx = random.randint(1, n-2)\n    removed_node = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Evaluate potential insertion points\n    insertion_scores = []\n    for i in range(1, n-1):\n        # Calculate the cost of inserting the node between i-1 and i\n        cost1 = distance_matrix_1[new_solution[i-1], removed_node] + distance_matrix_1[removed_node, new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], removed_node] + distance_matrix_2[removed_node, new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]]\n        cost3 = distance_matrix_3[new_solution[i-1], removed_node] + distance_matrix_3[removed_node, new_solution[i]] - distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Weighted score\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        insertion_scores.append((score, i))\n\n    # Select the best insertion point\n    best_score, best_pos = min(insertion_scores, key=lambda x: x[0])\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7412723225284067,
            1.2470757246017456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on current solution's objective values\n    total = sum(objectives)\n    weights = [obj / total for obj in objectives] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select a random node to remove (excluding start/end nodes)\n    remove_idx = random.randint(1, n-2)\n    removed_node = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Evaluate potential insertion points\n    insertion_scores = []\n    for i in range(1, n-1):\n        # Calculate the cost of inserting the node between i-1 and i\n        cost1 = distance_matrix_1[new_solution[i-1], removed_node] + distance_matrix_1[removed_node, new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], removed_node] + distance_matrix_2[removed_node, new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]]\n        cost3 = distance_matrix_3[new_solution[i-1], removed_node] + distance_matrix_3[removed_node, new_solution[i]] - distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n        # Weighted score\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        insertion_scores.append((score, i))\n\n    # Select the best insertion point\n    best_score, best_pos = min(insertion_scores, key=lambda x: x[0])\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then generates a neighbor by performing a multi-segment inversion and objective-aware edge swaps, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (sum(x[1]) - max(x[1])) / (1 + min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if sum(new_costs) < sum(original_costs):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3739645722713035,
            4.477536678314209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (sum(x[1]) - max(x[1])) / (1 + min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if sum(new_costs) < sum(original_costs):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their contributions across all objectives with dynamically adjusted weights and performs crossover by replacing sub-tours with alternative paths while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This new algorithm employs a multi-objective tour inversion and dynamic objective-balanced edge replacement strategy that selectively inverts segments of the tour based on their objective contributions, then replaces edges with alternative paths prioritized by dynamically balanced improvements across all three objectives, ensuring feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for the combined objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if sum(obj) > 0]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = next(obj for sol, obj in archive if np.array_equal(sol, base_solution))\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select a segment to invert\n    if n > 3:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+4, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Identify edges to potentially replace\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Replace the worst edge if it exists\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative nodes\n        available_nodes = [node for node in range(n) if node not in new_solution[worst_edge_idx:worst_edge_idx+2]]\n\n        if available_nodes:\n            w = random.choice(available_nodes)\n            # Replace the edge with a new node\n            new_solution = np.insert(new_solution, worst_edge_idx+1, w)\n            # Remove the duplicate node if necessary\n            if len(new_solution) > n:\n                new_solution = np.delete(new_solution, worst_edge_idx+2)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7438311693933245,
            4.43315212726593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if sum(obj) > 0]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = next(obj for sol, obj in archive if np.array_equal(sol, base_solution))\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Select a segment to invert\n    if n > 3:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+4, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Identify edges to potentially replace\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Replace the worst edge if it exists\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative nodes\n        available_nodes = [node for node in range(n) if node not in new_solution[worst_edge_idx:worst_edge_idx+2]]\n\n        if available_nodes:\n            w = random.choice(available_nodes)\n            # Replace the edge with a new node\n            new_solution = np.insert(new_solution, worst_edge_idx+1, w)\n            # Remove the duplicate node if necessary\n            if len(new_solution) > n:\n                new_solution = np.delete(new_solution, worst_edge_idx+2)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This novel algorithm employs an adaptive multi-objective tour decomposition strategy that dynamically partitions the solution into objective-aligned segments, evaluates their contributions with dynamically adjusted weights, and performs segment-wise inversions and insertions while maintaining feasibility through a constrained circular permutation mechanism that optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance with normalization\n    obj_values = objectives\n    min_val = min(obj_values)\n    max_val = max(obj_values)\n    if max_val > min_val:\n        normalized = [(val - min_val) / (max_val - min_val) for val in obj_values]\n    else:\n        normalized = [1.0, 1.0, 1.0]\n    total = sum(normalized)\n    weights = [val / total for val in normalized] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions with probabilistic merging\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations with inversion\n    if len(segments) > 1:\n        # Randomly select two segments to swap, merge, or invert\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.4:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        elif random.random() < 0.7:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n        else:\n            # Invert a segment\n            segments[i] = segments[i][::-1]\n\n    # Rebuild the solution with circular permutation and segment rotation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        elif random.random() < 0.3 and len(seg) > 3:\n            # Apply segment rotation\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6386819963168511,
            0.2775106310844421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance with normalization\n    obj_values = objectives\n    min_val = min(obj_values)\n    max_val = max(obj_values)\n    if max_val > min_val:\n        normalized = [(val - min_val) / (max_val - min_val) for val in obj_values]\n    else:\n        normalized = [1.0, 1.0, 1.0]\n    total = sum(normalized)\n    weights = [val / total for val in normalized] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions with probabilistic merging\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.6 and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations with inversion\n    if len(segments) > 1:\n        # Randomly select two segments to swap, merge, or invert\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.4:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        elif random.random() < 0.7:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n        else:\n            # Invert a segment\n            segments[i] = segments[i][::-1]\n\n    # Rebuild the solution with circular permutation and segment rotation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        elif random.random() < 0.3 and len(seg) > 3:\n            # Apply segment rotation\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive path inversion with dynamic objective-aware segment selection, where it intelligently inverts segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment relocation with dynamic objective-aware segment selection, where it intelligently relocates segments of the tour to different positions based on their weighted contributions across all objectives, evaluates potential improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = new_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Find best insertion position\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i >= seg_start and i <= seg_end:\n            continue  # Skip current segment position\n\n        # Try inserting segment at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Ensure no node is skipped or revisited\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate new segment\n        new_seg_start = max(0, i-1)\n        new_seg_end = min(new_seg_start + seg_length, n-1)\n        new_segment = temp_solution[new_seg_start:new_seg_end]\n        current_cost = evaluate_segment(new_segment)\n\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_pos = i\n\n    # Apply relocation if it improves the weighted cost\n    if best_pos != -1 and best_cost < original_cost:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Additional local improvement: try relocating a single node if relocation didn't help\n    if best_pos == -1 or best_cost >= original_cost:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            new_solution = np.concatenate([\n                new_solution[:a],\n                [new_solution[b]],\n                new_solution[a+1:b],\n                [new_solution[a]],\n                new_solution[b+1:]\n            ])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7117601764588531,
            3.209233748912811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, obj_values = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = new_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Find best insertion position\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i >= seg_start and i <= seg_end:\n            continue  # Skip current segment position\n\n        # Try inserting segment at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Ensure no node is skipped or revisited\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Evaluate new segment\n        new_seg_start = max(0, i-1)\n        new_seg_end = min(new_seg_start + seg_length, n-1)\n        new_segment = temp_solution[new_seg_start:new_seg_end]\n        current_cost = evaluate_segment(new_segment)\n\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_pos = i\n\n    # Apply relocation if it improves the weighted cost\n    if best_pos != -1 and best_cost < original_cost:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Additional local improvement: try relocating a single node if relocation didn't help\n    if best_pos == -1 or best_cost >= original_cost:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            new_solution = np.concatenate([\n                new_solution[:a],\n                [new_solution[b]],\n                new_solution[a+1:b],\n                [new_solution[a]],\n                new_solution[b+1:]\n            ])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6592496036843931,
            0.32188522815704346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment inversion and objective-aware path reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment[::-1], new_solution[b+1:]\n    ])\n\n    # Objective-aware path reversal\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[j+1 if j+1 < n else 0]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7063393602197039,
            2.2903788805007936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-segment inversion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment[::-1], new_solution[b+1:]\n    ])\n\n    # Objective-aware path reversal\n    for _ in range(3):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[j+1 if j+1 < n else 0]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[j+1 if j+1 < n else 0]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective adaptive path inversion with dynamic objective-aware segment selection, where it intelligently inverts segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment relocation with dynamic objective-aware node selection, where it intelligently relocates segments of the tour based on their contributions across all objectives, evaluates improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Relocate the segment to a new position\n    new_pos = random.randint(0, n-1)\n    if new_pos > seg_start:\n        new_pos -= len(segment)\n\n    new_solution = np.concatenate([\n        base_solution[:seg_start],\n        base_solution[seg_end:new_pos],\n        segment,\n        base_solution[new_pos:seg_start],\n        base_solution[seg_end:]\n    ])\n\n    # Evaluate the new solution\n    def evaluate_solution(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost3 = sum(distance_matrix_3[sol[i-1], sol[i]] for i in range(len(sol)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    new_cost = evaluate_solution(new_solution)\n\n    # Apply relocation if it improves the weighted cost\n    if new_cost < original_cost:\n        base_solution = new_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the relocation didn't help\n    if new_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        base_solution[a], base_solution[b] = base_solution[b], base_solution[a]\n\n    # Ensure the tour is circular\n    if base_solution[0] != base_solution[-1]:\n        base_solution = np.append(base_solution, base_solution[0])\n\n    return base_solution\n\n",
        "score": [
            -0.6452365940205965,
            0.571157968044281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Relocate the segment to a new position\n    new_pos = random.randint(0, n-1)\n    if new_pos > seg_start:\n        new_pos -= len(segment)\n\n    new_solution = np.concatenate([\n        base_solution[:seg_start],\n        base_solution[seg_end:new_pos],\n        segment,\n        base_solution[new_pos:seg_start],\n        base_solution[seg_end:]\n    ])\n\n    # Evaluate the new solution\n    def evaluate_solution(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost3 = sum(distance_matrix_3[sol[i-1], sol[i]] for i in range(len(sol)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    new_cost = evaluate_solution(new_solution)\n\n    # Apply relocation if it improves the weighted cost\n    if new_cost < original_cost:\n        base_solution = new_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the relocation didn't help\n    if new_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        base_solution[a], base_solution[b] = base_solution[b], base_solution[a]\n\n    # Ensure the tour is circular\n    if base_solution[0] != base_solution[-1]:\n        base_solution = np.append(base_solution, base_solution[0])\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This new algorithm employs a dynamic objective-weighted segmental perturbation strategy that adaptively selects and modifies tour segments based on node dominance in each objective space, performs segment-wise inversions and cross-segment merges with probability proportional to the node's relative contribution to each objective, and maintains feasibility through a circular permutation mechanism that ensures tour continuity while optimizing for all three objectives with adaptive weights and segmental dominance criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.8 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7517103291836299,
            0.2047654628753662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.8 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This new algorithm employs a dynamic objective-weighted segmental perturbation strategy that adaptively selects and modifies tour segments based on node dominance in each objective space, performs segment-wise inversions and cross-segment merges with probability proportional to the node's relative contribution to each objective, and maintains feasibility through a circular permutation mechanism that ensures tour continuity while optimizing for all three objectives with adaptive weights and segmental dominance criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.8 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7517103291836299,
            0.2047654628753662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.8 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive path inversion with dynamic objective-aware segment selection, where it intelligently inverts segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This new algorithm employs a multi-objective-aware node insertion and segment relinking strategy that intelligently selects and combines segments from different solutions in the archive to create a hybrid neighbor solution, while dynamically balancing improvements across all three objectives through adaptive segment selection and weighted cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two distinct solutions from the archive\n    sol1, sol2 = random.sample(archive, 2)\n    base_solution = sol1[0].copy()\n    reference_solution = sol2[0].copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Randomly select a segment from the base solution\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n    segment = base_solution[seg_start:seg_end]\n\n    # Find the best position to insert this segment in the reference solution\n    best_position = 0\n    best_cost = float('inf')\n\n    for i in range(len(reference_solution)):\n        # Try inserting the segment at position i\n        candidate = np.concatenate([reference_solution[:i], segment, reference_solution[i:]])\n\n        # Calculate the cost for each objective\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n        cost3 = sum(distance_matrix_3[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n\n        # Weighted sum of costs (equal weights for simplicity)\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_position = i\n\n    # Create the new solution by inserting the segment at the best position\n    new_solution = np.concatenate([reference_solution[:best_position], segment, reference_solution[best_position:]])\n\n    # Remove duplicates while preserving order\n    _, idx = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(idx)]\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n:\n        # If we lost nodes, add missing nodes at random positions\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6635496163287439,
            3.3707887649536135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two distinct solutions from the archive\n    sol1, sol2 = random.sample(archive, 2)\n    base_solution = sol1[0].copy()\n    reference_solution = sol2[0].copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Randomly select a segment from the base solution\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n    segment = base_solution[seg_start:seg_end]\n\n    # Find the best position to insert this segment in the reference solution\n    best_position = 0\n    best_cost = float('inf')\n\n    for i in range(len(reference_solution)):\n        # Try inserting the segment at position i\n        candidate = np.concatenate([reference_solution[:i], segment, reference_solution[i:]])\n\n        # Calculate the cost for each objective\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n        cost3 = sum(distance_matrix_3[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n\n        # Weighted sum of costs (equal weights for simplicity)\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_position = i\n\n    # Create the new solution by inserting the segment at the best position\n    new_solution = np.concatenate([reference_solution[:best_position], segment, reference_solution[best_position:]])\n\n    # Remove duplicates while preserving order\n    _, idx = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(idx)]\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n:\n        # If we lost nodes, add missing nodes at random positions\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and crowding distance, then generates a neighbor by performing a multi-segment reversal and objective-aware edge insertion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Select based on objective diversity and crowding distance\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        diversity = np.std(objectives, axis=0).sum()\n        scores = crowding * diversity\n        selected_idx = np.argmax(scores)\n        selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment reversal\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1][::-1]\n    segment2 = new_solution[c:d+1][::-1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment1, new_solution[b+1:c], segment2, new_solution[d+1:]\n    ])\n\n    # Objective-aware edge insertion\n    for _ in range(3):\n        i = random.randint(1, n - 2)\n        j = random.randint(0, n - 1)\n        while j == i or j == i - 1 or j == i + 1:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        temp_solution = new_solution.copy()\n        node = temp_solution[i]\n        temp_solution = np.delete(temp_solution, i)\n        temp_solution = np.insert(temp_solution, j, node)\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5438064170870797,
            3.135397028923035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Select based on objective diversity and crowding distance\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        diversity = np.std(objectives, axis=0).sum()\n        scores = crowding * diversity\n        selected_idx = np.argmax(scores)\n        selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment reversal\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1][::-1]\n    segment2 = new_solution[c:d+1][::-1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment1, new_solution[b+1:c], segment2, new_solution[d+1:]\n    ])\n\n    # Objective-aware edge insertion\n    for _ in range(3):\n        i = random.randint(1, n - 2)\n        j = random.randint(0, n - 1)\n        while j == i or j == i - 1 or j == i + 1:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        temp_solution = new_solution.copy()\n        node = temp_solution[i]\n        temp_solution = np.delete(temp_solution, i)\n        temp_solution = np.insert(temp_solution, j, node)\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment merging and splitting strategy that dynamically identifies critical segments based on their contribution to each objective, performs segment-wise permutations with probability proportional to their weighted improvement potential, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with dynamically adjusted weights and segment boundary adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine critical segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Evaluate segments and select high-potential segments for transformation\n    segment_scores = []\n    for seg in segments:\n        if len(seg) < 2:\n            segment_scores.append(0)\n            continue\n\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        weighted_score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_scores.append(weighted_score)\n\n    if not segment_scores:\n        return new_solution\n\n    max_score = max(segment_scores)\n    high_potential_indices = [i for i, score in enumerate(segment_scores) if score >= 0.7 * max_score]\n\n    if not high_potential_indices:\n        return new_solution\n\n    # Apply segment transformations\n    selected_idx = random.choice(high_potential_indices)\n    selected_seg = segments[selected_idx]\n\n    if len(selected_seg) > 3:\n        # Perform segment permutation with probability based on improvement potential\n        if random.random() < 0.6:\n            k = random.randint(1, len(selected_seg)-1)\n            selected_seg = selected_seg[-k:] + selected_seg[:-k]\n            segments[selected_idx] = selected_seg\n\n    # Reconstruct the solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6789747779160945,
            0.35186084508895876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dynamic weights based on objective values\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine critical segments based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Evaluate segments and select high-potential segments for transformation\n    segment_scores = []\n    for seg in segments:\n        if len(seg) < 2:\n            segment_scores.append(0)\n            continue\n\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        weighted_score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_scores.append(weighted_score)\n\n    if not segment_scores:\n        return new_solution\n\n    max_score = max(segment_scores)\n    high_potential_indices = [i for i, score in enumerate(segment_scores) if score >= 0.7 * max_score]\n\n    if not high_potential_indices:\n        return new_solution\n\n    # Apply segment transformations\n    selected_idx = random.choice(high_potential_indices)\n    selected_seg = segments[selected_idx]\n\n    if len(selected_seg) > 3:\n        # Perform segment permutation with probability based on improvement potential\n        if random.random() < 0.6:\n            k = random.randint(1, len(selected_seg)-1)\n            selected_seg = selected_seg[-k:] + selected_seg[:-k]\n            segments[selected_idx] = selected_seg\n\n    # Reconstruct the solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective tour partitioning strategy that dynamically segments the solution based on node dominance in each objective space, performs segment-wise inversions and cross-segment swaps with probability proportional to the node's relative contribution to each objective, and ensures feasibility through a circular permutation mechanism that maintains tour continuity while optimizing for all three objectives with adaptive weights.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost and len(current_segment) < 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.7:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j][::-1]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.4 and len(seg) > 3:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and spatial clustering, then generates a neighbor by performing a multi-objective k-means inspired segmentation followed by adaptive segment merging and reordering, ensuring feasibility through a circular permutation mechanism that optimizes for all three objectives while maintaining tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective k-means inspired segmentation\n    k = min(3, n // 4)\n    centroids = random.sample(range(n), k)\n    segments = [[] for _ in range(k)]\n\n    for i in range(n):\n        node = new_solution[i]\n        coords = instance[node]\n\n        # Calculate distances to centroids in all three spaces\n        dists = []\n        for c in centroids:\n            c_node = new_solution[c]\n            c_coords = instance[c_node]\n            dist1 = ((coords[0] - c_coords[0])**2 + (coords[1] - c_coords[1])**2)**0.5\n            dist2 = ((coords[2] - c_coords[2])**2 + (coords[3] - c_coords[3])**2)**0.5\n            dist3 = distance_matrix_1[node, c_node] + distance_matrix_2[node, c_node] + distance_matrix_3[node, c_node]\n            dists.append(dist1 + dist2 + dist3)\n\n        closest = np.argmin(dists)\n        segments[closest].append(node)\n\n    # Adaptive segment merging and reordering\n    merged_segments = []\n    for seg in segments:\n        if len(seg) > 1:\n            if random.random() < 0.6:\n                # Randomly reorder segment\n                random.shuffle(seg)\n            merged_segments.append(seg)\n        elif len(seg) == 1:\n            merged_segments.append(seg)\n\n    if len(merged_segments) > 1 and random.random() < 0.5:\n        # Merge two random segments\n        i, j = random.sample(range(len(merged_segments)), 2)\n        merged_segments[i] = merged_segments[i] + merged_segments[j]\n        merged_segments.pop(j)\n\n    # Reconstruct solution\n    new_solution = []\n    for seg in merged_segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7612655573404927,
            1.7861379265785218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective k-means inspired segmentation\n    k = min(3, n // 4)\n    centroids = random.sample(range(n), k)\n    segments = [[] for _ in range(k)]\n\n    for i in range(n):\n        node = new_solution[i]\n        coords = instance[node]\n\n        # Calculate distances to centroids in all three spaces\n        dists = []\n        for c in centroids:\n            c_node = new_solution[c]\n            c_coords = instance[c_node]\n            dist1 = ((coords[0] - c_coords[0])**2 + (coords[1] - c_coords[1])**2)**0.5\n            dist2 = ((coords[2] - c_coords[2])**2 + (coords[3] - c_coords[3])**2)**0.5\n            dist3 = distance_matrix_1[node, c_node] + distance_matrix_2[node, c_node] + distance_matrix_3[node, c_node]\n            dists.append(dist1 + dist2 + dist3)\n\n        closest = np.argmin(dists)\n        segments[closest].append(node)\n\n    # Adaptive segment merging and reordering\n    merged_segments = []\n    for seg in segments:\n        if len(seg) > 1:\n            if random.random() < 0.6:\n                # Randomly reorder segment\n                random.shuffle(seg)\n            merged_segments.append(seg)\n        elif len(seg) == 1:\n            merged_segments.append(seg)\n\n    if len(merged_segments) > 1 and random.random() < 0.5:\n        # Merge two random segments\n        i, j = random.sample(range(len(merged_segments)), 2)\n        merged_segments[i] = merged_segments[i] + merged_segments[j]\n        merged_segments.pop(j)\n\n    # Reconstruct solution\n    new_solution = []\n    for seg in merged_segments:\n        new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm employs a multi-objective path inversion operator with adaptive objective-weighted segment selection, where it identifies critical segments in the tour based on their weighted contributions across all objectives, inverts these segments with dynamic probability, and then performs a targeted node insertion to repair any feasibility issues while promoting balanced improvements across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on weighted contributions\n    segment_length = max(2, n // 4)\n    segments = [new_solution[i:i+segment_length] for i in range(0, n, segment_length) if i+segment_length <= n]\n\n    # Evaluate segments based on weighted contributions\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    segment_scores = [evaluate_segment(seg) for seg in segments]\n\n    # Select segments to invert with dynamic probability\n    for i, seg in enumerate(segments):\n        if random.random() < 0.3 * (1 - segment_scores[i] / (sum(segment_scores) + 1e-6)):\n            segments[i] = seg[::-1]\n\n    # Reconstruct the solution with inverted segments\n    new_solution = np.concatenate(segments)\n\n    # Perform targeted node insertion to repair any feasibility issues\n    if len(np.unique(new_solution)) != n:\n        # Find duplicate nodes and replace them\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n\n        for dup in duplicates:\n            # Find all positions of the duplicate\n            positions = np.where(new_solution == dup)[0]\n            for pos in positions[1:]:\n                # Find the best position to insert a missing node\n                missing_nodes = [node for node in range(n) if node not in new_solution]\n                if missing_nodes:\n                    best_node = min(missing_nodes, key=lambda x: sum([\n                        weights[0] * (distance_matrix_1[new_solution[pos-1], x] + distance_matrix_1[x, new_solution[(pos+1)%n]]),\n                        weights[1] * (distance_matrix_2[new_solution[pos-1], x] + distance_matrix_2[x, new_solution[(pos+1)%n]]),\n                        weights[2] * (distance_matrix_3[new_solution[pos-1], x] + distance_matrix_3[x, new_solution[(pos+1)%n]])\n                    ]))\n                    new_solution[pos] = best_node\n\n    return new_solution\n\n",
        "score": [
            -0.6580679437381127,
            3.844277811050415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate dynamic weights based on objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical segments based on weighted contributions\n    segment_length = max(2, n // 4)\n    segments = [new_solution[i:i+segment_length] for i in range(0, n, segment_length) if i+segment_length <= n]\n\n    # Evaluate segments based on weighted contributions\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(1, len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    segment_scores = [evaluate_segment(seg) for seg in segments]\n\n    # Select segments to invert with dynamic probability\n    for i, seg in enumerate(segments):\n        if random.random() < 0.3 * (1 - segment_scores[i] / (sum(segment_scores) + 1e-6)):\n            segments[i] = seg[::-1]\n\n    # Reconstruct the solution with inverted segments\n    new_solution = np.concatenate(segments)\n\n    # Perform targeted node insertion to repair any feasibility issues\n    if len(np.unique(new_solution)) != n:\n        # Find duplicate nodes and replace them\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n\n        for dup in duplicates:\n            # Find all positions of the duplicate\n            positions = np.where(new_solution == dup)[0]\n            for pos in positions[1:]:\n                # Find the best position to insert a missing node\n                missing_nodes = [node for node in range(n) if node not in new_solution]\n                if missing_nodes:\n                    best_node = min(missing_nodes, key=lambda x: sum([\n                        weights[0] * (distance_matrix_1[new_solution[pos-1], x] + distance_matrix_1[x, new_solution[(pos+1)%n]]),\n                        weights[1] * (distance_matrix_2[new_solution[pos-1], x] + distance_matrix_2[x, new_solution[(pos+1)%n]]),\n                        weights[2] * (distance_matrix_3[new_solution[pos-1], x] + distance_matrix_3[x, new_solution[(pos+1)%n]])\n                    ]))\n                    new_solution[pos] = best_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective adaptive path inversion with dynamic objective-aware segment selection, where it intelligently inverts segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    # Dynamic weights based on current solution's objective values\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    seg_start = random.randint(0, n-2)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n-1)\n\n    # Extract segment\n    segment = base_solution[seg_start:seg_end]\n\n    # Evaluate segment\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    # Apply inversion if it improves the weighted cost\n    if inverted_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = inverted_segment\n    else:\n        new_solution = base_solution.copy()\n\n    # Additional local improvement: try swapping nodes if the inversion didn't help\n    if inverted_cost >= original_cost:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment merging and splitting strategy with dynamic objective-aware segment selection, where it intelligently merges and splits segments of the tour based on their contributions across all objectives, evaluates the improvements using dynamically weighted objective functions, and dynamically adjusts segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space while maintaining tour validity through a novel segment reordering mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    seg_start = random.randint(0, n-3)\n    seg_length = random.randint(2, min(4, n-seg_start-1))\n    seg_end = seg_start + seg_length\n\n    segment = base_solution[seg_start:seg_end]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    if random.random() < 0.5:\n        split_point = random.randint(1, len(segment)-1)\n        first_part = segment[:split_point]\n        second_part = segment[split_point:]\n\n        if random.random() < 0.5:\n            first_part = first_part[::-1]\n        else:\n            second_part = second_part[::-1]\n\n        merged_segment = np.concatenate([first_part, second_part])\n    else:\n        other_segment_start = random.randint(0, n-3)\n        other_segment_length = random.randint(2, min(4, n-other_segment_start-1))\n        other_segment_end = other_segment_start + other_segment_length\n        other_segment = base_solution[other_segment_start:other_segment_end]\n\n        combined = np.concatenate([segment, other_segment])\n        split_point = len(segment)\n        merged_segment = np.concatenate([combined[split_point:], combined[:split_point]])\n\n    merged_cost = evaluate_segment(merged_segment)\n\n    if merged_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = merged_segment\n    else:\n        new_solution = base_solution.copy()\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6153088018997678,
            0.45502434968948363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    obj_values = selected[1]\n\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    seg_start = random.randint(0, n-3)\n    seg_length = random.randint(2, min(4, n-seg_start-1))\n    seg_end = seg_start + seg_length\n\n    segment = base_solution[seg_start:seg_end]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    original_cost = evaluate_segment(segment)\n\n    if random.random() < 0.5:\n        split_point = random.randint(1, len(segment)-1)\n        first_part = segment[:split_point]\n        second_part = segment[split_point:]\n\n        if random.random() < 0.5:\n            first_part = first_part[::-1]\n        else:\n            second_part = second_part[::-1]\n\n        merged_segment = np.concatenate([first_part, second_part])\n    else:\n        other_segment_start = random.randint(0, n-3)\n        other_segment_length = random.randint(2, min(4, n-other_segment_start-1))\n        other_segment_end = other_segment_start + other_segment_length\n        other_segment = base_solution[other_segment_start:other_segment_end]\n\n        combined = np.concatenate([segment, other_segment])\n        split_point = len(segment)\n        merged_segment = np.concatenate([combined[split_point:], combined[:split_point]])\n\n    merged_cost = evaluate_segment(merged_segment)\n\n    if merged_cost < original_cost:\n        new_solution = base_solution.copy()\n        new_solution[seg_start:seg_end] = merged_segment\n    else:\n        new_solution = base_solution.copy()\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a dynamic objective-weighted segmental perturbation strategy that adaptively selects and modifies tour segments based on node dominance in each objective space, performs segment-wise inversions and cross-segment merges with probability proportional to the node's relative contribution to each objective, and maintains feasibility through a circular permutation mechanism that ensures tour continuity while optimizing for all three objectives with adaptive weights and segmental dominance criteria.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < weighted_cost * 0.8 and len(current_segment) < 5:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    if len(segments) > 1:\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.6:\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.5 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This new algorithm employs a multi-objective segmental crossover strategy that adaptively combines segments from two parent solutions based on node dominance in each objective, performs segment-wise inversions with probability proportional to the node's relative contribution to each objective, and maintains feasibility through a circular permutation mechanism that ensures tour continuity while optimizing for all three objectives with adaptive weights and segmental dominance criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    parent1, parent2 = random.sample(archive, 2)\n    sol1, obj1 = parent1\n    sol2, obj2 = parent2\n\n    n = len(sol1)\n    if n < 4:\n        return sol1.copy()\n\n    obj_values1 = obj1\n    obj_values2 = obj2\n    total1 = sum(obj_values1)\n    total2 = sum(obj_values2)\n    weights1 = [obj / total1 for obj in obj_values1] if total1 > 0 else [1/3, 1/3, 1/3]\n    weights2 = [obj / total2 for obj in obj_values2] if total2 > 0 else [1/3, 1/3, 1/3]\n\n    segments1 = []\n    segments2 = []\n    current_seg1 = [sol1[0]]\n    current_seg2 = [sol2[0]]\n\n    for i in range(1, n):\n        node1 = sol1[i]\n        node2 = sol2[i]\n        prev_node1 = sol1[i-1]\n        prev_node2 = sol2[i-1]\n\n        cost1_1 = distance_matrix_1[prev_node1, node1]\n        cost2_1 = distance_matrix_2[prev_node1, node1]\n        cost3_1 = distance_matrix_3[prev_node1, node1]\n        weighted_cost1 = weights1[0]*cost1_1 + weights1[1]*cost2_1 + weights1[2]*cost3_1\n\n        cost1_2 = distance_matrix_1[prev_node2, node2]\n        cost2_2 = distance_matrix_2[prev_node2, node2]\n        cost3_2 = distance_matrix_3[prev_node2, node2]\n        weighted_cost2 = weights2[0]*cost1_2 + weights2[1]*cost2_2 + weights2[2]*cost3_2\n\n        if random.random() < weighted_cost1 * 0.7 and len(current_seg1) < 4:\n            current_seg1.append(node1)\n        else:\n            segments1.append(current_seg1)\n            current_seg1 = [node1]\n\n        if random.random() < weighted_cost2 * 0.7 and len(current_seg2) < 4:\n            current_seg2.append(node2)\n        else:\n            segments2.append(current_seg2)\n            current_seg2 = [node2]\n\n    if current_seg1:\n        segments1.append(current_seg1)\n    if current_seg2:\n        segments2.append(current_seg2)\n\n    new_segments = []\n    for seg1, seg2 in zip(segments1, segments2):\n        if random.random() < 0.5:\n            new_segments.append(seg1)\n        else:\n            new_segments.append(seg2)\n\n    new_solution = []\n    for seg in new_segments:\n        if random.random() < 0.4 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6563193568010826,
            0.5163483500480652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    parent1, parent2 = random.sample(archive, 2)\n    sol1, obj1 = parent1\n    sol2, obj2 = parent2\n\n    n = len(sol1)\n    if n < 4:\n        return sol1.copy()\n\n    obj_values1 = obj1\n    obj_values2 = obj2\n    total1 = sum(obj_values1)\n    total2 = sum(obj_values2)\n    weights1 = [obj / total1 for obj in obj_values1] if total1 > 0 else [1/3, 1/3, 1/3]\n    weights2 = [obj / total2 for obj in obj_values2] if total2 > 0 else [1/3, 1/3, 1/3]\n\n    segments1 = []\n    segments2 = []\n    current_seg1 = [sol1[0]]\n    current_seg2 = [sol2[0]]\n\n    for i in range(1, n):\n        node1 = sol1[i]\n        node2 = sol2[i]\n        prev_node1 = sol1[i-1]\n        prev_node2 = sol2[i-1]\n\n        cost1_1 = distance_matrix_1[prev_node1, node1]\n        cost2_1 = distance_matrix_2[prev_node1, node1]\n        cost3_1 = distance_matrix_3[prev_node1, node1]\n        weighted_cost1 = weights1[0]*cost1_1 + weights1[1]*cost2_1 + weights1[2]*cost3_1\n\n        cost1_2 = distance_matrix_1[prev_node2, node2]\n        cost2_2 = distance_matrix_2[prev_node2, node2]\n        cost3_2 = distance_matrix_3[prev_node2, node2]\n        weighted_cost2 = weights2[0]*cost1_2 + weights2[1]*cost2_2 + weights2[2]*cost3_2\n\n        if random.random() < weighted_cost1 * 0.7 and len(current_seg1) < 4:\n            current_seg1.append(node1)\n        else:\n            segments1.append(current_seg1)\n            current_seg1 = [node1]\n\n        if random.random() < weighted_cost2 * 0.7 and len(current_seg2) < 4:\n            current_seg2.append(node2)\n        else:\n            segments2.append(current_seg2)\n            current_seg2 = [node2]\n\n    if current_seg1:\n        segments1.append(current_seg1)\n    if current_seg2:\n        segments2.append(current_seg2)\n\n    new_segments = []\n    for seg1, seg2 in zip(segments1, segments2):\n        if random.random() < 0.5:\n            new_segments.append(seg1)\n        else:\n            new_segments.append(seg2)\n\n    new_solution = []\n    for seg in new_segments:\n        if random.random() < 0.4 and len(seg) > 2:\n            k = random.randint(1, len(seg)-1)\n            seg = seg[-k:] + seg[:-k]\n        new_solution.extend(seg)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their contributions across all objectives with dynamically adjusted weights and performs crossover by replacing sub-tours with alternative paths while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This new algorithm employs a hierarchical objective-aware path insertion strategy that first identifies critical segments in the tour based on their combined contributions across all objectives, then performs multi-point insertions with dynamically adjusted priorities to explore promising alternative paths while maintaining feasibility and balancing exploration of different objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical segments\n    segment_scores = []\n    for i in range(n-2):\n        segment = new_solution[i:i+3]\n        cost1 = distance_matrix_1[segment[0], segment[1]] + distance_matrix_1[segment[1], segment[2]]\n        cost2 = distance_matrix_2[segment[0], segment[1]] + distance_matrix_2[segment[1], segment[2]]\n        cost3 = distance_matrix_3[segment[0], segment[1]] + distance_matrix_3[segment[1], segment[2]]\n        score = cost1 + cost2 + cost3\n        segment_scores.append(score)\n\n    if segment_scores:\n        # Select worst segment to replace\n        worst_segment_idx = max(range(len(segment_scores)), key=lambda i: segment_scores[i])\n        segment_start = worst_segment_idx\n        segment_end = worst_segment_idx + 2\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] not in new_solution[segment_start:segment_end+1]:\n                candidates.append(new_solution[i])\n\n        if len(candidates) >= 2:\n            # Select 2 random nodes to insert\n            a, b = random.sample(candidates, 2)\n\n            # Insert new path\n            new_path = np.concatenate([\n                new_solution[:segment_start+1],\n                [a, b],\n                new_solution[segment_end:]\n            ])\n\n            # Ensure no duplicates\n            if len(np.unique(new_path)) == n:\n                new_solution = new_path\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7075465048263649,
            1.7994516491889954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical segments\n    segment_scores = []\n    for i in range(n-2):\n        segment = new_solution[i:i+3]\n        cost1 = distance_matrix_1[segment[0], segment[1]] + distance_matrix_1[segment[1], segment[2]]\n        cost2 = distance_matrix_2[segment[0], segment[1]] + distance_matrix_2[segment[1], segment[2]]\n        cost3 = distance_matrix_3[segment[0], segment[1]] + distance_matrix_3[segment[1], segment[2]]\n        score = cost1 + cost2 + cost3\n        segment_scores.append(score)\n\n    if segment_scores:\n        # Select worst segment to replace\n        worst_segment_idx = max(range(len(segment_scores)), key=lambda i: segment_scores[i])\n        segment_start = worst_segment_idx\n        segment_end = worst_segment_idx + 2\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] not in new_solution[segment_start:segment_end+1]:\n                candidates.append(new_solution[i])\n\n        if len(candidates) >= 2:\n            # Select 2 random nodes to insert\n            a, b = random.sample(candidates, 2)\n\n            # Insert new path\n            new_path = np.concatenate([\n                new_solution[:segment_start+1],\n                [a, b],\n                new_solution[segment_end:]\n            ])\n\n            # Ensure no duplicates\n            if len(np.unique(new_path)) == n:\n                new_solution = new_path\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6709344270298955,
            0.5591939449310303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges in the tour based on their contributions across all objectives with dynamically adjusted weights and performs crossover by replacing sub-tours with alternative paths while dynamically adjusting edge priorities based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify critical edges\n    edge_scores = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        edge_scores.append(score)\n\n    # Select edge to replace\n    if edge_scores:\n        worst_edge_idx = max(range(len(edge_scores)), key=lambda i: edge_scores[i])\n        u, v = new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]\n\n        # Find alternative path\n        candidates = []\n        for i in range(n):\n            if new_solution[i] != u and new_solution[i] != v:\n                candidates.append(new_solution[i])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace sub-tour\n            new_solution[worst_edge_idx+1] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This new algorithm employs a dynamic multi-objective 2-opt* local search with adaptive objective-aware segment selection, where it identifies and replaces segments of the tour based on their weighted contributions across objectives, dynamically adjusting segment priorities to balance exploration and exploitation while ensuring feasibility and promoting diverse improvements across all dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify segments to potentially replace\n    segment_scores = []\n    for i in range(n-2):\n        u, v, w = new_solution[i], new_solution[i+1], new_solution[i+2]\n        cost1 = distance_matrix_1[u, v] + distance_matrix_1[v, w] - distance_matrix_1[u, w]\n        cost2 = distance_matrix_2[u, v] + distance_matrix_2[v, w] - distance_matrix_2[u, w]\n        cost3 = distance_matrix_3[u, v] + distance_matrix_3[v, w] - distance_matrix_3[u, w]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_scores.append(score)\n\n    # Select segment to replace\n    if segment_scores:\n        worst_segment_idx = max(range(len(segment_scores)), key=lambda i: segment_scores[i])\n        i, j = worst_segment_idx, worst_segment_idx + 2\n\n        # Find alternative path\n        candidates = []\n        for k in range(n):\n            if new_solution[k] not in [new_solution[i], new_solution[j]]:\n                candidates.append(new_solution[k])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace segment with new node\n            new_solution[j] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6835128451004544,
            0.6324974298477173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Identify segments to potentially replace\n    segment_scores = []\n    for i in range(n-2):\n        u, v, w = new_solution[i], new_solution[i+1], new_solution[i+2]\n        cost1 = distance_matrix_1[u, v] + distance_matrix_1[v, w] - distance_matrix_1[u, w]\n        cost2 = distance_matrix_2[u, v] + distance_matrix_2[v, w] - distance_matrix_2[u, w]\n        cost3 = distance_matrix_3[u, v] + distance_matrix_3[v, w] - distance_matrix_3[u, w]\n        score = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_scores.append(score)\n\n    # Select segment to replace\n    if segment_scores:\n        worst_segment_idx = max(range(len(segment_scores)), key=lambda i: segment_scores[i])\n        i, j = worst_segment_idx, worst_segment_idx + 2\n\n        # Find alternative path\n        candidates = []\n        for k in range(n):\n            if new_solution[k] not in [new_solution[i], new_solution[j]]:\n                candidates.append(new_solution[k])\n\n        if candidates:\n            w = random.choice(candidates)\n            # Replace segment with new node\n            new_solution[j] = w\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This new algorithm employs an adaptive multi-objective edge-based crossover with dynamic objective-aware edge selection, where it identifies critical edges based on their weighted contributions across all objectives, performs crossover by swapping edges while dynamically adjusting edge weights based on their impact on multiple objectives, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    def edge_weight(u, v):\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    critical_edges = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        critical_edges.append((edge_weight(u, v), i))\n\n    critical_edges.sort(reverse=True)\n    top_edges = [idx for _, idx in critical_edges[:max(2, n//5)]]\n\n    if random.random() < 0.7:\n        for idx in top_edges:\n            if idx + 2 < n:\n                new_solution[idx+1], new_solution[idx+2] = new_solution[idx+2], new_solution[idx+1]\n    else:\n        for idx in top_edges:\n            if idx + 3 < n:\n                temp = new_solution[idx+1:idx+4]\n                random.shuffle(temp)\n                new_solution[idx+1:idx+4] = temp\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6594308828404404,
            0.40210781097412107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    def edge_weight(u, v):\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    critical_edges = []\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        critical_edges.append((edge_weight(u, v), i))\n\n    critical_edges.sort(reverse=True)\n    top_edges = [idx for _, idx in critical_edges[:max(2, n//5)]]\n\n    if random.random() < 0.7:\n        for idx in top_edges:\n            if idx + 2 < n:\n                new_solution[idx+1], new_solution[idx+2] = new_solution[idx+2], new_solution[idx+1]\n    else:\n        for idx in top_edges:\n            if idx + 3 < n:\n                temp = new_solution[idx+1:idx+4]\n                random.shuffle(temp)\n                new_solution[idx+1:idx+4] = temp\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Reverse segments\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7055027814640147,
            0.5888056516647339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    if random.random() < 0.5:\n        segments = [seg1, seg2, seg3]\n        segments[best_seg_idx] = segments[best_seg_idx][::-1]\n        segments[worst_seg_idx] = segments[worst_seg_idx][::-1]\n        new_solution = np.concatenate(segments)\n    else:\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    }
]