[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly select a segment to reverse if it improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Revert reversal if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7657823101995268,
            4.280471789836883
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, objectives = min(archive, key=lambda x: max(x[1]))\n\n    # Determine the objective with the highest value (most critical)\n    worst_obj_index = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_index]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform a segment reversal and node insertion to improve the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Find the best insertion point for a randomly selected node to improve the worst objective\n    node_to_insert = random.choice(new_solution)\n    best_insert_pos = i\n    best_insert_cost = float('inf')\n\n    for pos in range(n):\n        if pos == i:\n            continue  # Skip the current position to avoid unnecessary checks\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        temp_solution = np.delete(temp_solution, i if pos > i else i + 1)\n        cost = sum(distance_matrix[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        if cost < best_insert_cost:\n            best_insert_cost = cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n    new_solution = np.delete(new_solution, i if best_insert_pos > i else i + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7531815614756967,
            3.5943554282188415
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7188114819116691,
            1.8188122510910034
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the objective space, then generates a neighbor by performing a multi-objective-aware edge insertion and deletion operation, ensuring feasibility while potentially improving all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (can be adjusted)\n    base_solution, _ = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Find the longest edge in any of the objective spaces\n    def edge_lengths(solution, matrix):\n        return [matrix[solution[i-1], solution[i]] for i in range(n)]\n\n    edges1 = edge_lengths(new_solution, distance_matrix_1)\n    edges2 = edge_lengths(new_solution, distance_matrix_2)\n    edges3 = edge_lengths(new_solution, distance_matrix_3)\n\n    # Find the index of the longest edge in any space\n    max_edge_idx = max(range(n), key=lambda i: max(edges1[i], edges2[i], edges3[i]))\n\n    # Remove the longest edge and insert it in a new position\n    node_a = new_solution[max_edge_idx - 1]\n    node_b = new_solution[max_edge_idx]\n\n    # Insert node_b after a random node (but not node_a) to maintain feasibility\n    insertion_pos = random.choice([i for i in range(n) if new_solution[i] != node_a and new_solution[i] != node_b])\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos + 1],\n        np.array([node_b]),\n        new_solution[insertion_pos + 1:max_edge_idx],\n        new_solution[max_edge_idx + 1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.726831508208732,
            2.772015929222107
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a 3-opt local search to improve the solution\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segments between i-j, j-k, and i-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Randomly perturb the solution by swapping a pair of nodes if it improves any objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7442115378482151,
            3.685063374042511
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / 3)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply a novel local search operator: reverse a randomly selected segment and then insert a randomly selected node at a new position\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6929967606433114,
            3.1458989500999452
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = max(obj) - min(obj)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with random segment reversal and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.47594604996023904,
            3.3994994044303892
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the average of its objectives, then applies a novel 3-segment rotation operator that cyclically shifts three randomly selected segments of the tour to create a neighbor solution, ensuring feasibility and potentially improving multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three distinct positions for segment rotation\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Split the tour into three segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Rotate the segments cyclically\n    new_solution = np.concatenate([segment2, segment3, segment4, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6570624236444197,
            4.243347227573395
        ]
    }
]