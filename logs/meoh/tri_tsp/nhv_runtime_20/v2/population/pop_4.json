[
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7836454933963461,
            3.2404825925827025
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8113602972863486,
            3.2665385484695433
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{This algorithm combines multi-objective-aware segment swapping with adaptive objective-specific perturbations to explore the solution space while maintaining feasibility, using a biased selection of solutions based on objective diversity and a novel perturbation strategy that considers the relative importance of each objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform segment swap with objective awareness\n    segment_size = random.randint(2, min(4, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    # Swap segments\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Apply objective-specific perturbation\n    obj_weights = np.random.dirichlet(np.ones(3))\n    for i in range(3):\n        if random.random() < obj_weights[i]:\n            # Select nodes with high distance in this objective\n            distances = [distance_matrix_1, distance_matrix_2, distance_matrix_3][i]\n            node_pairs = [(new_solution[(j-1)%n], new_solution[j]) for j in range(n)]\n            pair_distances = [distances[a][b] for a, b in node_pairs]\n            if len(pair_distances) > 0:\n                max_dist_idx = np.argmax(pair_distances)\n                # Swap nodes in the high-distance pair\n                new_solution[max_dist_idx], new_solution[(max_dist_idx+1)%n] = new_solution[(max_dist_idx+1)%n], new_solution[max_dist_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6559690422852045,
            1.563647198677063
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 to balance exploration and exploitation\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps to balance objectives\n    for _ in range(3):  # Limit the number of swaps\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]])\n        if new_dist < old_dist:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7188114819116691,
            1.8188122510910034
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7897195935913786,
            3.2829968333244324
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))  # Keep segment size small for local improvement\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7997607720801532,
            3.6680373191833495
        ]
    },
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a hybrid local search combining 3-opt and edge insertion, followed by a random perturbation to explore new configurations while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a hybrid local search combining 3-opt and edge swaps\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly swap two edges to explore new configurations\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Random perturbation: randomly shift a segment of the tour\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    segment = new_solution[start:end]\n    np.random.shuffle(segment)\n    new_solution[start:end] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7595891270828317,
            3.230099391937256
        ]
    }
]