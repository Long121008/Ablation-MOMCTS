[
    {
        "algorithm": "{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.748700524915218,
            0.6126219034194946
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8113602972863486,
            3.2665385484695433
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7836454933963461,
            3.2404825925827025
        ]
    },
    {
        "algorithm": "{This algorithm uses a combination of adaptive objective-focused segment swapping and dynamic perturbation intensity to generate diverse neighbors while maintaining feasibility, leveraging a selection mechanism that prioritizes solutions with balanced objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    improvement_scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform adaptive segment swap\n    segment_size = random.randint(1, min(5, n//3))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Dynamic perturbation intensity\n    perturbation_intensity = random.uniform(0.3, 0.7)\n    for _ in range(int(perturbation_intensity * n)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6940297670505741,
            1.1457605242729187
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective-aware two-opt-inspired operator that selectively applies segment inversions based on their potential to simultaneously improve all three objectives, combined with a dynamic segment selection mechanism that adapts to the current solution's objective profile, ensuring balanced exploration of the search space while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = min(archive, key=lambda x: (max(x[1]) - min(x[1])) / sum(x[1]))\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective balance\n    segment_size = n // 4\n    if segment_size < 2:\n        segment_size = 2\n\n    # Evaluate potential segments for inversion\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate original and inverted segment costs\n        orig_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        orig_cost3 = sum(distance_matrix_3[segment[j-1], segment[j]] for j in range(1, len(segment)))\n\n        inverted_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost2 = sum(distance_matrix_2[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n        inv_cost3 = sum(distance_matrix_3[inverted_segment[j-1], inverted_segment[j]] for j in range(1, len(inverted_segment)))\n\n        # Apply inversion if it improves all objectives\n        if (inv_cost1 < orig_cost1 and inv_cost2 < orig_cost2 and inv_cost3 < orig_cost3):\n            new_solution[i:i+segment_size] = inverted_segment\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.736506833921203,
            1.2021115303039551
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment relocation with multi-objective evaluation\n    if n >= 4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j]\n\n        # Evaluate insertion points\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(1, n-1):\n            if pos >= i and pos <= j:\n                continue\n\n            # Temporarily insert segment at pos\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            temp_solution = np.concatenate([temp_solution[:i], temp_solution[j:]])\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n                sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n                sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            ]\n\n            # Calculate improvement (negative if worse)\n            improvement = sum(new_costs) - sum(archive[0][1])\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Probabilistic edge exchange\n    if n >= 3:\n        a, b = random.sample(range(1, n-1), 2)\n        original_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[a], new_solution[a+1]),\n            (new_solution[b-1], new_solution[b]),\n            (new_solution[b], new_solution[b+1])\n        ]\n\n        # Calculate original costs\n        original_costs = [\n            sum(distance_matrix_1[u, v] for u, v in original_edges),\n            sum(distance_matrix_2[u, v] for u, v in original_edges),\n            sum(distance_matrix_3[u, v] for u, v in original_edges)\n        ]\n\n        # Swap edges\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[a], new_solution[a+1]),\n            (new_solution[b-1], new_solution[b]),\n            (new_solution[b], new_solution[b+1])\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[u, v] for u, v in new_edges),\n            sum(distance_matrix_2[u, v] for u, v in new_edges),\n            sum(distance_matrix_3[u, v] for u, v in new_edges)\n        ]\n\n        # Revert if no improvement in any objective\n        if all(new_cost >= orig_cost for new_cost, orig_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7706135972652566,
            3.0373866081237795
        ]
    },
    {
        "algorithm": "{This new algorithm combines a novel multi-objective path segmentation with adaptive segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective, and reverses segments that show potential for simultaneous improvement across all three objectives, while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]) - min(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment the tour into 3 parts\n    segment_size = n // 3\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:]\n    ]\n\n    # Evaluate each segment's contribution to each objective\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Identify segments that could improve all objectives when reversed\n    for i in range(3):\n        seg = segments[i]\n        reversed_seg = seg[::-1]\n        rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n        rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n\n        # If reversing improves all objectives, apply the change\n        if (rev_cost1 < segment_costs[i][0] and\n            rev_cost2 < segment_costs[i][1] and\n            rev_cost3 < segment_costs[i][2]):\n            segments[i] = reversed_seg\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6081383806265657,
            0.9583791732788086
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8113602972863486,
            3.2665385484695433
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7836454933963461,
            3.2404825925827025
        ]
    },
    {
        "algorithm": "{This new algorithm combines a novel multi-objective adaptive segment swapping with dynamic objective-weighted segment reversal, where it intelligently partitions the tour into segments, evaluates their contributions to each objective with dynamic weights, and reverses or swaps segments based on weighted improvements across all three objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour into 4 parts\n    segment_size = n // 4\n    segments = [\n        new_solution[:segment_size],\n        new_solution[segment_size:2*segment_size],\n        new_solution[2*segment_size:3*segment_size],\n        new_solution[3*segment_size:]\n    ]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst segment to potentially improve\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Try reversing the worst segment\n    worst_seg = segments[worst_seg_idx]\n    reversed_seg = worst_seg[::-1]\n    rev_cost1 = sum(distance_matrix_1[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost2 = sum(distance_matrix_2[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_cost3 = sum(distance_matrix_3[reversed_seg[j-1], reversed_seg[j]] for j in range(len(reversed_seg)))\n    rev_weighted_cost = weights[0]*rev_cost1 + weights[1]*rev_cost2 + weights[2]*rev_cost3\n\n    if rev_weighted_cost < segment_costs[worst_seg_idx][3]:\n        segments[worst_seg_idx] = reversed_seg\n\n    # Try swapping two segments\n    i, j = random.sample(range(len(segments)), 2)\n    temp = segments[i].copy()\n    segments[i] = segments[j]\n    segments[j] = temp\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.748700524915218,
            0.6126219034194946
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7836454933963461,
            3.2404825925827025
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8113602972863486,
            3.2665385484695433
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node swapping and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment rotation\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        segment = new_solution[start:end+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8113602972863486,
            3.2665385484695433
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then generates a neighbor by performing a multi-objective-aware segment inversion and relocation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n\n    # Invert the selected segment\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Randomly select another segment to relocate\n    reloc_start = random.randint(0, n - 2)\n    reloc_end = random.randint(reloc_start + 1, min(reloc_start + 2, n - 1))\n\n    # Move this segment to a new position\n    segment_to_move = new_solution[reloc_start:reloc_end+1]\n    new_solution = np.concatenate([\n        new_solution[:reloc_start],\n        new_solution[reloc_end+1:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7836454933963461,
            3.2404825925827025
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution, _ = max(archive, key=lambda x: -sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform a 3-opt local search for multi-objective optimization\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node to explore new configurations\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788986973792207,
            2.7285127520561216
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    }
]