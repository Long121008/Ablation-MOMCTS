[
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8685804771441283,
            2.7185657024383545
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional node reinsertion with adaptive segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster nodes based on their positions in all three spaces\n    clusters = []\n    for i in range(0, n, 3):\n        clusters.append(new_solution[i:i+3])\n\n    # Shuffle clusters to explore different configurations\n    random.shuffle(clusters)\n    new_solution = np.concatenate(clusters)\n\n    # Perform adaptive segment reversal\n    for _ in range(2):\n        i = random.randint(0, len(clusters) - 1)\n        cluster = clusters[i]\n\n        # Reverse the cluster in one of the three spaces\n        space = random.randint(1, 3)\n        if space == 1:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_1[cluster[0], x])\n        elif space == 2:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_2[cluster[0], x])\n        else:\n            cluster_order = sorted(cluster, key=lambda x: distance_matrix_3[cluster[0], x])\n\n        # Randomly decide to reverse or not\n        if random.random() < 0.7:\n            cluster_order = cluster_order[::-1]\n\n        clusters[i] = cluster_order\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(clusters)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6815072479007493,
            0.39972691535949706
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes if it improves at least one objective\n    a, b = random.sample(range(n), 2)\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Swap nodes a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Calculate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # Revert swap if it doesn't improve any objective\n    if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7496025283943377,
            1.7068828344345093
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution structure, then generates a neighbor by performing a multi-objective-aware node insertion and segment reversal, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform node insertion\n    if n >= 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Perform segment reversal\n    if n >= 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, min(start + 2, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8350307492651485,
            2.202926051616669
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that combines a novel hybrid of 4-opt and objective-driven edge swapping, with dynamic segment reinsertion and Pareto-dominance guided selection to balance improvements across all three objectives while maintaining tour feasibility through constrained node permutations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.array([])\n\n    # Select solution with best overall improvement potential\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[1]) / max(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        # Simple swap for small tours\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply 4-opt move with constrained segment reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reconstruct solution with segments reversed and reinserted\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2[::-1],\n        new_solution[b+1:c],\n        segment1[::-1],\n        new_solution[d+1:]\n    ])\n\n    # Calculate original and new costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    # Perform objective-driven edge swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves and not dominated\n        if (any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)) and\n            not all(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs))):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8365967435911348,
            2.372413969039917
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8685804771441283,
            2.7185657024383545
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8685804771441283,
            2.7185657024383545
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8685804771441283,
            2.7185657024383545
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8685804771441283,
            2.7185657024383545
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that intelligently selects solutions from the archive, applies a hybrid of 2-opt and objective-driven segment reversal, and evaluates improvements across all three objectives while ensuring feasibility through dynamic node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, base_obj = max(archive, key=lambda x: min(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply 2-opt move with segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform objective-driven segment reversal\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse segment and evaluate\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[temp_solution[l-1], temp_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[temp_solution[l-1], temp_solution[l]] for l in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n            original_costs = new_costs\n\n    return new_solution\n\n",
        "score": [
            -0.8685804771441283,
            2.7185657024383545
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive k-exchange neighborhood with dynamic objective-aware segment insertion, where it intelligently partitions the tour into k segments, evaluates their contributions across all objectives with dynamic weights, and performs k-exchange operations between segments while inserting or merging segments based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine k for k-exchange (random between 2 and 4)\n    k = random.randint(2, 4)\n    segment_size = max(1, n // k)\n\n    # Partition the tour into k segments\n    segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(k)]\n\n    # Evaluate each segment's weighted contribution\n    segment_costs = []\n    for seg in segments:\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        segment_costs.append((cost1, cost2, cost3, weighted_cost))\n\n    # Find the worst and best segments\n    worst_seg_idx = max(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n    best_seg_idx = min(range(len(segment_costs)), key=lambda i: segment_costs[i][3])\n\n    # Perform k-exchange: swap worst segment with best segment\n    segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n\n    # Randomly decide to insert or merge segments\n    if random.random() < 0.5 and len(segments) > 2:\n        # Insert a random segment between two others\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n        segments.insert(j, segments.pop(i))\n    else:\n        # Merge two random segments\n        i, j = sorted(random.sample(range(len(segments)), 2))\n        segments[i] = np.concatenate([segments[i], segments[j]])\n        segments.pop(j)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7753210497397391,
            0.5590757250785827
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    }
]