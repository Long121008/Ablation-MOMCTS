[
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7575080658931472,
            0.37191160917282107
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7769515442322067,
            0.5529865026473999
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial clustering, then generates a neighbor by performing a multi-dimensional 2-opt exchange with adaptive segment swapping, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt exchange\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment swapping\n    if random.random() < 0.5:\n        k = random.randint(1, n//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7231738685518546,
            0.3247414231300354
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour decomposition and reassembly strategy that dynamically partitions the solution into objective-aware sub-tours, evaluates their contributions across all objectives with adaptive weights, and performs sub-tour rotations and inversions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    sub_tours = []\n    current_sub_tour = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        if random.random() < 0.6 and len(current_sub_tour) < 4:\n            current_sub_tour.append(node)\n        else:\n            sub_tours.append(current_sub_tour)\n            current_sub_tour = [node]\n\n    if current_sub_tour:\n        sub_tours.append(current_sub_tour)\n\n    if len(sub_tours) > 1:\n        i, j = random.sample(range(len(sub_tours)), 2)\n\n        if random.random() < 0.4:\n            sub_tours[i], sub_tours[j] = sub_tours[j], sub_tours[i]\n        else:\n            sub_tours[i] = sub_tours[i] + sub_tours[j]\n            sub_tours.pop(j)\n\n    new_solution = []\n    for sub_tour in sub_tours:\n        if random.random() < 0.5 and len(sub_tour) > 2:\n            k = random.randint(1, len(sub_tour)-1)\n            sub_tour = sub_tour[k:] + sub_tour[:k]\n        if random.random() < 0.3 and len(sub_tour) > 1:\n            sub_tour = sub_tour[::-1]\n        new_solution.extend(sub_tour)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7421125054124592,
            0.46006319522857664
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7575080658931472,
            0.37191160917282107
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7769515442322067,
            0.5529865026473999
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7575080658931472,
            0.37191160917282107
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and spatial centrality, then generates a neighbor by performing a multi-dimensional edge swap with adaptive path inversion, ensuring feasibility while potentially improving all three objectives through a balance of local refinement and global exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (max(x[1]) - min(x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional edge swap\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7769515442322067,
            0.5529865026473999
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7575080658931472,
            0.37191160917282107
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment-based crossover with dynamic objective-aware segment selection, where it partitions the tour into segments, evaluates their contributions across all objectives with dynamically adjusted weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover with higher probability of merge-split\n    if random.random() < 0.5:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments with dynamic split point\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7575080658931472,
            0.37191160917282107
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and recombination strategy that dynamically partitions the solution into objective-specific segments, evaluates their contributions across all objectives with adaptive weights, and performs segment-wise swaps and insertions while ensuring feasibility through a novel circular permutation mechanism that preserves tour continuity and optimizes for all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective weights based on current solution's performance\n    obj_values = objectives\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Segment the tour based on objective contributions\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate contribution to each objective\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n        cost3 = distance_matrix_3[prev_node, node]\n        weighted_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n        # Decide whether to continue current segment or start a new one\n        if random.random() < 0.7 and len(current_segment) < 3:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Perform segment-wise operations\n    if len(segments) > 1:\n        # Randomly select two segments to swap or merge\n        i, j = random.sample(range(len(segments)), 2)\n\n        if random.random() < 0.5:\n            # Swap segments\n            segments[i], segments[j] = segments[j], segments[i]\n        else:\n            # Merge segments\n            segments[i] = segments[i] + segments[j]\n            segments.pop(j)\n\n    # Rebuild the solution with circular permutation\n    new_solution = []\n    for seg in segments:\n        if random.random() < 0.3 and len(seg) > 2:\n            # Apply circular permutation to segment\n            k = random.randint(1, len(seg)-1)\n            seg = seg[k:] + seg[:k]\n        new_solution.extend(seg)\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6868022962685265,
            0.25402103662490844
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective balance and solution structure, then generates a neighbor by performing a multi-objective-aware node swap and segment rotation, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Perform multi-objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Accept swap if it improves any objective\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[i]]\n    ]\n\n    new_costs = [\n        distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[(i+1)%n], temp_solution[i]],\n        distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[(i+1)%n], temp_solution[i]]\n    ]\n\n    if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution = temp_solution\n\n    # Perform segment rotation\n    if n >= 4:\n        k = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            -0.8873933197402302,
            2.2875623226165773
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive segment-based crossover with dynamic objective-aware segment selection, where it intelligently partitions the tour into segments, evaluates their contributions across all objectives with dynamic weights, and performs crossover between selected segments while dynamically adjusting segment boundaries based on weighted improvements, ensuring feasibility and promoting diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic weights based on current solution's objective values\n    obj_values = archive[0][1]\n    total = sum(obj_values)\n    weights = [obj / total for obj in obj_values] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment boundaries\n    segment_points = sorted(random.sample(range(1, n-1), 2))\n    seg1_start, seg1_end, seg2_end = 0, segment_points[0], segment_points[1]\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg1_end:seg2_end]\n    seg3 = new_solution[seg2_end:]\n\n    # Evaluate segments\n    def evaluate_segment(seg):\n        cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i-1], seg[i]] for i in range(len(seg)))\n        return weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n\n    seg_costs = [evaluate_segment(seg) for seg in [seg1, seg2, seg3]]\n\n    # Select segments for crossover\n    best_seg_idx = min(range(3), key=lambda i: seg_costs[i])\n    worst_seg_idx = max(range(3), key=lambda i: seg_costs[i])\n\n    # Perform segment-based crossover\n    if random.random() < 0.7:\n        # Swap segments\n        segments = [seg1, seg2, seg3]\n        segments[worst_seg_idx], segments[best_seg_idx] = segments[best_seg_idx], segments[worst_seg_idx]\n        new_solution = np.concatenate(segments)\n    else:\n        # Merge and split segments\n        merged = np.concatenate([seg1, seg2, seg3])\n        split_point = random.randint(1, n-2)\n        new_solution = np.concatenate([merged[:split_point], merged[split_point:]])\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7311697580843959,
            0.2953584313392639
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution structure, then generates a neighbor by performing a multi-objective-aware 2-opt move followed by a segment inversion, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform segment inversion\n    if n >= 4:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 3, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883315578351238,
            1.8846153140068054
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then generates a neighbor by performing a multi-segment swap and objective-aware node reordering, ensuring feasibility while potentially improving all three objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Perform multi-segment swap\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n\n    # Objective-aware node reordering\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential improvement\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_costs = [\n            distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]],\n            distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8393949301075224,
            2.021987271308899
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search algorithm that intelligently selects promising solutions from the archive, applies a hybrid of 3-opt and adaptive node swapping, and evaluates improvements across all three objectives before finalizing the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution, _ = min(archive, key=lambda x: max(x[1]))\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt move: select three distinct positions and reverse the middle segment\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate original costs\n    original_costs = [\n        sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n        sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n    ]\n\n    # Perform adaptive node swaps based on objective improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate new costs\n        new_costs = [\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)),\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n))\n        ]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9029666278648799,
            3.720578670501709
        ]
    }
]