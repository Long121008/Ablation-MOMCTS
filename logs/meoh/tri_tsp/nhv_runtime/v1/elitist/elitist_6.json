[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7953175966449583,
            0.4413440227508545
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n",
        "score": [
            -0.8020609514601988,
            1.1996041417121888
        ]
    },
    {
        "algorithm": "{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6487521269777595,
            0.25273447036743163
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 3-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7667865195344993,
            0.5162989020347595
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objectives, then applies a novel multi-objective path relinking operator that combines segments from the selected solution with segments from a randomly generated solution, followed by an objective-aware insertion heuristic to further optimize the solution across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution\n    random_solution = np.random.permutation(len(base_solution))\n\n    # Apply multi-objective path relinking\n    new_solution = []\n    n = len(base_solution)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(base_solution[i])\n        else:\n            new_solution.append(random_solution[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware insertion heuristic\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find best insertion position for the node\n        best_pos = i\n        best_cost = (distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[(i+1)%n]],\n                     distance_matrix_2[new_solution[(i-1)%n], node] + distance_matrix_2[node, new_solution[(i+1)%n]],\n                     distance_matrix_3[new_solution[(i-1)%n], node] + distance_matrix_3[node, new_solution[(i+1)%n]])\n\n        for pos in range(n):\n            if pos == i or pos == (i-1)%n or pos == (i+1)%n:\n                continue\n            cost = (distance_matrix_1[new_solution[(pos-1)%n], node] + distance_matrix_1[node, new_solution[pos]],\n                    distance_matrix_2[new_solution[(pos-1)%n], node] + distance_matrix_2[node, new_solution[pos]],\n                    distance_matrix_3[new_solution[(pos-1)%n], node] + distance_matrix_3[node, new_solution[pos]])\n            if any(new < old for new, old in zip(cost, best_cost)):\n                best_cost = cost\n                best_pos = pos\n\n        # Perform insertion if beneficial\n        if best_pos != i:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6737423671104347,
            0.3266602396965027
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7789831971774414,
            0.5182350397109985
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid 2-opt and edge-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.exp(-np.mean(normalized, axis=0))  # Weight inversely proportional to average normalized objective\n    scores = np.dot(normalized, weights)\n\n    # Select solution with probability proportional to score\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge-swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 2-opt swap\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n    else:\n        # Perform edge-swap if 2-opt doesn't help\n        if np.random.rand() < 0.3:  # 30% chance for edge-swap\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j and k != j and l != i:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.743317339197078,
            0.452105188369751
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7953175966449583,
            0.4413440227508545
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    }
]