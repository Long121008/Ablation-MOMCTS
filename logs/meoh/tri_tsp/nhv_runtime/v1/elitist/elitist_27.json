[
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective path segment exchange operator that combines non-dominated segments from two archive solutions while maintaining feasibility, followed by an objective-aware node insertion step to refine the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 4)\n    start_pos = random.randint(0, n - segment_length)\n\n    # Copy a segment from sol1\n    new_solution.extend(sol1[start_pos:start_pos+segment_length])\n\n    # Fill the remaining positions with nodes from sol2 not already in the new solution\n    remaining_nodes = [node for node in sol2 if node not in new_solution]\n    new_solution.extend(remaining_nodes)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware node insertion\n    for _ in range(5):  # Perform 5 insertion steps\n        i, j = sorted(random.sample(range(n), 2))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform node insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8040245511582083,
            0.34511393308639526
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This novel algorithm selects a solution from the archive with the best compromise between objectives, then applies a multi-objective-aware segment inversion where it dynamically balances improvements across all three objectives by prioritizing edges that show the most balanced improvement across objectives, followed by a probabilistic node reordering step that maintains feasibility while introducing controlled diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def compromise_score(obj):\n        return max(obj) - min(obj)\n\n    best_solution = min(archive, key=lambda x: compromise_score(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment inversion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate improvement balance\n        old_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[i]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[j]]),\n            (distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate improvement balance score\n        old_balance = [sum(c) for c in old_costs]\n        new_balance = [sum(c) for c in new_costs]\n        improvement = sum(old_balance) - sum(new_balance)\n\n        if improvement > 0 and np.random.rand() < 0.7:  # 70% chance to accept balanced improvement\n            new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reordering\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.5:  # 50% chance to perform swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8262146924677568,
            0.46992807388305663
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive with the best balance across all three objectives, then performs a multi-objective-aware node relocation that intelligently moves nodes between segments while prioritizing improvement in the most underperforming objective, followed by a segment inversion step to further optimize the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Perform multi-objective-aware node relocation\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate cost change for the most underperforming objective\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[i])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            # Perform relocation\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j+1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform segment inversion for further optimization\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7936362470453648,
            0.4110574245452881
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective path relinking approach that combines the best segments from two archive solutions while using a dominance-based selection criterion to guide the search, followed by an adaptive 3-opt local search that dynamically prioritizes objectives based on their current improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    parent1, parent2 = random.sample(archive, 2)\n    sol1, obj1 = parent1[0], parent1[1]\n    sol2, obj2 = parent2[0], parent2[1]\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n    used_nodes = set()\n\n    # Path relinking with dominance-based selection\n    for i in range(n):\n        if random.random() < 0.5:\n            candidate = sol1[i] if sol1[i] not in used_nodes else sol2[i] if sol2[i] not in used_nodes else -1\n        else:\n            candidate = sol2[i] if sol2[i] not in used_nodes else sol1[i] if sol1[i] not in used_nodes else -1\n\n        if candidate == -1:\n            remaining_nodes = list(set(range(n)) - used_nodes)\n            candidate = random.choice(remaining_nodes)\n\n        new_solution[i] = candidate\n        used_nodes.add(candidate)\n\n    # Adaptive 3-opt local search\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate current and potential costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]]\n        )\n\n        # Try all possible 3-opt moves\n        for move in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            a, b, c = move\n            temp_sol = new_solution.copy()\n            temp_sol[a], temp_sol[b], temp_sol[c] = temp_sol[b], temp_sol[c], temp_sol[a]\n\n            new_cost = (\n                distance_matrix_1[temp_sol[a], temp_sol[(a+1)%n]] + distance_matrix_1[temp_sol[b], temp_sol[(b+1)%n]] + distance_matrix_1[temp_sol[c], temp_sol[(c+1)%n]],\n                distance_matrix_2[temp_sol[a], temp_sol[(a+1)%n]] + distance_matrix_2[temp_sol[b], temp_sol[(b+1)%n]] + distance_matrix_2[temp_sol[c], temp_sol[(c+1)%n]],\n                distance_matrix_3[temp_sol[a], temp_sol[(a+1)%n]] + distance_matrix_3[temp_sol[b], temp_sol[(b+1)%n]] + distance_matrix_3[temp_sol[c], temp_sol[(c+1)%n]]\n            )\n\n            # Calculate improvement for each objective\n            improvements = [\n                current_cost[0] - new_cost[0],\n                current_cost[1] - new_cost[1],\n                current_cost[2] - new_cost[2]\n            ]\n\n            # Dynamic weight based on improvement potential\n            weights = [1.0, 1.0, 1.0]\n            if max(improvements) > 0:\n                dominant_obj = improvements.index(max(improvements))\n                weights[dominant_obj] = 2.0\n\n            total_improvement = sum(w * imp for w, imp in zip(weights, improvements))\n\n            if total_improvement > 0:\n                new_solution = temp_sol\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8191987159667125,
            0.5154118657112121
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective path segment exchange operator that combines non-dominated segments from two archive solutions while maintaining feasibility, followed by an objective-aware node insertion step to refine the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 4)\n    start_pos = random.randint(0, n - segment_length)\n\n    # Copy a segment from sol1\n    new_solution.extend(sol1[start_pos:start_pos+segment_length])\n\n    # Fill the remaining positions with nodes from sol2 not already in the new solution\n    remaining_nodes = [node for node in sol2 if node not in new_solution]\n    new_solution.extend(remaining_nodes)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware node insertion\n    for _ in range(5):  # Perform 5 insertion steps\n        i, j = sorted(random.sample(range(n), 2))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform node insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8040245511582083,
            0.34511393308639526
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This novel algorithm selects a solution from the archive with the best compromise between objectives, then applies a multi-objective-aware segment inversion where it dynamically balances improvements across all three objectives by prioritizing edges that show the most balanced improvement across objectives, followed by a probabilistic node reordering step that maintains feasibility while introducing controlled diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def compromise_score(obj):\n        return max(obj) - min(obj)\n\n    best_solution = min(archive, key=lambda x: compromise_score(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment inversion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate improvement balance\n        old_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[i]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[j]]),\n            (distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate improvement balance score\n        old_balance = [sum(c) for c in old_costs]\n        new_balance = [sum(c) for c in new_costs]\n        improvement = sum(old_balance) - sum(new_balance)\n\n        if improvement > 0 and np.random.rand() < 0.7:  # 70% chance to accept balanced improvement\n            new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reordering\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.5:  # 50% chance to perform swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8262146924677568,
            0.46992807388305663
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This novel algorithm selects a solution from the archive with the best compromise between objectives, then applies a multi-objective-aware segment inversion where it dynamically balances improvements across all three objectives by prioritizing edges that show the most balanced improvement across objectives, followed by a probabilistic node reordering step that maintains feasibility while introducing controlled diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def compromise_score(obj):\n        return max(obj) - min(obj)\n\n    best_solution = min(archive, key=lambda x: compromise_score(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment inversion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate improvement balance\n        old_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[i]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[j]]),\n            (distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate improvement balance score\n        old_balance = [sum(c) for c in old_costs]\n        new_balance = [sum(c) for c in new_costs]\n        improvement = sum(old_balance) - sum(new_balance)\n\n        if improvement > 0 and np.random.rand() < 0.7:  # 70% chance to accept balanced improvement\n            new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reordering\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.5:  # 50% chance to perform swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8262146924677568,
            0.46992807388305663
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective path segment exchange operator that combines non-dominated segments from two archive solutions while maintaining feasibility, followed by an objective-aware node insertion step to refine the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 4)\n    start_pos = random.randint(0, n - segment_length)\n\n    # Copy a segment from sol1\n    new_solution.extend(sol1[start_pos:start_pos+segment_length])\n\n    # Fill the remaining positions with nodes from sol2 not already in the new solution\n    remaining_nodes = [node for node in sol2 if node not in new_solution]\n    new_solution.extend(remaining_nodes)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware node insertion\n    for _ in range(5):  # Perform 5 insertion steps\n        i, j = sorted(random.sample(range(n), 2))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform node insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8040245511582083,
            0.34511393308639526
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This novel algorithm selects a solution from the archive with the best compromise between objectives, then applies a multi-objective-aware segment inversion where it dynamically balances improvements across all three objectives by prioritizing edges that show the most balanced improvement across objectives, followed by a probabilistic node reordering step that maintains feasibility while introducing controlled diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def compromise_score(obj):\n        return max(obj) - min(obj)\n\n    best_solution = min(archive, key=lambda x: compromise_score(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment inversion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate improvement balance\n        old_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[i]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[j]]),\n            (distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate improvement balance score\n        old_balance = [sum(c) for c in old_costs]\n        new_balance = [sum(c) for c in new_costs]\n        improvement = sum(old_balance) - sum(new_balance)\n\n        if improvement > 0 and np.random.rand() < 0.7:  # 70% chance to accept balanced improvement\n            new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reordering\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.5:  # 50% chance to perform swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8262146924677568,
            0.46992807388305663
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective-aware crossover operator that combines segments from the best and second-best solutions in the archive with a probabilistic selection based on Pareto dominance, followed by a dynamic edge refinement step that selectively improves edges with the most significant objective-specific improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) >= 2:\n        sol1, sol2 = archive[0][0], archive[1][0]\n        n = len(sol1)\n\n        # Create new solution with probabilistic crossover\n        new_solution = []\n        for i in range(n):\n            if np.random.random() < 0.7:  # Higher probability for better solution\n                new_solution.append(sol1[i])\n            else:\n                new_solution.append(sol2[i])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution.insert(insert_pos, node)\n\n        new_solution = np.array(new_solution)\n\n        # Dynamic edge refinement based on objective improvements\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                        distance_matrix_2[new_solution[i], new_solution[j]],\n                        distance_matrix_3[new_solution[i], new_solution[j]])\n\n            # Calculate improvement scores for each objective\n            improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n            total_improvement = sum(improvements)\n\n            # Apply 2-opt if significant improvement in any objective\n            if total_improvement > 0:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    else:\n        # Fallback to simple mutation if archive is small\n        new_solution = archive[0][0].copy()\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6823208354225547,
            0.126544189453125
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    }
]