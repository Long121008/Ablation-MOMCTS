[
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n",
        "score": [
            -7787.720528352528,
            0.36901015043258667
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7853.03067691646,
            1.5377792239189148
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n",
        "score": [
            -7816.6322728059795,
            1.1020054340362548
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D segment-shuffling and objective-biased edge-insertion operator, and ensures feasibility by preserving the TSP tour structure while dynamically balancing improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -7695.799031100536,
            0.4392615079879761
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on objective diversity and applies a novel 3D path optimization operator that combines edge swaps, segment reversals, and objective-aware node insertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -7703.440317649794,
            0.4500385165214539
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform a multi-objective edge insertion move\n    for _ in range(5):\n        # Randomly select two distinct edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Perform the insertion\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(base_solution)\n\n        # Accept if the solution is non-dominated or improves at least one objective\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            base_solution = new_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -7807.360617696031,
            1.3040217638015748
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D two-opt* operator with dynamic segment selection based on objective dominance, and ensures feasibility by maintaining the TSP tour structure while considering the trade-offs between objectives}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives (most balanced)\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = normalized.std(axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective dominance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 < obj2 and obj1 < obj3:\n        # Focus on first objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 < obj1 and obj2 < obj3:\n        # Focus on second objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Focus on third objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt* move for further improvement\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7788.1073385244745,
            1.1389009952545166
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt combined with a novel 3-objective-aware swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    worst_solution = archive[worst_obj][0].copy()\n\n    # Find the worst edge in the worst solution\n    worst_edge = None\n    max_distance = -1\n    for i in range(n):\n        u, v = worst_solution[i], worst_solution[(i + 1) % n]\n        total_dist = distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if total_dist > max_distance:\n            max_distance = total_dist\n            worst_edge = (i, (i + 1) % n)\n\n    # Perform 2-opt on the worst edge\n    if worst_edge:\n        i, j = worst_edge\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then apply a novel 3-objective-aware swap\n    # For each node, find the best swap that improves at least one objective\n    for i in range(n):\n        best_swap = None\n        best_improvement = 0\n\n        for j in range(i + 1, n):\n            # Calculate the change in all three objectives\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            old_dist3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_dist3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n            # Check if at least one objective improves\n            if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n                total_improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2) + (old_dist3 - new_dist3)\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_swap = j\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -7815.459342788238,
            2.0758976101875306
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search operator that considers all three objectives simultaneously, and ensures feasibility through careful edge-swapping and segment-reversal operations tailored to multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on a weighted sum of objectives (weights can be adjusted)\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    ranked_solutions = sorted(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    # Select the top 30% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or 2-opt with consideration for all three objectives\n    if np.random.random() < 0.6:  # Higher probability for edge-swap\n        # Edge-swap with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7779.9995118898705,
            1.2579894423484803
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7853.03067691646,
            1.5377792239189148
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n",
        "score": [
            -7787.720528352528,
            0.36901015043258667
        ]
    },
    {
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ]
    }
]