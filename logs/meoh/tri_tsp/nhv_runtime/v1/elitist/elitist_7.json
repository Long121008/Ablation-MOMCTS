[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances individual objective improvements and solution diversity, then applies a novel 4-opt local search with objective-aware edge selection and dynamic segment reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring more complex tour modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))  # Balance diversity and objective values\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i+1:l+1] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7460972722025783,
            0.4353316903114319
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8245367578593978,
            0.546731150150299
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7307172451307181,
            0.3655233263969421
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7953175966449583,
            0.4413440227508545
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8126371584141945,
            0.5375605702400208
        ]
    },
    {
        "algorithm": "{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6487521269777595,
            0.25273447036743163
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 4-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]\n    weights = [w / sum(weights) for w in weights]\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7528428789893651,
            0.4601970434188843
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7953175966449583,
            0.4413440227508545
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7307172451307181,
            0.3655233263969421
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8245367578593978,
            0.546731150150299
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances individual objective improvements and solution diversity, then applies a novel 4-opt local search with objective-aware edge selection and dynamic segment reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring more complex tour modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))  # Balance diversity and objective values\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i+1:l+1] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7460972722025783,
            0.4353316903114319
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8126371584141945,
            0.5375605702400208
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7953175966449583,
            0.4413440227508545
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    }
]