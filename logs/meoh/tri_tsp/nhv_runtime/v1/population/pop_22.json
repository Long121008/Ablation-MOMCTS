[
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive with the best balance across all three objectives, then performs a multi-objective-aware node relocation that intelligently moves nodes between segments while prioritizing improvement in the most underperforming objective, followed by a segment inversion step to further optimize the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Perform multi-objective-aware node relocation\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate cost change for the most underperforming objective\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[i])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            # Perform relocation\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j+1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform segment inversion for further optimization\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7936362470453648,
            0.4110574245452881
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8126371584141945,
            0.5375605702400208
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7857785219516787,
            0.3704549789428711
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8245367578593978,
            0.546731150150299
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    }
]