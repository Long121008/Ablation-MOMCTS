[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7925495345199637,
            0.5407833933830262
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n",
        "score": [
            -0.8020609514601988,
            1.1996041417121888
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7789831971774414,
            0.5182350397109985
        ]
    },
    {
        "algorithm": "{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6487521269777595,
            0.25273447036743163
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.7058426196712846,
            0.4203469634056091
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6585157508766472,
            0.2513168215751648
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7089536759190119,
            0.5115267157554626
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a 2-opt local search with a novel edge selection strategy that considers both individual objective improvements and combined multi-objective potential, and ensures the solution remains feasible while exploring diverse neighborhood structures.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, 3)\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i:j] = temp_solution[i:j][::-1]\n\n        # Evaluate multi-objective improvement potential\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # Accept if any objective improves or if combined improvement is significant\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)) or \\\n           sum(new_costs) < 0.98 * sum(current_costs):\n            new_solution = temp_solution\n\n        # Additional edge swap for multi-objective optimization\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Evaluate edge swap impact\n        current_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n])\n        ]\n\n        new_edges = [\n            (temp_solution[a], temp_solution[(a+1)%n]),\n            (temp_solution[b], temp_solution[(b+1)%n])\n        ]\n\n        edge_improvements = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_1[current_edges[0][0], current_edges[0][1]] - distance_matrix_1[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_2[current_edges[0][0], current_edges[0][1]] - distance_matrix_2[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_3[current_edges[0][0], current_edges[0][1]] - distance_matrix_3[current_edges[1][0], current_edges[1][1]]\n        ]\n\n        if any(improvement < 0 for improvement in edge_improvements):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8012330177850181,
            1.228614616394043
        ]
    }
]