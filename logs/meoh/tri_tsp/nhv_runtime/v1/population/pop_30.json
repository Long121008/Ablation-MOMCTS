[
    {
        "algorithm": "{This new algorithm employs a multi-objective segment exchange operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware insertion refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Select random segments from both solutions\n    start = np.random.randint(0, n)\n    length = np.random.randint(1, n//2 + 1)\n    end = (start + length) % n\n\n    # Extract segments\n    if start < end:\n        segment1 = sol1[start:end]\n        segment2 = sol2[start:end]\n    else:\n        segment1 = np.concatenate([sol1[start:], sol1[:end]])\n        segment2 = np.concatenate([sol2[start:], sol2[:end]])\n\n    # Create new solution by combining segments\n    new_solution = sol1.copy()\n    if start < end:\n        new_solution[start:end] = segment2\n    else:\n        new_solution[start:] = segment2[:n-start]\n        new_solution[:end] = segment2[n-start:]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply objective-aware insertion refinement\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]] +\n                    distance_matrix_3[new_solution[i], new_solution[j]] +\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.715340862530232,
            0.14152817726135253
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective path segment exchange operator that combines non-dominated segments from two archive solutions while maintaining feasibility, followed by an objective-aware node insertion step to refine the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 4)\n    start_pos = random.randint(0, n - segment_length)\n\n    # Copy a segment from sol1\n    new_solution.extend(sol1[start_pos:start_pos+segment_length])\n\n    # Fill the remaining positions with nodes from sol2 not already in the new solution\n    remaining_nodes = [node for node in sol2 if node not in new_solution]\n    new_solution.extend(remaining_nodes)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware node insertion\n    for _ in range(5):  # Perform 5 insertion steps\n        i, j = sorted(random.sample(range(n), 2))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform node insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8040245511582083,
            0.34511393308639526
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover operator that combines path segments from three archive solutions with adaptive segment selection based on objective dominance, followed by a hierarchical local search that first improves the least dominated objective and progressively refines the others.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) >= 3:\n        sol1, sol2, sol3 = random.sample(archive, 3)\n    else:\n        sol1, sol2 = random.sample(archive, 2)\n        sol3 = sol1\n    sol1, sol2, sol3 = sol1[0], sol2[0], sol3[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from all three solutions\n    new_solution = []\n    segment_length = max(2, n // 5)\n    start_pos = random.randint(0, n - segment_length)\n\n    # Alternate segments from the three solutions\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i % n])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i % n])\n        else:\n            new_solution.append(sol3[i % n])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Hierarchical local search\n    for obj in range(3):\n        for _ in range(3):  # Perform 3 improvements per objective\n            i, j = sorted(random.sample(range(n), 2))\n            if obj == 0:\n                old_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]]\n            elif obj == 1:\n                old_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]]\n            else:\n                old_cost = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                new_cost = distance_matrix_3[new_solution[i], new_solution[j]]\n\n            if new_cost < old_cost:\n                # Perform 2-opt swap\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6802442914332645,
            0.10534934997558594
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid approach combining a multi-objective segment crossover with a dominance-aware adaptive 2-opt local search, where solutions are prioritized based on their Pareto front position and dynamically adjusted weights for each objective during the local search phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    parent1, parent2 = random.sample(archive, 2)\n    sol1, obj1 = parent1[0], parent1[1]\n    sol2, obj2 = parent2[0], parent2[1]\n\n    # Determine Pareto dominance relationship\n    dominates = [False, False]\n    if all(o1 <= o2 for o1, o2 in zip(obj1, obj2)) and any(o1 < o2 for o1, o2 in zip(obj1, obj2)):\n        dominates[0] = True\n    if all(o2 <= o1 for o1, o2 in zip(obj1, obj2)) and any(o2 < o1 for o1, o2 in zip(obj1, obj2)):\n        dominates[1] = True\n\n    # Use the dominating solution as base if available\n    if dominates[0]:\n        base_solution = sol1.copy()\n    elif dominates[1]:\n        base_solution = sol2.copy()\n    else:\n        base_solution = sol1.copy() if random.random() < 0.5 else sol2.copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment crossover\n    start = random.randint(0, n-1)\n    length = random.randint(1, n//2)\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate((new_solution[start:], new_solution[:end]))\n\n    # Adaptive 2-opt local search with dynamic weights\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        temp_sol = new_solution.copy()\n        temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n\n        new_cost = (\n            distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] + distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]],\n            distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] + distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]],\n            distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] + distance_matrix_3[temp_sol[j], temp_sol[(j+1)%n]]\n        )\n\n        # Calculate improvement for each objective\n        improvements = [\n            current_cost[0] - new_cost[0],\n            current_cost[1] - new_cost[1],\n            current_cost[2] - new_cost[2]\n        ]\n\n        # Dynamic weight based on improvement potential\n        weights = [1.0, 1.0, 1.0]\n        if max(improvements) > 0:\n            dominant_obj = improvements.index(max(improvements))\n            weights[dominant_obj] = 1.5\n\n        total_improvement = sum(w * imp for w, imp in zip(weights, improvements))\n\n        if total_improvement > 0:\n            new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            -0.858742296869992,
            0.4167145609855652
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective segment crossover operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware 3-opt refinement step that prioritizes improving the worst-performing objective in each iteration, using a dynamic weighting scheme based on current solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution by combining segments with dynamic selection\n    new_solution = []\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware 3-opt refinement\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Try all 3-opt configurations\n        configurations = [\n            (i, j, k, [new_solution[i], new_solution[j], new_solution[k], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n]]),\n            (i, j, k, [new_solution[i], new_solution[k], new_solution[j], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n]]),\n            (i, j, k, [new_solution[i], new_solution[j], new_solution[(i+1)%n], new_solution[k], new_solution[(j+1)%n], new_solution[(k+1)%n]]),\n            (i, j, k, [new_solution[i], new_solution[k], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n], new_solution[(k+1)%n]])\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            _, _, _, nodes = config\n            new_cost = (distance_matrix_1[nodes[0], nodes[1]] + distance_matrix_2[nodes[0], nodes[1]] + distance_matrix_3[nodes[0], nodes[1]],\n                        distance_matrix_1[nodes[2], nodes[3]] + distance_matrix_2[nodes[2], nodes[3]] + distance_matrix_3[nodes[2], nodes[3]],\n                        distance_matrix_1[nodes[4], nodes[5]] + distance_matrix_2[nodes[4], nodes[5]] + distance_matrix_3[nodes[4], nodes[5]])\n\n            # Calculate improvement (prioritize worst objective)\n            improvement = min(current_cost[obj] - new_cost[obj] for obj in range(3))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            _, _, _, nodes = best_config\n            # Apply the best configuration\n            new_solution[i] = nodes[0]\n            new_solution[j] = nodes[1]\n            new_solution[k] = nodes[2]\n            new_solution[(i+1)%n] = nodes[3]\n            new_solution[(j+1)%n] = nodes[4]\n            new_solution[(k+1)%n] = nodes[5]\n\n    return new_solution\n\n",
        "score": [
            -0.7369307701516145,
            0.22518953084945678
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective segment crossover operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware 2.5-opt refinement step that prioritizes improving the worst-performing objective in each iteration, using a dynamic weighting scheme based on current solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution by combining segments with dynamic selection\n    new_solution = []\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware 2.5-opt refinement\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]],\n                        distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # Try all 2.5-opt configurations\n        configurations = [\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[k], new_solution[l], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[k], new_solution[j], new_solution[l], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[l], new_solution[k], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[k], new_solution[l], new_solution[j], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]])\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            _, _, _, _, nodes = config\n            new_cost = (distance_matrix_1[nodes[0], nodes[1]] + distance_matrix_2[nodes[0], nodes[1]] + distance_matrix_3[nodes[0], nodes[1]],\n                        distance_matrix_1[nodes[2], nodes[3]] + distance_matrix_2[nodes[2], nodes[3]] + distance_matrix_3[nodes[2], nodes[3]],\n                        distance_matrix_1[nodes[4], nodes[5]] + distance_matrix_2[nodes[4], nodes[5]] + distance_matrix_3[nodes[4], nodes[5]],\n                        distance_matrix_1[nodes[6], nodes[7]] + distance_matrix_2[nodes[6], nodes[7]] + distance_matrix_3[nodes[6], nodes[7]])\n\n            # Calculate improvement (prioritize worst objective)\n            improvement = min(current_cost[obj] - new_cost[obj] for obj in range(4))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            _, _, _, _, nodes = best_config\n            # Apply the best configuration\n            new_solution[i] = nodes[0]\n            new_solution[j] = nodes[1]\n            new_solution[k] = nodes[2]\n            new_solution[l] = nodes[3]\n            new_solution[(i+1)%n] = nodes[4]\n            new_solution[(j+1)%n] = nodes[5]\n            new_solution[(k+1)%n] = nodes[6]\n            new_solution[(l+1)%n] = nodes[7]\n\n    return new_solution\n\n",
        "score": [
            -0.7403587053770553,
            0.3170604944229126
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ]
    },
    {
        "algorithm": "{This novel algorithm selects a solution from the archive with the best compromise between objectives, then applies a multi-objective-aware segment inversion where it dynamically balances improvements across all three objectives by prioritizing edges that show the most balanced improvement across objectives, followed by a probabilistic node reordering step that maintains feasibility while introducing controlled diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    def compromise_score(obj):\n        return max(obj) - min(obj)\n\n    best_solution = min(archive, key=lambda x: compromise_score(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment inversion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate improvement balance\n        old_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[i]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[i]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(i-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(i-1)%n], new_solution[j]]),\n            (distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate improvement balance score\n        old_balance = [sum(c) for c in old_costs]\n        new_balance = [sum(c) for c in new_costs]\n        improvement = sum(old_balance) - sum(new_balance)\n\n        if improvement > 0 and np.random.rand() < 0.7:  # 70% chance to accept balanced improvement\n            new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reordering\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.5:  # 50% chance to perform swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8262146924677568,
            0.46992807388305663
        ]
    }
]