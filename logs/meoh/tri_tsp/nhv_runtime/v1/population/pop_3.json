[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7925495345199637,
            0.5407833933830262
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7089536759190119,
            0.5115267157554626
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.7058426196712846,
            0.4203469634056091
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n",
        "score": [
            -0.8020609514601988,
            1.1996041417121888
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel \"multi-objective edge insertion\" heuristic that intelligently inserts nodes at positions that improve multiple objectives simultaneously, ensuring feasibility through careful edge replacement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives to compare across different scales\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Perform 3 insertion attempts\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost difference for all three objectives\n            prev_node = new_solution[(pos - 1) % n]\n            next_node = new_solution[pos % n]\n\n            old_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n\n            improvements = [old - new for old, new in zip(old_costs, new_costs)]\n            improvement_score = sum(1 for imp in improvements if imp > 0)\n\n            # Prefer positions that improve at least two objectives\n            if improvement_score >= 2 and sum(improvements) > best_improvement:\n                best_improvement = sum(improvements)\n                best_pos = pos\n\n        # Perform the insertion if beneficial\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7329742458545723,
            0.919282603263855
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6585157508766472,
            0.2513168215751648
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a multi-objective aware insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relocate\n    segment_length = random.randint(2, min(5, n // 3))\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Evaluate potential insertion points based on all three objectives\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for pos in range(len(new_solution) - segment_length + 1):\n        # Insert the segment at position pos\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate improvement for each objective\n        total_improvement = 0\n        for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            old_cost = sum(distance_matrix[selected_solution[k], selected_solution[k+1]] for k in range(n-1)) + distance_matrix[selected_solution[-1], selected_solution[0]]\n            new_cost = sum(distance_matrix[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix[candidate[-1], candidate[0]]\n            total_improvement += (old_cost - new_cost)\n\n        # Update best position if this is better\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_insert_pos = pos\n\n    # Perform the best insertion if found\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7165201049328347,
            1.1220825433731079
        ]
    },
    {
        "algorithm": "{This new algorithm combines a multi-objective selection criterion with a novel edge insertion operator that prioritizes diverse objective improvements while maintaining feasibility through a constrained insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Find the edge with highest combined objective cost\n    max_edge_cost = -1\n    max_edge_idx = -1\n    for i in range(n):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        total_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        if total_cost > max_edge_cost:\n            max_edge_cost = total_cost\n            max_edge_idx = i\n\n    if max_edge_idx != -1:\n        # Remove the worst edge\n        u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx+1)%n]\n        new_solution = np.concatenate([new_solution[:max_edge_idx+1], new_solution[max_edge_idx+2:]])\n\n        # Find insertion point that improves at least one objective\n        best_improvement = 0\n        best_insert_pos = -1\n        for i in range(len(new_solution)-1):\n            # Calculate potential insertion cost\n            cost1 = distance_matrix_1[new_solution[i], v] + distance_matrix_1[u, new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], v] + distance_matrix_2[u, new_solution[i+1]]\n            cost3 = distance_matrix_3[new_solution[i], v] + distance_matrix_3[u, new_solution[i+1]]\n\n            # Calculate original cost\n            orig_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            orig_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            orig_cost3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n\n            # Calculate improvement\n            imp1 = orig_cost1 - cost1\n            imp2 = orig_cost2 - cost2\n            imp3 = orig_cost3 - cost3\n\n            # Total weighted improvement\n            total_imp = weights[0]*imp1 + weights[1]*imp2 + weights[2]*imp3\n\n            if total_imp > best_improvement:\n                best_improvement = total_imp\n                best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Insert the nodes back in the best position\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos+1],\n                np.array([v, u]),\n                new_solution[best_insert_pos+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6722069221725123,
            0.4633386254310608
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n",
        "score": [
            -0.6051273741762091,
            0.40557374954223635
        ]
    }
]