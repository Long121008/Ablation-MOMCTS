[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective segment crossover operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware 2.5-opt refinement step that prioritizes improving the worst-performing objective in each iteration, using a dynamic weighting scheme based on current solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution by combining segments with dynamic selection\n    new_solution = []\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware 2.5-opt refinement\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]],\n                        distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # Try all 2.5-opt configurations\n        configurations = [\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[k], new_solution[l], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[k], new_solution[j], new_solution[l], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[l], new_solution[k], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[k], new_solution[l], new_solution[j], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]])\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            _, _, _, _, nodes = config\n            new_cost = (distance_matrix_1[nodes[0], nodes[1]] + distance_matrix_2[nodes[0], nodes[1]] + distance_matrix_3[nodes[0], nodes[1]],\n                        distance_matrix_1[nodes[2], nodes[3]] + distance_matrix_2[nodes[2], nodes[3]] + distance_matrix_3[nodes[2], nodes[3]],\n                        distance_matrix_1[nodes[4], nodes[5]] + distance_matrix_2[nodes[4], nodes[5]] + distance_matrix_3[nodes[4], nodes[5]],\n                        distance_matrix_1[nodes[6], nodes[7]] + distance_matrix_2[nodes[6], nodes[7]] + distance_matrix_3[nodes[6], nodes[7]])\n\n            # Calculate improvement (prioritize worst objective)\n            improvement = min(current_cost[obj] - new_cost[obj] for obj in range(4))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            _, _, _, _, nodes = best_config\n            # Apply the best configuration\n            new_solution[i] = nodes[0]\n            new_solution[j] = nodes[1]\n            new_solution[k] = nodes[2]\n            new_solution[l] = nodes[3]\n            new_solution[(i+1)%n] = nodes[4]\n            new_solution[(j+1)%n] = nodes[5]\n            new_solution[(k+1)%n] = nodes[6]\n            new_solution[(l+1)%n] = nodes[7]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid approach combining a multi-objective segment crossover with a dominance-aware adaptive 2-opt local search, where solutions are prioritized based on their Pareto front position and dynamically adjusted weights for each objective during the local search phase.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    parent1, parent2 = random.sample(archive, 2)\n    sol1, obj1 = parent1[0], parent1[1]\n    sol2, obj2 = parent2[0], parent2[1]\n\n    # Determine Pareto dominance relationship\n    dominates = [False, False]\n    if all(o1 <= o2 for o1, o2 in zip(obj1, obj2)) and any(o1 < o2 for o1, o2 in zip(obj1, obj2)):\n        dominates[0] = True\n    if all(o2 <= o1 for o1, o2 in zip(obj1, obj2)) and any(o2 < o1 for o1, o2 in zip(obj1, obj2)):\n        dominates[1] = True\n\n    # Use the dominating solution as base if available\n    if dominates[0]:\n        base_solution = sol1.copy()\n    elif dominates[1]:\n        base_solution = sol2.copy()\n    else:\n        base_solution = sol1.copy() if random.random() < 0.5 else sol2.copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment crossover\n    start = random.randint(0, n-1)\n    length = random.randint(1, n//2)\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate((new_solution[start:], new_solution[:end]))\n\n    # Adaptive 2-opt local search with dynamic weights\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        temp_sol = new_solution.copy()\n        temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n\n        new_cost = (\n            distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] + distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]],\n            distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] + distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]],\n            distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] + distance_matrix_3[temp_sol[j], temp_sol[(j+1)%n]]\n        )\n\n        # Calculate improvement for each objective\n        improvements = [\n            current_cost[0] - new_cost[0],\n            current_cost[1] - new_cost[1],\n            current_cost[2] - new_cost[2]\n        ]\n\n        # Dynamic weight based on improvement potential\n        weights = [1.0, 1.0, 1.0]\n        if max(improvements) > 0:\n            dominant_obj = improvements.index(max(improvements))\n            weights[dominant_obj] = 1.5\n\n        total_improvement = sum(w * imp for w, imp in zip(weights, improvements))\n\n        if total_improvement > 0:\n            new_solution = temp_sol\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This new algorithm employs a multi-objective adaptive 3-opt local search that dynamically selects the worst-performing objective in the current solution and applies a targeted 3-opt move to improve it, combined with a segment inversion operator that preserves the relative order of nodes in the worst-performing objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine the worst-performing objective\n    obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    worst_obj = 1 if obj1 >= obj2 and obj1 >= obj3 else (2 if obj2 >= obj1 and obj2 >= obj3 else 3)\n\n    # Apply adaptive 3-opt local search targeting the worst objective\n    for _ in range(5):\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Calculate current cost for the worst objective\n        if worst_obj == 1:\n            current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        elif worst_obj == 2:\n            current_cost = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n        else:\n            current_cost = (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Try all 3-opt configurations\n        configurations = [\n            [new_solution[i], new_solution[j], new_solution[k]],\n            [new_solution[i], new_solution[k], new_solution[j]],\n            [new_solution[j], new_solution[i], new_solution[k]],\n            [new_solution[j], new_solution[k], new_solution[i]],\n            [new_solution[k], new_solution[i], new_solution[j]],\n            [new_solution[k], new_solution[j], new_solution[i]]\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            # Calculate new cost for the worst objective\n            if worst_obj == 1:\n                new_cost = (distance_matrix_1[config[0], config[1]] +\n                            distance_matrix_1[config[1], config[2]] +\n                            distance_matrix_1[config[2], new_solution[(k+1)%n]])\n            elif worst_obj == 2:\n                new_cost = (distance_matrix_2[config[0], config[1]] +\n                            distance_matrix_2[config[1], config[2]] +\n                            distance_matrix_2[config[2], new_solution[(k+1)%n]])\n            else:\n                new_cost = (distance_matrix_3[config[0], config[1]] +\n                            distance_matrix_3[config[1], config[2]] +\n                            distance_matrix_3[config[2], new_solution[(k+1)%n]])\n\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            # Apply the best configuration\n            new_solution[i] = best_config[0]\n            new_solution[j] = best_config[1]\n            new_solution[k] = best_config[2]\n\n    # Apply segment inversion targeting the worst objective\n    start = random.randint(0, n-1)\n    length = random.randint(1, n//2)\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate((new_solution[start:], new_solution[:end]))\n\n    # Calculate segment cost in worst objective\n    if worst_obj == 1:\n        segment_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    elif worst_obj == 2:\n        segment_cost = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    else:\n        segment_cost = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert the segment if it improves the worst objective\n    inverted_segment = segment[::-1]\n    if worst_obj == 1:\n        inverted_cost = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    elif worst_obj == 2:\n        inverted_cost = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    else:\n        inverted_cost = sum(distance_matrix_3[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    if inverted_cost < segment_cost:\n        if start < end:\n            new_solution[start:end] = inverted_segment\n        else:\n            new_solution[start:] = inverted_segment[:n-start]\n            new_solution[:end] = inverted_segment[n-start:]\n\n    return new_solution\n\n",
        "score": [
            -0.6345161002501094,
            0.38585840463638305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine the worst-performing objective\n    obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    worst_obj = 1 if obj1 >= obj2 and obj1 >= obj3 else (2 if obj2 >= obj1 and obj2 >= obj3 else 3)\n\n    # Apply adaptive 3-opt local search targeting the worst objective\n    for _ in range(5):\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Calculate current cost for the worst objective\n        if worst_obj == 1:\n            current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        elif worst_obj == 2:\n            current_cost = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n        else:\n            current_cost = (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Try all 3-opt configurations\n        configurations = [\n            [new_solution[i], new_solution[j], new_solution[k]],\n            [new_solution[i], new_solution[k], new_solution[j]],\n            [new_solution[j], new_solution[i], new_solution[k]],\n            [new_solution[j], new_solution[k], new_solution[i]],\n            [new_solution[k], new_solution[i], new_solution[j]],\n            [new_solution[k], new_solution[j], new_solution[i]]\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            # Calculate new cost for the worst objective\n            if worst_obj == 1:\n                new_cost = (distance_matrix_1[config[0], config[1]] +\n                            distance_matrix_1[config[1], config[2]] +\n                            distance_matrix_1[config[2], new_solution[(k+1)%n]])\n            elif worst_obj == 2:\n                new_cost = (distance_matrix_2[config[0], config[1]] +\n                            distance_matrix_2[config[1], config[2]] +\n                            distance_matrix_2[config[2], new_solution[(k+1)%n]])\n            else:\n                new_cost = (distance_matrix_3[config[0], config[1]] +\n                            distance_matrix_3[config[1], config[2]] +\n                            distance_matrix_3[config[2], new_solution[(k+1)%n]])\n\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            # Apply the best configuration\n            new_solution[i] = best_config[0]\n            new_solution[j] = best_config[1]\n            new_solution[k] = best_config[2]\n\n    # Apply segment inversion targeting the worst objective\n    start = random.randint(0, n-1)\n    length = random.randint(1, n//2)\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate((new_solution[start:], new_solution[:end]))\n\n    # Calculate segment cost in worst objective\n    if worst_obj == 1:\n        segment_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    elif worst_obj == 2:\n        segment_cost = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    else:\n        segment_cost = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert the segment if it improves the worst objective\n    inverted_segment = segment[::-1]\n    if worst_obj == 1:\n        inverted_cost = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    elif worst_obj == 2:\n        inverted_cost = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    else:\n        inverted_cost = sum(distance_matrix_3[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    if inverted_cost < segment_cost:\n        if start < end:\n            new_solution[start:end] = inverted_segment\n        else:\n            new_solution[start:] = inverted_segment[:n-start]\n            new_solution[:end] = inverted_segment[n-start:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective segment crossover operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware 3-opt refinement step that prioritizes improving the worst-performing objective in each iteration, using a dynamic weighting scheme based on current solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution by combining segments with dynamic selection\n    new_solution = []\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware 3-opt refinement\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Try all 3-opt configurations\n        configurations = [\n            (i, j, k, [new_solution[i], new_solution[j], new_solution[k], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n]]),\n            (i, j, k, [new_solution[i], new_solution[k], new_solution[j], new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n]]),\n            (i, j, k, [new_solution[i], new_solution[j], new_solution[(i+1)%n], new_solution[k], new_solution[(j+1)%n], new_solution[(k+1)%n]]),\n            (i, j, k, [new_solution[i], new_solution[k], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n], new_solution[(k+1)%n]])\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            _, _, _, nodes = config\n            new_cost = (distance_matrix_1[nodes[0], nodes[1]] + distance_matrix_2[nodes[0], nodes[1]] + distance_matrix_3[nodes[0], nodes[1]],\n                        distance_matrix_1[nodes[2], nodes[3]] + distance_matrix_2[nodes[2], nodes[3]] + distance_matrix_3[nodes[2], nodes[3]],\n                        distance_matrix_1[nodes[4], nodes[5]] + distance_matrix_2[nodes[4], nodes[5]] + distance_matrix_3[nodes[4], nodes[5]])\n\n            # Calculate improvement (prioritize worst objective)\n            improvement = min(current_cost[obj] - new_cost[obj] for obj in range(3))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            _, _, _, nodes = best_config\n            # Apply the best configuration\n            new_solution[i] = nodes[0]\n            new_solution[j] = nodes[1]\n            new_solution[k] = nodes[2]\n            new_solution[(i+1)%n] = nodes[3]\n            new_solution[(j+1)%n] = nodes[4]\n            new_solution[(k+1)%n] = nodes[5]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new algorithm employs a hybrid crossover operator that combines segments from multiple archive solutions using a dynamic segment selection mechanism, followed by an adaptive 2.5-opt refinement step that prioritizes improving the most underperforming objective in each iteration, with a dynamic weighting scheme that adjusts based on current solution quality and historical improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    n = len(base_solution)\n\n    # Hybrid crossover with dynamic segment selection\n    new_solution = []\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        # Randomly select between 2-4 archive solutions for each segment\n        sources = random.sample(archive, min(4, len(archive)))\n        best_segment = None\n        best_score = float('inf')\n\n        for source in sources:\n            segment = source[0][i:i+segment_length]\n            # Evaluate segment quality based on all three objectives\n            segment_cost = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]]\n                              for j in range(len(segment)))\n            if segment_cost < best_score:\n                best_score = segment_cost\n                best_segment = segment\n\n        new_solution.extend(best_segment)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive 2.5-opt refinement\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        # Calculate current cost\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # Try all 2.5-opt configurations\n        configurations = [\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[k], new_solution[l],\n                          new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[k], new_solution[j], new_solution[l],\n                          new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[l], new_solution[k],\n                          new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[k],\n                          new_solution[(i+1)%n], new_solution[l], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]])\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            _, _, _, _, nodes = config\n            new_cost = (distance_matrix_1[nodes[0], nodes[1]] + distance_matrix_2[nodes[0], nodes[1]] + distance_matrix_3[nodes[0], nodes[1]] +\n                        distance_matrix_1[nodes[2], nodes[3]] + distance_matrix_2[nodes[2], nodes[3]] + distance_matrix_3[nodes[2], nodes[3]] +\n                        distance_matrix_1[nodes[4], nodes[5]] + distance_matrix_2[nodes[4], nodes[5]] + distance_matrix_3[nodes[4], nodes[5]] +\n                        distance_matrix_1[nodes[6], nodes[7]] + distance_matrix_2[nodes[6], nodes[7]] + distance_matrix_3[nodes[6], nodes[7]])\n\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            _, _, _, _, nodes = best_config\n            new_solution[i] = nodes[0]\n            new_solution[j] = nodes[1]\n            new_solution[k] = nodes[2]\n            new_solution[l] = nodes[3]\n            new_solution[(i+1)%n] = nodes[4]\n            new_solution[(j+1)%n] = nodes[5]\n            new_solution[(k+1)%n] = nodes[6]\n            new_solution[(l+1)%n] = nodes[7]\n\n    return new_solution\n\n",
        "score": [
            -0.7159101865795293,
            0.41984052658081056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    n = len(base_solution)\n\n    # Hybrid crossover with dynamic segment selection\n    new_solution = []\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        # Randomly select between 2-4 archive solutions for each segment\n        sources = random.sample(archive, min(4, len(archive)))\n        best_segment = None\n        best_score = float('inf')\n\n        for source in sources:\n            segment = source[0][i:i+segment_length]\n            # Evaluate segment quality based on all three objectives\n            segment_cost = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] +\n                              distance_matrix_3[segment[j], segment[(j+1)%len(segment)]]\n                              for j in range(len(segment)))\n            if segment_cost < best_score:\n                best_score = segment_cost\n                best_segment = segment\n\n        new_solution.extend(best_segment)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive 2.5-opt refinement\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        # Calculate current cost\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # Try all 2.5-opt configurations\n        configurations = [\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[k], new_solution[l],\n                          new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[k], new_solution[j], new_solution[l],\n                          new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[l], new_solution[k],\n                          new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]]),\n            (i, j, k, l, [new_solution[i], new_solution[j], new_solution[k],\n                          new_solution[(i+1)%n], new_solution[l], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n]])\n        ]\n\n        best_config = None\n        best_improvement = -float('inf')\n\n        for config in configurations:\n            _, _, _, _, nodes = config\n            new_cost = (distance_matrix_1[nodes[0], nodes[1]] + distance_matrix_2[nodes[0], nodes[1]] + distance_matrix_3[nodes[0], nodes[1]] +\n                        distance_matrix_1[nodes[2], nodes[3]] + distance_matrix_2[nodes[2], nodes[3]] + distance_matrix_3[nodes[2], nodes[3]] +\n                        distance_matrix_1[nodes[4], nodes[5]] + distance_matrix_2[nodes[4], nodes[5]] + distance_matrix_3[nodes[4], nodes[5]] +\n                        distance_matrix_1[nodes[6], nodes[7]] + distance_matrix_2[nodes[6], nodes[7]] + distance_matrix_3[nodes[6], nodes[7]])\n\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_improvement > 0:\n            _, _, _, _, nodes = best_config\n            new_solution[i] = nodes[0]\n            new_solution[j] = nodes[1]\n            new_solution[k] = nodes[2]\n            new_solution[l] = nodes[3]\n            new_solution[(i+1)%n] = nodes[4]\n            new_solution[(j+1)%n] = nodes[5]\n            new_solution[(k+1)%n] = nodes[6]\n            new_solution[(l+1)%n] = nodes[7]\n\n    return new_solution\n\n"
    }
]